// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Topology.hxx"

namespace xsd
{
  namespace qif2
  {
    // TopologySetType
    // 

    const TopologySetType::VertexSet_optional& TopologySetType::
    VertexSet () const
    {
      return this->VertexSet_;
    }

    TopologySetType::VertexSet_optional& TopologySetType::
    VertexSet ()
    {
      return this->VertexSet_;
    }

    void TopologySetType::
    VertexSet (const VertexSet_type& x)
    {
      this->VertexSet_.set (x);
    }

    void TopologySetType::
    VertexSet (const VertexSet_optional& x)
    {
      this->VertexSet_ = x;
    }

    void TopologySetType::
    VertexSet (::std::auto_ptr< VertexSet_type > x)
    {
      this->VertexSet_.set (x);
    }

    const TopologySetType::EdgeSet_optional& TopologySetType::
    EdgeSet () const
    {
      return this->EdgeSet_;
    }

    TopologySetType::EdgeSet_optional& TopologySetType::
    EdgeSet ()
    {
      return this->EdgeSet_;
    }

    void TopologySetType::
    EdgeSet (const EdgeSet_type& x)
    {
      this->EdgeSet_.set (x);
    }

    void TopologySetType::
    EdgeSet (const EdgeSet_optional& x)
    {
      this->EdgeSet_ = x;
    }

    void TopologySetType::
    EdgeSet (::std::auto_ptr< EdgeSet_type > x)
    {
      this->EdgeSet_.set (x);
    }

    const TopologySetType::LoopSet_optional& TopologySetType::
    LoopSet () const
    {
      return this->LoopSet_;
    }

    TopologySetType::LoopSet_optional& TopologySetType::
    LoopSet ()
    {
      return this->LoopSet_;
    }

    void TopologySetType::
    LoopSet (const LoopSet_type& x)
    {
      this->LoopSet_.set (x);
    }

    void TopologySetType::
    LoopSet (const LoopSet_optional& x)
    {
      this->LoopSet_ = x;
    }

    void TopologySetType::
    LoopSet (::std::auto_ptr< LoopSet_type > x)
    {
      this->LoopSet_.set (x);
    }

    const TopologySetType::FaceSet_optional& TopologySetType::
    FaceSet () const
    {
      return this->FaceSet_;
    }

    TopologySetType::FaceSet_optional& TopologySetType::
    FaceSet ()
    {
      return this->FaceSet_;
    }

    void TopologySetType::
    FaceSet (const FaceSet_type& x)
    {
      this->FaceSet_.set (x);
    }

    void TopologySetType::
    FaceSet (const FaceSet_optional& x)
    {
      this->FaceSet_ = x;
    }

    void TopologySetType::
    FaceSet (::std::auto_ptr< FaceSet_type > x)
    {
      this->FaceSet_.set (x);
    }

    const TopologySetType::ShellSet_optional& TopologySetType::
    ShellSet () const
    {
      return this->ShellSet_;
    }

    TopologySetType::ShellSet_optional& TopologySetType::
    ShellSet ()
    {
      return this->ShellSet_;
    }

    void TopologySetType::
    ShellSet (const ShellSet_type& x)
    {
      this->ShellSet_.set (x);
    }

    void TopologySetType::
    ShellSet (const ShellSet_optional& x)
    {
      this->ShellSet_ = x;
    }

    void TopologySetType::
    ShellSet (::std::auto_ptr< ShellSet_type > x)
    {
      this->ShellSet_.set (x);
    }

    const TopologySetType::BodySet_optional& TopologySetType::
    BodySet () const
    {
      return this->BodySet_;
    }

    TopologySetType::BodySet_optional& TopologySetType::
    BodySet ()
    {
      return this->BodySet_;
    }

    void TopologySetType::
    BodySet (const BodySet_type& x)
    {
      this->BodySet_.set (x);
    }

    void TopologySetType::
    BodySet (const BodySet_optional& x)
    {
      this->BodySet_ = x;
    }

    void TopologySetType::
    BodySet (::std::auto_ptr< BodySet_type > x)
    {
      this->BodySet_.set (x);
    }

    const TopologySetType::PointCloudSet_optional& TopologySetType::
    PointCloudSet () const
    {
      return this->PointCloudSet_;
    }

    TopologySetType::PointCloudSet_optional& TopologySetType::
    PointCloudSet ()
    {
      return this->PointCloudSet_;
    }

    void TopologySetType::
    PointCloudSet (const PointCloudSet_type& x)
    {
      this->PointCloudSet_.set (x);
    }

    void TopologySetType::
    PointCloudSet (const PointCloudSet_optional& x)
    {
      this->PointCloudSet_ = x;
    }

    void TopologySetType::
    PointCloudSet (::std::auto_ptr< PointCloudSet_type > x)
    {
      this->PointCloudSet_.set (x);
    }


    // TopologyBaseType
    // 


    // VertexSetType
    // 

    const VertexSetType::Vertex_sequence& VertexSetType::
    Vertex () const
    {
      return this->Vertex_;
    }

    VertexSetType::Vertex_sequence& VertexSetType::
    Vertex ()
    {
      return this->Vertex_;
    }

    void VertexSetType::
    Vertex (const Vertex_sequence& s)
    {
      this->Vertex_ = s;
    }

    const VertexSetType::N_type& VertexSetType::
    N () const
    {
      return this->N_.get ();
    }

    VertexSetType::N_type& VertexSetType::
    N ()
    {
      return this->N_.get ();
    }

    void VertexSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void VertexSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // VertexType
    // 

    const VertexType::Point_type& VertexType::
    Point () const
    {
      return this->Point_.get ();
    }

    VertexType::Point_type& VertexType::
    Point ()
    {
      return this->Point_.get ();
    }

    void VertexType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void VertexType::
    Point (::std::auto_ptr< Point_type > x)
    {
      this->Point_.set (x);
    }

    const VertexType::tolerance_optional& VertexType::
    tolerance () const
    {
      return this->tolerance_;
    }

    VertexType::tolerance_optional& VertexType::
    tolerance ()
    {
      return this->tolerance_;
    }

    void VertexType::
    tolerance (const tolerance_type& x)
    {
      this->tolerance_.set (x);
    }

    void VertexType::
    tolerance (const tolerance_optional& x)
    {
      this->tolerance_ = x;
    }


    // EdgeSetType
    // 

    const EdgeSetType::Edge_sequence& EdgeSetType::
    Edge () const
    {
      return this->Edge_;
    }

    EdgeSetType::Edge_sequence& EdgeSetType::
    Edge ()
    {
      return this->Edge_;
    }

    void EdgeSetType::
    Edge (const Edge_sequence& s)
    {
      this->Edge_ = s;
    }

    const EdgeSetType::N_type& EdgeSetType::
    N () const
    {
      return this->N_.get ();
    }

    EdgeSetType::N_type& EdgeSetType::
    N ()
    {
      return this->N_.get ();
    }

    void EdgeSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void EdgeSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // EdgeType
    // 

    const EdgeType::Curve_type& EdgeType::
    Curve () const
    {
      return this->Curve_.get ();
    }

    EdgeType::Curve_type& EdgeType::
    Curve ()
    {
      return this->Curve_.get ();
    }

    void EdgeType::
    Curve (const Curve_type& x)
    {
      this->Curve_.set (x);
    }

    void EdgeType::
    Curve (::std::auto_ptr< Curve_type > x)
    {
      this->Curve_.set (x);
    }

    const EdgeType::VertexBeg_type& EdgeType::
    VertexBeg () const
    {
      return this->VertexBeg_.get ();
    }

    EdgeType::VertexBeg_type& EdgeType::
    VertexBeg ()
    {
      return this->VertexBeg_.get ();
    }

    void EdgeType::
    VertexBeg (const VertexBeg_type& x)
    {
      this->VertexBeg_.set (x);
    }

    void EdgeType::
    VertexBeg (::std::auto_ptr< VertexBeg_type > x)
    {
      this->VertexBeg_.set (x);
    }

    const EdgeType::VertexEnd_type& EdgeType::
    VertexEnd () const
    {
      return this->VertexEnd_.get ();
    }

    EdgeType::VertexEnd_type& EdgeType::
    VertexEnd ()
    {
      return this->VertexEnd_.get ();
    }

    void EdgeType::
    VertexEnd (const VertexEnd_type& x)
    {
      this->VertexEnd_.set (x);
    }

    void EdgeType::
    VertexEnd (::std::auto_ptr< VertexEnd_type > x)
    {
      this->VertexEnd_.set (x);
    }

    const EdgeType::tolerance_optional& EdgeType::
    tolerance () const
    {
      return this->tolerance_;
    }

    EdgeType::tolerance_optional& EdgeType::
    tolerance ()
    {
      return this->tolerance_;
    }

    void EdgeType::
    tolerance (const tolerance_type& x)
    {
      this->tolerance_.set (x);
    }

    void EdgeType::
    tolerance (const tolerance_optional& x)
    {
      this->tolerance_ = x;
    }


    // LoopSetType
    // 

    const LoopSetType::LoopBase_sequence& LoopSetType::
    LoopBase () const
    {
      return this->LoopBase_;
    }

    LoopSetType::LoopBase_sequence& LoopSetType::
    LoopBase ()
    {
      return this->LoopBase_;
    }

    void LoopSetType::
    LoopBase (const LoopBase_sequence& s)
    {
      this->LoopBase_ = s;
    }

    const LoopSetType::N_type& LoopSetType::
    N () const
    {
      return this->N_.get ();
    }

    LoopSetType::N_type& LoopSetType::
    N ()
    {
      return this->N_.get ();
    }

    void LoopSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void LoopSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // LoopBaseType
    // 


    // LoopFormEnumType
    // 

    LoopFormEnumType::
    LoopFormEnumType (value v)
    : ::xml_schema::string (_xsd_LoopFormEnumType_literals_[v])
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const LoopFormEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LoopFormEnumType& LoopFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LoopFormEnumType_literals_[v]);

      return *this;
    }


    // EdgeOrientedType
    // 

    const EdgeOrientedType::turned_type& EdgeOrientedType::
    turned () const
    {
      return this->turned_.get ();
    }

    EdgeOrientedType::turned_type& EdgeOrientedType::
    turned ()
    {
      return this->turned_.get ();
    }

    void EdgeOrientedType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    EdgeOrientedType::turned_type EdgeOrientedType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // CoEdgeType
    // 

    const CoEdgeType::EdgeOriented_type& CoEdgeType::
    EdgeOriented () const
    {
      return this->EdgeOriented_.get ();
    }

    CoEdgeType::EdgeOriented_type& CoEdgeType::
    EdgeOriented ()
    {
      return this->EdgeOriented_.get ();
    }

    void CoEdgeType::
    EdgeOriented (const EdgeOriented_type& x)
    {
      this->EdgeOriented_.set (x);
    }

    void CoEdgeType::
    EdgeOriented (::std::auto_ptr< EdgeOriented_type > x)
    {
      this->EdgeOriented_.set (x);
    }

    const CoEdgeType::Curve12_optional& CoEdgeType::
    Curve12 () const
    {
      return this->Curve12_;
    }

    CoEdgeType::Curve12_optional& CoEdgeType::
    Curve12 ()
    {
      return this->Curve12_;
    }

    void CoEdgeType::
    Curve12 (const Curve12_type& x)
    {
      this->Curve12_.set (x);
    }

    void CoEdgeType::
    Curve12 (const Curve12_optional& x)
    {
      this->Curve12_ = x;
    }

    void CoEdgeType::
    Curve12 (::std::auto_ptr< Curve12_type > x)
    {
      this->Curve12_.set (x);
    }


    // CoEdgesType
    // 

    const CoEdgesType::CoEdge_sequence& CoEdgesType::
    CoEdge () const
    {
      return this->CoEdge_;
    }

    CoEdgesType::CoEdge_sequence& CoEdgesType::
    CoEdge ()
    {
      return this->CoEdge_;
    }

    void CoEdgesType::
    CoEdge (const CoEdge_sequence& s)
    {
      this->CoEdge_ = s;
    }

    const CoEdgesType::N_type& CoEdgesType::
    N () const
    {
      return this->N_.get ();
    }

    CoEdgesType::N_type& CoEdgesType::
    N ()
    {
      return this->N_.get ();
    }

    void CoEdgesType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void CoEdgesType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // CoEdgeMeshType
    // 

    const CoEdgeMeshType::EdgeOriented_type& CoEdgeMeshType::
    EdgeOriented () const
    {
      return this->EdgeOriented_.get ();
    }

    CoEdgeMeshType::EdgeOriented_type& CoEdgeMeshType::
    EdgeOriented ()
    {
      return this->EdgeOriented_.get ();
    }

    void CoEdgeMeshType::
    EdgeOriented (const EdgeOriented_type& x)
    {
      this->EdgeOriented_.set (x);
    }

    void CoEdgeMeshType::
    EdgeOriented (::std::auto_ptr< EdgeOriented_type > x)
    {
      this->EdgeOriented_.set (x);
    }

    const CoEdgeMeshType::CurveMesh_optional& CoEdgeMeshType::
    CurveMesh () const
    {
      return this->CurveMesh_;
    }

    CoEdgeMeshType::CurveMesh_optional& CoEdgeMeshType::
    CurveMesh ()
    {
      return this->CurveMesh_;
    }

    void CoEdgeMeshType::
    CurveMesh (const CurveMesh_type& x)
    {
      this->CurveMesh_.set (x);
    }

    void CoEdgeMeshType::
    CurveMesh (const CurveMesh_optional& x)
    {
      this->CurveMesh_ = x;
    }

    void CoEdgeMeshType::
    CurveMesh (::std::auto_ptr< CurveMesh_type > x)
    {
      this->CurveMesh_.set (x);
    }


    // CoEdgesMeshType
    // 

    const CoEdgesMeshType::CoEdgeMesh_sequence& CoEdgesMeshType::
    CoEdgeMesh () const
    {
      return this->CoEdgeMesh_;
    }

    CoEdgesMeshType::CoEdgeMesh_sequence& CoEdgesMeshType::
    CoEdgeMesh ()
    {
      return this->CoEdgeMesh_;
    }

    void CoEdgesMeshType::
    CoEdgeMesh (const CoEdgeMesh_sequence& s)
    {
      this->CoEdgeMesh_ = s;
    }

    const CoEdgesMeshType::N_type& CoEdgesMeshType::
    N () const
    {
      return this->N_.get ();
    }

    CoEdgesMeshType::N_type& CoEdgesMeshType::
    N ()
    {
      return this->N_.get ();
    }

    void CoEdgesMeshType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void CoEdgesMeshType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // LoopType
    // 

    const LoopType::CoEdges_type& LoopType::
    CoEdges () const
    {
      return this->CoEdges_.get ();
    }

    LoopType::CoEdges_type& LoopType::
    CoEdges ()
    {
      return this->CoEdges_.get ();
    }

    void LoopType::
    CoEdges (const CoEdges_type& x)
    {
      this->CoEdges_.set (x);
    }

    void LoopType::
    CoEdges (::std::auto_ptr< CoEdges_type > x)
    {
      this->CoEdges_.set (x);
    }

    const LoopType::form_type& LoopType::
    form () const
    {
      return this->form_.get ();
    }

    LoopType::form_type& LoopType::
    form ()
    {
      return this->form_.get ();
    }

    void LoopType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void LoopType::
    form (::std::auto_ptr< form_type > x)
    {
      this->form_.set (x);
    }

    const LoopType::form_type& LoopType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // LoopMeshType
    // 

    const LoopMeshType::CoEdgesMesh_type& LoopMeshType::
    CoEdgesMesh () const
    {
      return this->CoEdgesMesh_.get ();
    }

    LoopMeshType::CoEdgesMesh_type& LoopMeshType::
    CoEdgesMesh ()
    {
      return this->CoEdgesMesh_.get ();
    }

    void LoopMeshType::
    CoEdgesMesh (const CoEdgesMesh_type& x)
    {
      this->CoEdgesMesh_.set (x);
    }

    void LoopMeshType::
    CoEdgesMesh (::std::auto_ptr< CoEdgesMesh_type > x)
    {
      this->CoEdgesMesh_.set (x);
    }


    // FaceSetType
    // 

    const FaceSetType::FaceBase_sequence& FaceSetType::
    FaceBase () const
    {
      return this->FaceBase_;
    }

    FaceSetType::FaceBase_sequence& FaceSetType::
    FaceBase ()
    {
      return this->FaceBase_;
    }

    void FaceSetType::
    FaceBase (const FaceBase_sequence& s)
    {
      this->FaceBase_ = s;
    }

    const FaceSetType::N_type& FaceSetType::
    N () const
    {
      return this->N_.get ();
    }

    FaceSetType::N_type& FaceSetType::
    N ()
    {
      return this->N_.get ();
    }

    void FaceSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void FaceSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // FaceBaseType
    // 

    const FaceBaseType::InertiaMatrix_optional& FaceBaseType::
    InertiaMatrix () const
    {
      return this->InertiaMatrix_;
    }

    FaceBaseType::InertiaMatrix_optional& FaceBaseType::
    InertiaMatrix ()
    {
      return this->InertiaMatrix_;
    }

    void FaceBaseType::
    InertiaMatrix (const InertiaMatrix_type& x)
    {
      this->InertiaMatrix_.set (x);
    }

    void FaceBaseType::
    InertiaMatrix (const InertiaMatrix_optional& x)
    {
      this->InertiaMatrix_ = x;
    }

    void FaceBaseType::
    InertiaMatrix (::std::auto_ptr< InertiaMatrix_type > x)
    {
      this->InertiaMatrix_.set (x);
    }

    const FaceBaseType::turned_type& FaceBaseType::
    turned () const
    {
      return this->turned_.get ();
    }

    FaceBaseType::turned_type& FaceBaseType::
    turned ()
    {
      return this->turned_.get ();
    }

    void FaceBaseType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    FaceBaseType::turned_type FaceBaseType::
    turned_default_value ()
    {
      return turned_type (false);
    }

    const FaceBaseType::area_optional& FaceBaseType::
    area () const
    {
      return this->area_;
    }

    FaceBaseType::area_optional& FaceBaseType::
    area ()
    {
      return this->area_;
    }

    void FaceBaseType::
    area (const area_type& x)
    {
      this->area_.set (x);
    }

    void FaceBaseType::
    area (const area_optional& x)
    {
      this->area_ = x;
    }

    const FaceBaseType::volume_optional& FaceBaseType::
    volume () const
    {
      return this->volume_;
    }

    FaceBaseType::volume_optional& FaceBaseType::
    volume ()
    {
      return this->volume_;
    }

    void FaceBaseType::
    volume (const volume_type& x)
    {
      this->volume_.set (x);
    }

    void FaceBaseType::
    volume (const volume_optional& x)
    {
      this->volume_ = x;
    }

    const FaceBaseType::massCenter_optional& FaceBaseType::
    massCenter () const
    {
      return this->massCenter_;
    }

    FaceBaseType::massCenter_optional& FaceBaseType::
    massCenter ()
    {
      return this->massCenter_;
    }

    void FaceBaseType::
    massCenter (const massCenter_type& x)
    {
      this->massCenter_.set (x);
    }

    void FaceBaseType::
    massCenter (const massCenter_optional& x)
    {
      this->massCenter_ = x;
    }

    void FaceBaseType::
    massCenter (::std::auto_ptr< massCenter_type > x)
    {
      this->massCenter_.set (x);
    }


    // FaceType
    // 

    const FaceType::Surface_type& FaceType::
    Surface () const
    {
      return this->Surface_.get ();
    }

    FaceType::Surface_type& FaceType::
    Surface ()
    {
      return this->Surface_.get ();
    }

    void FaceType::
    Surface (const Surface_type& x)
    {
      this->Surface_.set (x);
    }

    void FaceType::
    Surface (::std::auto_ptr< Surface_type > x)
    {
      this->Surface_.set (x);
    }

    const FaceType::LoopIds_optional& FaceType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    FaceType::LoopIds_optional& FaceType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void FaceType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void FaceType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void FaceType::
    LoopIds (::std::auto_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (x);
    }

    const FaceType::hasOuter_type& FaceType::
    hasOuter () const
    {
      return this->hasOuter_.get ();
    }

    FaceType::hasOuter_type& FaceType::
    hasOuter ()
    {
      return this->hasOuter_.get ();
    }

    void FaceType::
    hasOuter (const hasOuter_type& x)
    {
      this->hasOuter_.set (x);
    }

    FaceType::hasOuter_type FaceType::
    hasOuter_default_value ()
    {
      return hasOuter_type (true);
    }


    // FaceMeshType
    // 

    const FaceMeshType::Mesh_type& FaceMeshType::
    Mesh () const
    {
      return this->Mesh_.get ();
    }

    FaceMeshType::Mesh_type& FaceMeshType::
    Mesh ()
    {
      return this->Mesh_.get ();
    }

    void FaceMeshType::
    Mesh (const Mesh_type& x)
    {
      this->Mesh_.set (x);
    }

    void FaceMeshType::
    Mesh (::std::auto_ptr< Mesh_type > x)
    {
      this->Mesh_.set (x);
    }

    const FaceMeshType::LoopIds_optional& FaceMeshType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    FaceMeshType::LoopIds_optional& FaceMeshType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void FaceMeshType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void FaceMeshType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void FaceMeshType::
    LoopIds (::std::auto_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (x);
    }

    const FaceMeshType::Triangles_optional& FaceMeshType::
    Triangles () const
    {
      return this->Triangles_;
    }

    FaceMeshType::Triangles_optional& FaceMeshType::
    Triangles ()
    {
      return this->Triangles_;
    }

    void FaceMeshType::
    Triangles (const Triangles_type& x)
    {
      this->Triangles_.set (x);
    }

    void FaceMeshType::
    Triangles (const Triangles_optional& x)
    {
      this->Triangles_ = x;
    }

    void FaceMeshType::
    Triangles (::std::auto_ptr< Triangles_type > x)
    {
      this->Triangles_.set (x);
    }

    const FaceMeshType::TrianglesBinary_optional& FaceMeshType::
    TrianglesBinary () const
    {
      return this->TrianglesBinary_;
    }

    FaceMeshType::TrianglesBinary_optional& FaceMeshType::
    TrianglesBinary ()
    {
      return this->TrianglesBinary_;
    }

    void FaceMeshType::
    TrianglesBinary (const TrianglesBinary_type& x)
    {
      this->TrianglesBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesBinary (const TrianglesBinary_optional& x)
    {
      this->TrianglesBinary_ = x;
    }

    void FaceMeshType::
    TrianglesBinary (::std::auto_ptr< TrianglesBinary_type > x)
    {
      this->TrianglesBinary_.set (x);
    }

    const FaceMeshType::TrianglesVisible_optional& FaceMeshType::
    TrianglesVisible () const
    {
      return this->TrianglesVisible_;
    }

    FaceMeshType::TrianglesVisible_optional& FaceMeshType::
    TrianglesVisible ()
    {
      return this->TrianglesVisible_;
    }

    void FaceMeshType::
    TrianglesVisible (const TrianglesVisible_type& x)
    {
      this->TrianglesVisible_.set (x);
    }

    void FaceMeshType::
    TrianglesVisible (const TrianglesVisible_optional& x)
    {
      this->TrianglesVisible_ = x;
    }

    void FaceMeshType::
    TrianglesVisible (::std::auto_ptr< TrianglesVisible_type > x)
    {
      this->TrianglesVisible_.set (x);
    }

    const FaceMeshType::TrianglesVisibleBinary_optional& FaceMeshType::
    TrianglesVisibleBinary () const
    {
      return this->TrianglesVisibleBinary_;
    }

    FaceMeshType::TrianglesVisibleBinary_optional& FaceMeshType::
    TrianglesVisibleBinary ()
    {
      return this->TrianglesVisibleBinary_;
    }

    void FaceMeshType::
    TrianglesVisibleBinary (const TrianglesVisibleBinary_type& x)
    {
      this->TrianglesVisibleBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesVisibleBinary (const TrianglesVisibleBinary_optional& x)
    {
      this->TrianglesVisibleBinary_ = x;
    }

    void FaceMeshType::
    TrianglesVisibleBinary (::std::auto_ptr< TrianglesVisibleBinary_type > x)
    {
      this->TrianglesVisibleBinary_.set (x);
    }

    const FaceMeshType::TrianglesHidden_optional& FaceMeshType::
    TrianglesHidden () const
    {
      return this->TrianglesHidden_;
    }

    FaceMeshType::TrianglesHidden_optional& FaceMeshType::
    TrianglesHidden ()
    {
      return this->TrianglesHidden_;
    }

    void FaceMeshType::
    TrianglesHidden (const TrianglesHidden_type& x)
    {
      this->TrianglesHidden_.set (x);
    }

    void FaceMeshType::
    TrianglesHidden (const TrianglesHidden_optional& x)
    {
      this->TrianglesHidden_ = x;
    }

    void FaceMeshType::
    TrianglesHidden (::std::auto_ptr< TrianglesHidden_type > x)
    {
      this->TrianglesHidden_.set (x);
    }

    const FaceMeshType::TrianglesHiddenBinary_optional& FaceMeshType::
    TrianglesHiddenBinary () const
    {
      return this->TrianglesHiddenBinary_;
    }

    FaceMeshType::TrianglesHiddenBinary_optional& FaceMeshType::
    TrianglesHiddenBinary ()
    {
      return this->TrianglesHiddenBinary_;
    }

    void FaceMeshType::
    TrianglesHiddenBinary (const TrianglesHiddenBinary_type& x)
    {
      this->TrianglesHiddenBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesHiddenBinary (const TrianglesHiddenBinary_optional& x)
    {
      this->TrianglesHiddenBinary_ = x;
    }

    void FaceMeshType::
    TrianglesHiddenBinary (::std::auto_ptr< TrianglesHiddenBinary_type > x)
    {
      this->TrianglesHiddenBinary_.set (x);
    }

    const FaceMeshType::TrianglesColor_optional& FaceMeshType::
    TrianglesColor () const
    {
      return this->TrianglesColor_;
    }

    FaceMeshType::TrianglesColor_optional& FaceMeshType::
    TrianglesColor ()
    {
      return this->TrianglesColor_;
    }

    void FaceMeshType::
    TrianglesColor (const TrianglesColor_type& x)
    {
      this->TrianglesColor_.set (x);
    }

    void FaceMeshType::
    TrianglesColor (const TrianglesColor_optional& x)
    {
      this->TrianglesColor_ = x;
    }

    void FaceMeshType::
    TrianglesColor (::std::auto_ptr< TrianglesColor_type > x)
    {
      this->TrianglesColor_.set (x);
    }

    const FaceMeshType::TrianglesColorBinary_optional& FaceMeshType::
    TrianglesColorBinary () const
    {
      return this->TrianglesColorBinary_;
    }

    FaceMeshType::TrianglesColorBinary_optional& FaceMeshType::
    TrianglesColorBinary ()
    {
      return this->TrianglesColorBinary_;
    }

    void FaceMeshType::
    TrianglesColorBinary (const TrianglesColorBinary_type& x)
    {
      this->TrianglesColorBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesColorBinary (const TrianglesColorBinary_optional& x)
    {
      this->TrianglesColorBinary_ = x;
    }

    void FaceMeshType::
    TrianglesColorBinary (::std::auto_ptr< TrianglesColorBinary_type > x)
    {
      this->TrianglesColorBinary_.set (x);
    }


    // ShellSetType
    // 

    const ShellSetType::Shell_sequence& ShellSetType::
    Shell () const
    {
      return this->Shell_;
    }

    ShellSetType::Shell_sequence& ShellSetType::
    Shell ()
    {
      return this->Shell_;
    }

    void ShellSetType::
    Shell (const Shell_sequence& s)
    {
      this->Shell_ = s;
    }

    const ShellSetType::N_type& ShellSetType::
    N () const
    {
      return this->N_.get ();
    }

    ShellSetType::N_type& ShellSetType::
    N ()
    {
      return this->N_.get ();
    }

    void ShellSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void ShellSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // ShellFormEnumType
    // 

    ShellFormEnumType::
    ShellFormEnumType (value v)
    : ::xml_schema::string (_xsd_ShellFormEnumType_literals_[v])
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ShellFormEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ShellFormEnumType& ShellFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ShellFormEnumType_literals_[v]);

      return *this;
    }


    // ShellType
    // 

    const ShellType::FaceIds_optional& ShellType::
    FaceIds () const
    {
      return this->FaceIds_;
    }

    ShellType::FaceIds_optional& ShellType::
    FaceIds ()
    {
      return this->FaceIds_;
    }

    void ShellType::
    FaceIds (const FaceIds_type& x)
    {
      this->FaceIds_.set (x);
    }

    void ShellType::
    FaceIds (const FaceIds_optional& x)
    {
      this->FaceIds_ = x;
    }

    void ShellType::
    FaceIds (::std::auto_ptr< FaceIds_type > x)
    {
      this->FaceIds_.set (x);
    }

    const ShellType::turned_type& ShellType::
    turned () const
    {
      return this->turned_.get ();
    }

    ShellType::turned_type& ShellType::
    turned ()
    {
      return this->turned_.get ();
    }

    void ShellType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    ShellType::turned_type ShellType::
    turned_default_value ()
    {
      return turned_type (false);
    }

    const ShellType::closed_type& ShellType::
    closed () const
    {
      return this->closed_.get ();
    }

    ShellType::closed_type& ShellType::
    closed ()
    {
      return this->closed_.get ();
    }

    void ShellType::
    closed (const closed_type& x)
    {
      this->closed_.set (x);
    }

    ShellType::closed_type ShellType::
    closed_default_value ()
    {
      return closed_type (false);
    }

    const ShellType::form_type& ShellType::
    form () const
    {
      return this->form_.get ();
    }

    ShellType::form_type& ShellType::
    form ()
    {
      return this->form_.get ();
    }

    void ShellType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void ShellType::
    form (::std::auto_ptr< form_type > x)
    {
      this->form_.set (x);
    }

    const ShellType::form_type& ShellType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // BodySetType
    // 

    const BodySetType::Body_sequence& BodySetType::
    Body () const
    {
      return this->Body_;
    }

    BodySetType::Body_sequence& BodySetType::
    Body ()
    {
      return this->Body_;
    }

    void BodySetType::
    Body (const Body_sequence& s)
    {
      this->Body_ = s;
    }

    const BodySetType::N_type& BodySetType::
    N () const
    {
      return this->N_.get ();
    }

    BodySetType::N_type& BodySetType::
    N ()
    {
      return this->N_.get ();
    }

    void BodySetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void BodySetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // BodyType
    // 

    const BodyType::Transform_optional& BodyType::
    Transform () const
    {
      return this->Transform_;
    }

    BodyType::Transform_optional& BodyType::
    Transform ()
    {
      return this->Transform_;
    }

    void BodyType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void BodyType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void BodyType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const BodyType::ShellIds_optional& BodyType::
    ShellIds () const
    {
      return this->ShellIds_;
    }

    BodyType::ShellIds_optional& BodyType::
    ShellIds ()
    {
      return this->ShellIds_;
    }

    void BodyType::
    ShellIds (const ShellIds_type& x)
    {
      this->ShellIds_.set (x);
    }

    void BodyType::
    ShellIds (const ShellIds_optional& x)
    {
      this->ShellIds_ = x;
    }

    void BodyType::
    ShellIds (::std::auto_ptr< ShellIds_type > x)
    {
      this->ShellIds_.set (x);
    }

    const BodyType::FaceIds_optional& BodyType::
    FaceIds () const
    {
      return this->FaceIds_;
    }

    BodyType::FaceIds_optional& BodyType::
    FaceIds ()
    {
      return this->FaceIds_;
    }

    void BodyType::
    FaceIds (const FaceIds_type& x)
    {
      this->FaceIds_.set (x);
    }

    void BodyType::
    FaceIds (const FaceIds_optional& x)
    {
      this->FaceIds_ = x;
    }

    void BodyType::
    FaceIds (::std::auto_ptr< FaceIds_type > x)
    {
      this->FaceIds_.set (x);
    }

    const BodyType::LoopIds_optional& BodyType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    BodyType::LoopIds_optional& BodyType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void BodyType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void BodyType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void BodyType::
    LoopIds (::std::auto_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (x);
    }

    const BodyType::EdgeIds_optional& BodyType::
    EdgeIds () const
    {
      return this->EdgeIds_;
    }

    BodyType::EdgeIds_optional& BodyType::
    EdgeIds ()
    {
      return this->EdgeIds_;
    }

    void BodyType::
    EdgeIds (const EdgeIds_type& x)
    {
      this->EdgeIds_.set (x);
    }

    void BodyType::
    EdgeIds (const EdgeIds_optional& x)
    {
      this->EdgeIds_ = x;
    }

    void BodyType::
    EdgeIds (::std::auto_ptr< EdgeIds_type > x)
    {
      this->EdgeIds_.set (x);
    }

    const BodyType::VertexIds_optional& BodyType::
    VertexIds () const
    {
      return this->VertexIds_;
    }

    BodyType::VertexIds_optional& BodyType::
    VertexIds ()
    {
      return this->VertexIds_;
    }

    void BodyType::
    VertexIds (const VertexIds_type& x)
    {
      this->VertexIds_.set (x);
    }

    void BodyType::
    VertexIds (const VertexIds_optional& x)
    {
      this->VertexIds_ = x;
    }

    void BodyType::
    VertexIds (::std::auto_ptr< VertexIds_type > x)
    {
      this->VertexIds_.set (x);
    }


    // PointCloudSetType
    // 

    const PointCloudSetType::PointCloud_sequence& PointCloudSetType::
    PointCloud () const
    {
      return this->PointCloud_;
    }

    PointCloudSetType::PointCloud_sequence& PointCloudSetType::
    PointCloud ()
    {
      return this->PointCloud_;
    }

    void PointCloudSetType::
    PointCloud (const PointCloud_sequence& s)
    {
      this->PointCloud_ = s;
    }

    const PointCloudSetType::N_type& PointCloudSetType::
    N () const
    {
      return this->N_.get ();
    }

    PointCloudSetType::N_type& PointCloudSetType::
    N ()
    {
      return this->N_.get ();
    }

    void PointCloudSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void PointCloudSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // PointCloudType
    // 

    const PointCloudType::Points_optional& PointCloudType::
    Points () const
    {
      return this->Points_;
    }

    PointCloudType::Points_optional& PointCloudType::
    Points ()
    {
      return this->Points_;
    }

    void PointCloudType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void PointCloudType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void PointCloudType::
    Points (::std::auto_ptr< Points_type > x)
    {
      this->Points_.set (x);
    }

    const PointCloudType::PointsBinary_optional& PointCloudType::
    PointsBinary () const
    {
      return this->PointsBinary_;
    }

    PointCloudType::PointsBinary_optional& PointCloudType::
    PointsBinary ()
    {
      return this->PointsBinary_;
    }

    void PointCloudType::
    PointsBinary (const PointsBinary_type& x)
    {
      this->PointsBinary_.set (x);
    }

    void PointCloudType::
    PointsBinary (const PointsBinary_optional& x)
    {
      this->PointsBinary_ = x;
    }

    void PointCloudType::
    PointsBinary (::std::auto_ptr< PointsBinary_type > x)
    {
      this->PointsBinary_.set (x);
    }

    const PointCloudType::Normals_optional& PointCloudType::
    Normals () const
    {
      return this->Normals_;
    }

    PointCloudType::Normals_optional& PointCloudType::
    Normals ()
    {
      return this->Normals_;
    }

    void PointCloudType::
    Normals (const Normals_type& x)
    {
      this->Normals_.set (x);
    }

    void PointCloudType::
    Normals (const Normals_optional& x)
    {
      this->Normals_ = x;
    }

    void PointCloudType::
    Normals (::std::auto_ptr< Normals_type > x)
    {
      this->Normals_.set (x);
    }

    const PointCloudType::NormalsBinary_optional& PointCloudType::
    NormalsBinary () const
    {
      return this->NormalsBinary_;
    }

    PointCloudType::NormalsBinary_optional& PointCloudType::
    NormalsBinary ()
    {
      return this->NormalsBinary_;
    }

    void PointCloudType::
    NormalsBinary (const NormalsBinary_type& x)
    {
      this->NormalsBinary_.set (x);
    }

    void PointCloudType::
    NormalsBinary (const NormalsBinary_optional& x)
    {
      this->NormalsBinary_ = x;
    }

    void PointCloudType::
    NormalsBinary (::std::auto_ptr< NormalsBinary_type > x)
    {
      this->NormalsBinary_.set (x);
    }

    const PointCloudType::PointsVisible_optional& PointCloudType::
    PointsVisible () const
    {
      return this->PointsVisible_;
    }

    PointCloudType::PointsVisible_optional& PointCloudType::
    PointsVisible ()
    {
      return this->PointsVisible_;
    }

    void PointCloudType::
    PointsVisible (const PointsVisible_type& x)
    {
      this->PointsVisible_.set (x);
    }

    void PointCloudType::
    PointsVisible (const PointsVisible_optional& x)
    {
      this->PointsVisible_ = x;
    }

    void PointCloudType::
    PointsVisible (::std::auto_ptr< PointsVisible_type > x)
    {
      this->PointsVisible_.set (x);
    }

    const PointCloudType::PointsVisibleBinary_optional& PointCloudType::
    PointsVisibleBinary () const
    {
      return this->PointsVisibleBinary_;
    }

    PointCloudType::PointsVisibleBinary_optional& PointCloudType::
    PointsVisibleBinary ()
    {
      return this->PointsVisibleBinary_;
    }

    void PointCloudType::
    PointsVisibleBinary (const PointsVisibleBinary_type& x)
    {
      this->PointsVisibleBinary_.set (x);
    }

    void PointCloudType::
    PointsVisibleBinary (const PointsVisibleBinary_optional& x)
    {
      this->PointsVisibleBinary_ = x;
    }

    void PointCloudType::
    PointsVisibleBinary (::std::auto_ptr< PointsVisibleBinary_type > x)
    {
      this->PointsVisibleBinary_.set (x);
    }

    const PointCloudType::PointsHidden_optional& PointCloudType::
    PointsHidden () const
    {
      return this->PointsHidden_;
    }

    PointCloudType::PointsHidden_optional& PointCloudType::
    PointsHidden ()
    {
      return this->PointsHidden_;
    }

    void PointCloudType::
    PointsHidden (const PointsHidden_type& x)
    {
      this->PointsHidden_.set (x);
    }

    void PointCloudType::
    PointsHidden (const PointsHidden_optional& x)
    {
      this->PointsHidden_ = x;
    }

    void PointCloudType::
    PointsHidden (::std::auto_ptr< PointsHidden_type > x)
    {
      this->PointsHidden_.set (x);
    }

    const PointCloudType::PointsHiddenBinary_optional& PointCloudType::
    PointsHiddenBinary () const
    {
      return this->PointsHiddenBinary_;
    }

    PointCloudType::PointsHiddenBinary_optional& PointCloudType::
    PointsHiddenBinary ()
    {
      return this->PointsHiddenBinary_;
    }

    void PointCloudType::
    PointsHiddenBinary (const PointsHiddenBinary_type& x)
    {
      this->PointsHiddenBinary_.set (x);
    }

    void PointCloudType::
    PointsHiddenBinary (const PointsHiddenBinary_optional& x)
    {
      this->PointsHiddenBinary_ = x;
    }

    void PointCloudType::
    PointsHiddenBinary (::std::auto_ptr< PointsHiddenBinary_type > x)
    {
      this->PointsHiddenBinary_.set (x);
    }

    const PointCloudType::PointsColor_optional& PointCloudType::
    PointsColor () const
    {
      return this->PointsColor_;
    }

    PointCloudType::PointsColor_optional& PointCloudType::
    PointsColor ()
    {
      return this->PointsColor_;
    }

    void PointCloudType::
    PointsColor (const PointsColor_type& x)
    {
      this->PointsColor_.set (x);
    }

    void PointCloudType::
    PointsColor (const PointsColor_optional& x)
    {
      this->PointsColor_ = x;
    }

    void PointCloudType::
    PointsColor (::std::auto_ptr< PointsColor_type > x)
    {
      this->PointsColor_.set (x);
    }

    const PointCloudType::PointsColorBinary_optional& PointCloudType::
    PointsColorBinary () const
    {
      return this->PointsColorBinary_;
    }

    PointCloudType::PointsColorBinary_optional& PointCloudType::
    PointsColorBinary ()
    {
      return this->PointsColorBinary_;
    }

    void PointCloudType::
    PointsColorBinary (const PointsColorBinary_type& x)
    {
      this->PointsColorBinary_.set (x);
    }

    void PointCloudType::
    PointsColorBinary (const PointsColorBinary_optional& x)
    {
      this->PointsColorBinary_ = x;
    }

    void PointCloudType::
    PointsColorBinary (::std::auto_ptr< PointsColorBinary_type > x)
    {
      this->PointsColorBinary_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // TopologySetType
    //

    TopologySetType::
    TopologySetType ()
    : ::xml_schema::type (),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (this),
      BodySet_ (this),
      PointCloudSet_ (this)
    {
    }

    TopologySetType::
    TopologySetType (const TopologySetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      VertexSet_ (x.VertexSet_, f, this),
      EdgeSet_ (x.EdgeSet_, f, this),
      LoopSet_ (x.LoopSet_, f, this),
      FaceSet_ (x.FaceSet_, f, this),
      ShellSet_ (x.ShellSet_, f, this),
      BodySet_ (x.BodySet_, f, this),
      PointCloudSet_ (x.PointCloudSet_, f, this)
    {
    }

    TopologySetType::
    TopologySetType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (this),
      BodySet_ (this),
      PointCloudSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TopologySetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // VertexSet
        //
        if (n.name () == "VertexSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexSet_type > r (
            VertexSet_traits::create (i, f, this));

          if (!this->VertexSet_)
          {
            this->VertexSet_.set (r);
            continue;
          }
        }

        // EdgeSet
        //
        if (n.name () == "EdgeSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeSet_type > r (
            EdgeSet_traits::create (i, f, this));

          if (!this->EdgeSet_)
          {
            this->EdgeSet_.set (r);
            continue;
          }
        }

        // LoopSet
        //
        if (n.name () == "LoopSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopSet_type > r (
            LoopSet_traits::create (i, f, this));

          if (!this->LoopSet_)
          {
            this->LoopSet_.set (r);
            continue;
          }
        }

        // FaceSet
        //
        if (n.name () == "FaceSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FaceSet_type > r (
            FaceSet_traits::create (i, f, this));

          if (!this->FaceSet_)
          {
            this->FaceSet_.set (r);
            continue;
          }
        }

        // ShellSet
        //
        if (n.name () == "ShellSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ShellSet_type > r (
            ShellSet_traits::create (i, f, this));

          if (!this->ShellSet_)
          {
            this->ShellSet_.set (r);
            continue;
          }
        }

        // BodySet
        //
        if (n.name () == "BodySet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BodySet_type > r (
            BodySet_traits::create (i, f, this));

          if (!this->BodySet_)
          {
            this->BodySet_.set (r);
            continue;
          }
        }

        // PointCloudSet
        //
        if (n.name () == "PointCloudSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointCloudSet_type > r (
            PointCloudSet_traits::create (i, f, this));

          if (!this->PointCloudSet_)
          {
            this->PointCloudSet_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TopologySetType* TopologySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TopologySetType (*this, f, c);
    }

    TopologySetType& TopologySetType::
    operator= (const TopologySetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->VertexSet_ = x.VertexSet_;
        this->EdgeSet_ = x.EdgeSet_;
        this->LoopSet_ = x.LoopSet_;
        this->FaceSet_ = x.FaceSet_;
        this->ShellSet_ = x.ShellSet_;
        this->BodySet_ = x.BodySet_;
        this->PointCloudSet_ = x.PointCloudSet_;
      }

      return *this;
    }

    TopologySetType::
    ~TopologySetType ()
    {
    }

    // TopologyBaseType
    //

    TopologyBaseType::
    TopologyBaseType (const id_type& id)
    : ::xsd::qif2::DrawableBaseType (id)
    {
    }

    TopologyBaseType::
    TopologyBaseType (const TopologyBaseType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (x, f, c)
    {
    }

    TopologyBaseType::
    TopologyBaseType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (e, f, c)
    {
    }

    TopologyBaseType* TopologyBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TopologyBaseType (*this, f, c);
    }

    TopologyBaseType::
    ~TopologyBaseType ()
    {
    }

    // VertexSetType
    //

    VertexSetType::
    VertexSetType (const N_type& N)
    : ::xml_schema::type (),
      Vertex_ (this),
      N_ (N, this)
    {
    }

    VertexSetType::
    VertexSetType (const VertexSetType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Vertex_ (x.Vertex_, f, this),
      N_ (x.N_, f, this)
    {
    }

    VertexSetType::
    VertexSetType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Vertex_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VertexSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Vertex
        //
        if (n.name () == "Vertex" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vertex_type > r (
            Vertex_traits::create (i, f, this));

          this->Vertex_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    VertexSetType* VertexSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VertexSetType (*this, f, c);
    }

    VertexSetType& VertexSetType::
    operator= (const VertexSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Vertex_ = x.Vertex_;
        this->N_ = x.N_;
      }

      return *this;
    }

    VertexSetType::
    ~VertexSetType ()
    {
    }

    // VertexType
    //

    VertexType::
    VertexType (const id_type& id,
                const Point_type& Point)
    : ::xsd::qif2::TopologyBaseType (id),
      Point_ (Point, this),
      tolerance_ (this)
    {
    }

    VertexType::
    VertexType (const id_type& id,
                ::std::auto_ptr< Point_type > Point)
    : ::xsd::qif2::TopologyBaseType (id),
      Point_ (Point, this),
      tolerance_ (this)
    {
    }

    VertexType::
    VertexType (const VertexType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Point_ (x.Point_, f, this),
      tolerance_ (x.tolerance_, f, this)
    {
    }

    VertexType::
    VertexType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      tolerance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VertexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Point
        //
        if (n.name () == "Point" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Point",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tolerance" && n.namespace_ ().empty ())
        {
          this->tolerance_.set (tolerance_traits::create (i, f, this));
          continue;
        }
      }
    }

    VertexType* VertexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VertexType (*this, f, c);
    }

    VertexType& VertexType::
    operator= (const VertexType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::TopologyBaseType& > (*this) = x;
        this->Point_ = x.Point_;
        this->tolerance_ = x.tolerance_;
      }

      return *this;
    }

    VertexType::
    ~VertexType ()
    {
    }

    // EdgeSetType
    //

    EdgeSetType::
    EdgeSetType (const N_type& N)
    : ::xml_schema::type (),
      Edge_ (this),
      N_ (N, this)
    {
    }

    EdgeSetType::
    EdgeSetType (const EdgeSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Edge_ (x.Edge_, f, this),
      N_ (x.N_, f, this)
    {
    }

    EdgeSetType::
    EdgeSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Edge_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgeSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Edge
        //
        if (n.name () == "Edge" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Edge_type > r (
            Edge_traits::create (i, f, this));

          this->Edge_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    EdgeSetType* EdgeSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeSetType (*this, f, c);
    }

    EdgeSetType& EdgeSetType::
    operator= (const EdgeSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Edge_ = x.Edge_;
        this->N_ = x.N_;
      }

      return *this;
    }

    EdgeSetType::
    ~EdgeSetType ()
    {
    }

    // EdgeType
    //

    EdgeType::
    EdgeType (const id_type& id,
              const Curve_type& Curve,
              const VertexBeg_type& VertexBeg,
              const VertexEnd_type& VertexEnd)
    : ::xsd::qif2::TopologyBaseType (id),
      Curve_ (Curve, this),
      VertexBeg_ (VertexBeg, this),
      VertexEnd_ (VertexEnd, this),
      tolerance_ (this)
    {
    }

    EdgeType::
    EdgeType (const id_type& id,
              ::std::auto_ptr< Curve_type > Curve,
              ::std::auto_ptr< VertexBeg_type > VertexBeg,
              ::std::auto_ptr< VertexEnd_type > VertexEnd)
    : ::xsd::qif2::TopologyBaseType (id),
      Curve_ (Curve, this),
      VertexBeg_ (VertexBeg, this),
      VertexEnd_ (VertexEnd, this),
      tolerance_ (this)
    {
    }

    EdgeType::
    EdgeType (const EdgeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Curve_ (x.Curve_, f, this),
      VertexBeg_ (x.VertexBeg_, f, this),
      VertexEnd_ (x.VertexEnd_, f, this),
      tolerance_ (x.tolerance_, f, this)
    {
    }

    EdgeType::
    EdgeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Curve_ (this),
      VertexBeg_ (this),
      VertexEnd_ (this),
      tolerance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Curve
        //
        if (n.name () == "Curve" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Curve_type > r (
            Curve_traits::create (i, f, this));

          if (!Curve_.present ())
          {
            this->Curve_.set (r);
            continue;
          }
        }

        // VertexBeg
        //
        if (n.name () == "VertexBeg" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexBeg_type > r (
            VertexBeg_traits::create (i, f, this));

          if (!VertexBeg_.present ())
          {
            this->VertexBeg_.set (r);
            continue;
          }
        }

        // VertexEnd
        //
        if (n.name () == "VertexEnd" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexEnd_type > r (
            VertexEnd_traits::create (i, f, this));

          if (!VertexEnd_.present ())
          {
            this->VertexEnd_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Curve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Curve",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!VertexBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "VertexBeg",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!VertexEnd_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "VertexEnd",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tolerance" && n.namespace_ ().empty ())
        {
          this->tolerance_.set (tolerance_traits::create (i, f, this));
          continue;
        }
      }
    }

    EdgeType* EdgeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeType (*this, f, c);
    }

    EdgeType& EdgeType::
    operator= (const EdgeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::TopologyBaseType& > (*this) = x;
        this->Curve_ = x.Curve_;
        this->VertexBeg_ = x.VertexBeg_;
        this->VertexEnd_ = x.VertexEnd_;
        this->tolerance_ = x.tolerance_;
      }

      return *this;
    }

    EdgeType::
    ~EdgeType ()
    {
    }

    // LoopSetType
    //

    LoopSetType::
    LoopSetType (const N_type& N)
    : ::xml_schema::type (),
      LoopBase_ (this),
      N_ (N, this)
    {
    }

    LoopSetType::
    LoopSetType (const LoopSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LoopBase_ (x.LoopBase_, f, this),
      N_ (x.N_, f, this)
    {
    }

    LoopSetType::
    LoopSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LoopBase_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LoopSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LoopBase
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "LoopBase",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< LoopBase_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< LoopBase_type > r (
              dynamic_cast< LoopBase_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LoopBase_.push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    LoopSetType* LoopSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopSetType (*this, f, c);
    }

    LoopSetType& LoopSetType::
    operator= (const LoopSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LoopBase_ = x.LoopBase_;
        this->N_ = x.N_;
      }

      return *this;
    }

    LoopSetType::
    ~LoopSetType ()
    {
    }

    // LoopBaseType
    //

    LoopBaseType::
    LoopBaseType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id)
    {
    }

    LoopBaseType::
    LoopBaseType (const LoopBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c)
    {
    }

    LoopBaseType::
    LoopBaseType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f, c)
    {
    }

    LoopBaseType* LoopBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopBaseType (*this, f, c);
    }

    LoopBaseType::
    ~LoopBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LoopBaseType >
    _xsd_LoopBaseType_type_factory_init (
      "LoopBaseType",
      "http://qifstandards.org/xsd/qif2");

    // LoopFormEnumType
    //

    LoopFormEnumType::
    LoopFormEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType* LoopFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopFormEnumType (*this, f, c);
    }

    LoopFormEnumType::value LoopFormEnumType::
    _xsd_LoopFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LoopFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LoopFormEnumType_indexes_,
                        _xsd_LoopFormEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_LoopFormEnumType_indexes_ + 4 || _xsd_LoopFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const LoopFormEnumType::
    _xsd_LoopFormEnumType_literals_[4] =
    {
      "UNKNOWN",
      "OUTER",
      "INNER",
      "SLIT"
    };

    const LoopFormEnumType::value LoopFormEnumType::
    _xsd_LoopFormEnumType_indexes_[4] =
    {
      ::xsd::qif2::LoopFormEnumType::INNER,
      ::xsd::qif2::LoopFormEnumType::OUTER,
      ::xsd::qif2::LoopFormEnumType::SLIT,
      ::xsd::qif2::LoopFormEnumType::UNKNOWN
    };

    // EdgeOrientedType
    //

    EdgeOrientedType::
    EdgeOrientedType (const Id_type& Id)
    : ::xsd::qif2::ElementReferenceType (Id),
      turned_ (turned_default_value (), this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (const EdgeOrientedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ElementReferenceType (x, f, c),
      turned_ (x.turned_, f, this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ElementReferenceType (e, f | ::xml_schema::flags::base, c),
      turned_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgeOrientedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ElementReferenceType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    EdgeOrientedType* EdgeOrientedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeOrientedType (*this, f, c);
    }

    EdgeOrientedType& EdgeOrientedType::
    operator= (const EdgeOrientedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ElementReferenceType& > (*this) = x;
        this->turned_ = x.turned_;
      }

      return *this;
    }

    EdgeOrientedType::
    ~EdgeOrientedType ()
    {
    }

    // CoEdgeType
    //

    CoEdgeType::
    CoEdgeType (const EdgeOriented_type& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, this),
      Curve12_ (this)
    {
    }

    CoEdgeType::
    CoEdgeType (::std::auto_ptr< EdgeOriented_type > EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, this),
      Curve12_ (this)
    {
    }

    CoEdgeType::
    CoEdgeType (const CoEdgeType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EdgeOriented_ (x.EdgeOriented_, f, this),
      Curve12_ (x.Curve12_, f, this)
    {
    }

    CoEdgeType::
    CoEdgeType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EdgeOriented_ (this),
      Curve12_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoEdgeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EdgeOriented
        //
        if (n.name () == "EdgeOriented" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeOriented_type > r (
            EdgeOriented_traits::create (i, f, this));

          if (!EdgeOriented_.present ())
          {
            this->EdgeOriented_.set (r);
            continue;
          }
        }

        // Curve12
        //
        if (n.name () == "Curve12" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Curve12_type > r (
            Curve12_traits::create (i, f, this));

          if (!this->Curve12_)
          {
            this->Curve12_.set (r);
            continue;
          }
        }

        break;
      }

      if (!EdgeOriented_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EdgeOriented",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CoEdgeType* CoEdgeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgeType (*this, f, c);
    }

    CoEdgeType& CoEdgeType::
    operator= (const CoEdgeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EdgeOriented_ = x.EdgeOriented_;
        this->Curve12_ = x.Curve12_;
      }

      return *this;
    }

    CoEdgeType::
    ~CoEdgeType ()
    {
    }

    // CoEdgesType
    //

    CoEdgesType::
    CoEdgesType (const N_type& N)
    : ::xml_schema::type (),
      CoEdge_ (this),
      N_ (N, this)
    {
    }

    CoEdgesType::
    CoEdgesType (const CoEdgesType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoEdge_ (x.CoEdge_, f, this),
      N_ (x.N_, f, this)
    {
    }

    CoEdgesType::
    CoEdgesType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoEdge_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoEdgesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdge
        //
        if (n.name () == "CoEdge" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdge_type > r (
            CoEdge_traits::create (i, f, this));

          this->CoEdge_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    CoEdgesType* CoEdgesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgesType (*this, f, c);
    }

    CoEdgesType& CoEdgesType::
    operator= (const CoEdgesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoEdge_ = x.CoEdge_;
        this->N_ = x.N_;
      }

      return *this;
    }

    CoEdgesType::
    ~CoEdgesType ()
    {
    }

    // CoEdgeMeshType
    //

    CoEdgeMeshType::
    CoEdgeMeshType (const EdgeOriented_type& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, this),
      CurveMesh_ (this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (::std::auto_ptr< EdgeOriented_type > EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, this),
      CurveMesh_ (this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (const CoEdgeMeshType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EdgeOriented_ (x.EdgeOriented_, f, this),
      CurveMesh_ (x.CurveMesh_, f, this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EdgeOriented_ (this),
      CurveMesh_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoEdgeMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EdgeOriented
        //
        if (n.name () == "EdgeOriented" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeOriented_type > r (
            EdgeOriented_traits::create (i, f, this));

          if (!EdgeOriented_.present ())
          {
            this->EdgeOriented_.set (r);
            continue;
          }
        }

        // CurveMesh
        //
        if (n.name () == "CurveMesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveMesh_type > r (
            CurveMesh_traits::create (i, f, this));

          if (!this->CurveMesh_)
          {
            this->CurveMesh_.set (r);
            continue;
          }
        }

        break;
      }

      if (!EdgeOriented_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EdgeOriented",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CoEdgeMeshType* CoEdgeMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgeMeshType (*this, f, c);
    }

    CoEdgeMeshType& CoEdgeMeshType::
    operator= (const CoEdgeMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EdgeOriented_ = x.EdgeOriented_;
        this->CurveMesh_ = x.CurveMesh_;
      }

      return *this;
    }

    CoEdgeMeshType::
    ~CoEdgeMeshType ()
    {
    }

    // CoEdgesMeshType
    //

    CoEdgesMeshType::
    CoEdgesMeshType (const N_type& N)
    : ::xml_schema::type (),
      CoEdgeMesh_ (this),
      N_ (N, this)
    {
    }

    CoEdgesMeshType::
    CoEdgesMeshType (const CoEdgesMeshType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoEdgeMesh_ (x.CoEdgeMesh_, f, this),
      N_ (x.N_, f, this)
    {
    }

    CoEdgesMeshType::
    CoEdgesMeshType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoEdgeMesh_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoEdgesMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdgeMesh
        //
        if (n.name () == "CoEdgeMesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdgeMesh_type > r (
            CoEdgeMesh_traits::create (i, f, this));

          this->CoEdgeMesh_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    CoEdgesMeshType* CoEdgesMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgesMeshType (*this, f, c);
    }

    CoEdgesMeshType& CoEdgesMeshType::
    operator= (const CoEdgesMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoEdgeMesh_ = x.CoEdgeMesh_;
        this->N_ = x.N_;
      }

      return *this;
    }

    CoEdgesMeshType::
    ~CoEdgesMeshType ()
    {
    }

    // LoopType
    //

    const LoopType::form_type LoopType::form_default_value_ (
      "UNKNOWN");

    LoopType::
    LoopType (const id_type& id,
              const CoEdges_type& CoEdges)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdges_ (CoEdges, this),
      form_ (form_default_value (), this)
    {
    }

    LoopType::
    LoopType (const id_type& id,
              ::std::auto_ptr< CoEdges_type > CoEdges)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdges_ (CoEdges, this),
      form_ (form_default_value (), this)
    {
    }

    LoopType::
    LoopType (const LoopType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (x, f, c),
      CoEdges_ (x.CoEdges_, f, this),
      form_ (x.form_, f, this)
    {
    }

    LoopType::
    LoopType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (e, f | ::xml_schema::flags::base, c),
      CoEdges_ (this),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LoopType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::LoopBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdges
        //
        if (n.name () == "CoEdges" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdges_type > r (
            CoEdges_traits::create (i, f, this));

          if (!CoEdges_.present ())
          {
            this->CoEdges_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CoEdges_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CoEdges",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    LoopType* LoopType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopType (*this, f, c);
    }

    LoopType& LoopType::
    operator= (const LoopType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::LoopBaseType& > (*this) = x;
        this->CoEdges_ = x.CoEdges_;
        this->form_ = x.form_;
      }

      return *this;
    }

    LoopType::
    ~LoopType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LoopType >
    _xsd_LoopType_type_factory_init (
      "LoopType",
      "http://qifstandards.org/xsd/qif2");

    // LoopMeshType
    //

    LoopMeshType::
    LoopMeshType (const id_type& id,
                  const CoEdgesMesh_type& CoEdgesMesh)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdgesMesh_ (CoEdgesMesh, this)
    {
    }

    LoopMeshType::
    LoopMeshType (const id_type& id,
                  ::std::auto_ptr< CoEdgesMesh_type > CoEdgesMesh)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdgesMesh_ (CoEdgesMesh, this)
    {
    }

    LoopMeshType::
    LoopMeshType (const LoopMeshType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (x, f, c),
      CoEdgesMesh_ (x.CoEdgesMesh_, f, this)
    {
    }

    LoopMeshType::
    LoopMeshType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (e, f | ::xml_schema::flags::base, c),
      CoEdgesMesh_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LoopMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::LoopBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdgesMesh
        //
        if (n.name () == "CoEdgesMesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdgesMesh_type > r (
            CoEdgesMesh_traits::create (i, f, this));

          if (!CoEdgesMesh_.present ())
          {
            this->CoEdgesMesh_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CoEdgesMesh_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CoEdgesMesh",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LoopMeshType* LoopMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopMeshType (*this, f, c);
    }

    LoopMeshType& LoopMeshType::
    operator= (const LoopMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::LoopBaseType& > (*this) = x;
        this->CoEdgesMesh_ = x.CoEdgesMesh_;
      }

      return *this;
    }

    LoopMeshType::
    ~LoopMeshType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LoopMeshType >
    _xsd_LoopMeshType_type_factory_init (
      "LoopMeshType",
      "http://qifstandards.org/xsd/qif2");

    // FaceSetType
    //

    FaceSetType::
    FaceSetType (const N_type& N)
    : ::xml_schema::type (),
      FaceBase_ (this),
      N_ (N, this)
    {
    }

    FaceSetType::
    FaceSetType (const FaceSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FaceBase_ (x.FaceBase_, f, this),
      N_ (x.N_, f, this)
    {
    }

    FaceSetType::
    FaceSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FaceBase_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FaceBase
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FaceBase",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< FaceBase_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< FaceBase_type > r (
              dynamic_cast< FaceBase_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FaceBase_.push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    FaceSetType* FaceSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceSetType (*this, f, c);
    }

    FaceSetType& FaceSetType::
    operator= (const FaceSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FaceBase_ = x.FaceBase_;
        this->N_ = x.N_;
      }

      return *this;
    }

    FaceSetType::
    ~FaceSetType ()
    {
    }

    // FaceBaseType
    //

    FaceBaseType::
    FaceBaseType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      InertiaMatrix_ (this),
      turned_ (turned_default_value (), this),
      area_ (this),
      volume_ (this),
      massCenter_ (this)
    {
    }

    FaceBaseType::
    FaceBaseType (const FaceBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      InertiaMatrix_ (x.InertiaMatrix_, f, this),
      turned_ (x.turned_, f, this),
      area_ (x.area_, f, this),
      volume_ (x.volume_, f, this),
      massCenter_ (x.massCenter_, f, this)
    {
    }

    FaceBaseType::
    FaceBaseType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      InertiaMatrix_ (this),
      turned_ (this),
      area_ (this),
      volume_ (this),
      massCenter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InertiaMatrix
        //
        if (n.name () == "InertiaMatrix" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InertiaMatrix_type > r (
            InertiaMatrix_traits::create (i, f, this));

          if (!this->InertiaMatrix_)
          {
            this->InertiaMatrix_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "area" && n.namespace_ ().empty ())
        {
          this->area_.set (area_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "volume" && n.namespace_ ().empty ())
        {
          this->volume_.set (volume_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "massCenter" && n.namespace_ ().empty ())
        {
          this->massCenter_.set (massCenter_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    FaceBaseType* FaceBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceBaseType (*this, f, c);
    }

    FaceBaseType& FaceBaseType::
    operator= (const FaceBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::TopologyBaseType& > (*this) = x;
        this->InertiaMatrix_ = x.InertiaMatrix_;
        this->turned_ = x.turned_;
        this->area_ = x.area_;
        this->volume_ = x.volume_;
        this->massCenter_ = x.massCenter_;
      }

      return *this;
    }

    FaceBaseType::
    ~FaceBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaceBaseType >
    _xsd_FaceBaseType_type_factory_init (
      "FaceBaseType",
      "http://qifstandards.org/xsd/qif2");

    // FaceType
    //

    FaceType::
    FaceType (const id_type& id,
              const Surface_type& Surface)
    : ::xsd::qif2::FaceBaseType (id),
      Surface_ (Surface, this),
      LoopIds_ (this),
      hasOuter_ (hasOuter_default_value (), this)
    {
    }

    FaceType::
    FaceType (const id_type& id,
              ::std::auto_ptr< Surface_type > Surface)
    : ::xsd::qif2::FaceBaseType (id),
      Surface_ (Surface, this),
      LoopIds_ (this),
      hasOuter_ (hasOuter_default_value (), this)
    {
    }

    FaceType::
    FaceType (const FaceType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (x, f, c),
      Surface_ (x.Surface_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      hasOuter_ (x.hasOuter_, f, this)
    {
    }

    FaceType::
    FaceType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (e, f | ::xml_schema::flags::base, c),
      Surface_ (this),
      LoopIds_ (this),
      hasOuter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Surface
        //
        if (n.name () == "Surface" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Surface_type > r (
            Surface_traits::create (i, f, this));

          if (!Surface_.present ())
          {
            this->Surface_.set (r);
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == "LoopIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Surface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Surface",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "hasOuter" && n.namespace_ ().empty ())
        {
          this->hasOuter_.set (hasOuter_traits::create (i, f, this));
          continue;
        }
      }

      if (!hasOuter_.present ())
      {
        this->hasOuter_.set (hasOuter_default_value ());
      }
    }

    FaceType* FaceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceType (*this, f, c);
    }

    FaceType& FaceType::
    operator= (const FaceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FaceBaseType& > (*this) = x;
        this->Surface_ = x.Surface_;
        this->LoopIds_ = x.LoopIds_;
        this->hasOuter_ = x.hasOuter_;
      }

      return *this;
    }

    FaceType::
    ~FaceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaceType >
    _xsd_FaceType_type_factory_init (
      "FaceType",
      "http://qifstandards.org/xsd/qif2");

    // FaceMeshType
    //

    FaceMeshType::
    FaceMeshType (const id_type& id,
                  const Mesh_type& Mesh)
    : ::xsd::qif2::FaceBaseType (id),
      Mesh_ (Mesh, this),
      LoopIds_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesVisible_ (this),
      TrianglesVisibleBinary_ (this),
      TrianglesHidden_ (this),
      TrianglesHiddenBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
    }

    FaceMeshType::
    FaceMeshType (const id_type& id,
                  ::std::auto_ptr< Mesh_type > Mesh)
    : ::xsd::qif2::FaceBaseType (id),
      Mesh_ (Mesh, this),
      LoopIds_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesVisible_ (this),
      TrianglesVisibleBinary_ (this),
      TrianglesHidden_ (this),
      TrianglesHiddenBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
    }

    FaceMeshType::
    FaceMeshType (const FaceMeshType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (x, f, c),
      Mesh_ (x.Mesh_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      Triangles_ (x.Triangles_, f, this),
      TrianglesBinary_ (x.TrianglesBinary_, f, this),
      TrianglesVisible_ (x.TrianglesVisible_, f, this),
      TrianglesVisibleBinary_ (x.TrianglesVisibleBinary_, f, this),
      TrianglesHidden_ (x.TrianglesHidden_, f, this),
      TrianglesHiddenBinary_ (x.TrianglesHiddenBinary_, f, this),
      TrianglesColor_ (x.TrianglesColor_, f, this),
      TrianglesColorBinary_ (x.TrianglesColorBinary_, f, this)
    {
    }

    FaceMeshType::
    FaceMeshType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (e, f | ::xml_schema::flags::base, c),
      Mesh_ (this),
      LoopIds_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesVisible_ (this),
      TrianglesVisibleBinary_ (this),
      TrianglesHidden_ (this),
      TrianglesHiddenBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Mesh
        //
        if (n.name () == "Mesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Mesh_type > r (
            Mesh_traits::create (i, f, this));

          if (!Mesh_.present ())
          {
            this->Mesh_.set (r);
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == "LoopIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (r);
            continue;
          }
        }

        // Triangles
        //
        if (n.name () == "Triangles" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Triangles_type > r (
            Triangles_traits::create (i, f, this));

          if (!this->Triangles_)
          {
            this->Triangles_.set (r);
            continue;
          }
        }

        // TrianglesBinary
        //
        if (n.name () == "TrianglesBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesBinary_type > r (
            TrianglesBinary_traits::create (i, f, this));

          if (!this->TrianglesBinary_)
          {
            this->TrianglesBinary_.set (r);
            continue;
          }
        }

        // TrianglesVisible
        //
        if (n.name () == "TrianglesVisible" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesVisible_type > r (
            TrianglesVisible_traits::create (i, f, this));

          if (!this->TrianglesVisible_)
          {
            this->TrianglesVisible_.set (r);
            continue;
          }
        }

        // TrianglesVisibleBinary
        //
        if (n.name () == "TrianglesVisibleBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesVisibleBinary_type > r (
            TrianglesVisibleBinary_traits::create (i, f, this));

          if (!this->TrianglesVisibleBinary_)
          {
            this->TrianglesVisibleBinary_.set (r);
            continue;
          }
        }

        // TrianglesHidden
        //
        if (n.name () == "TrianglesHidden" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesHidden_type > r (
            TrianglesHidden_traits::create (i, f, this));

          if (!this->TrianglesHidden_)
          {
            this->TrianglesHidden_.set (r);
            continue;
          }
        }

        // TrianglesHiddenBinary
        //
        if (n.name () == "TrianglesHiddenBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesHiddenBinary_type > r (
            TrianglesHiddenBinary_traits::create (i, f, this));

          if (!this->TrianglesHiddenBinary_)
          {
            this->TrianglesHiddenBinary_.set (r);
            continue;
          }
        }

        // TrianglesColor
        //
        if (n.name () == "TrianglesColor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesColor_type > r (
            TrianglesColor_traits::create (i, f, this));

          if (!this->TrianglesColor_)
          {
            this->TrianglesColor_.set (r);
            continue;
          }
        }

        // TrianglesColorBinary
        //
        if (n.name () == "TrianglesColorBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesColorBinary_type > r (
            TrianglesColorBinary_traits::create (i, f, this));

          if (!this->TrianglesColorBinary_)
          {
            this->TrianglesColorBinary_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Mesh_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Mesh",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FaceMeshType* FaceMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceMeshType (*this, f, c);
    }

    FaceMeshType& FaceMeshType::
    operator= (const FaceMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FaceBaseType& > (*this) = x;
        this->Mesh_ = x.Mesh_;
        this->LoopIds_ = x.LoopIds_;
        this->Triangles_ = x.Triangles_;
        this->TrianglesBinary_ = x.TrianglesBinary_;
        this->TrianglesVisible_ = x.TrianglesVisible_;
        this->TrianglesVisibleBinary_ = x.TrianglesVisibleBinary_;
        this->TrianglesHidden_ = x.TrianglesHidden_;
        this->TrianglesHiddenBinary_ = x.TrianglesHiddenBinary_;
        this->TrianglesColor_ = x.TrianglesColor_;
        this->TrianglesColorBinary_ = x.TrianglesColorBinary_;
      }

      return *this;
    }

    FaceMeshType::
    ~FaceMeshType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaceMeshType >
    _xsd_FaceMeshType_type_factory_init (
      "FaceMeshType",
      "http://qifstandards.org/xsd/qif2");

    // ShellSetType
    //

    ShellSetType::
    ShellSetType (const N_type& N)
    : ::xml_schema::type (),
      Shell_ (this),
      N_ (N, this)
    {
    }

    ShellSetType::
    ShellSetType (const ShellSetType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Shell_ (x.Shell_, f, this),
      N_ (x.N_, f, this)
    {
    }

    ShellSetType::
    ShellSetType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Shell_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ShellSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Shell
        //
        if (n.name () == "Shell" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Shell_type > r (
            Shell_traits::create (i, f, this));

          this->Shell_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ShellSetType* ShellSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellSetType (*this, f, c);
    }

    ShellSetType& ShellSetType::
    operator= (const ShellSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Shell_ = x.Shell_;
        this->N_ = x.N_;
      }

      return *this;
    }

    ShellSetType::
    ~ShellSetType ()
    {
    }

    // ShellFormEnumType
    //

    ShellFormEnumType::
    ShellFormEnumType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType* ShellFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellFormEnumType (*this, f, c);
    }

    ShellFormEnumType::value ShellFormEnumType::
    _xsd_ShellFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ShellFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ShellFormEnumType_indexes_,
                        _xsd_ShellFormEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ShellFormEnumType_indexes_ + 3 || _xsd_ShellFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ShellFormEnumType::
    _xsd_ShellFormEnumType_literals_[3] =
    {
      "UNKNOWN",
      "OUTER",
      "INNER"
    };

    const ShellFormEnumType::value ShellFormEnumType::
    _xsd_ShellFormEnumType_indexes_[3] =
    {
      ::xsd::qif2::ShellFormEnumType::INNER,
      ::xsd::qif2::ShellFormEnumType::OUTER,
      ::xsd::qif2::ShellFormEnumType::UNKNOWN
    };

    // ShellType
    //

    const ShellType::form_type ShellType::form_default_value_ (
      "UNKNOWN");

    ShellType::
    ShellType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      FaceIds_ (this),
      turned_ (turned_default_value (), this),
      closed_ (closed_default_value (), this),
      form_ (form_default_value (), this)
    {
    }

    ShellType::
    ShellType (const ShellType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      FaceIds_ (x.FaceIds_, f, this),
      turned_ (x.turned_, f, this),
      closed_ (x.closed_, f, this),
      form_ (x.form_, f, this)
    {
    }

    ShellType::
    ShellType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      FaceIds_ (this),
      turned_ (this),
      closed_ (this),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ShellType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FaceIds
        //
        if (n.name () == "FaceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FaceIds_type > r (
            FaceIds_traits::create (i, f, this));

          if (!this->FaceIds_)
          {
            this->FaceIds_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "closed" && n.namespace_ ().empty ())
        {
          this->closed_.set (closed_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }

      if (!closed_.present ())
      {
        this->closed_.set (closed_default_value ());
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    ShellType* ShellType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellType (*this, f, c);
    }

    ShellType& ShellType::
    operator= (const ShellType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::TopologyBaseType& > (*this) = x;
        this->FaceIds_ = x.FaceIds_;
        this->turned_ = x.turned_;
        this->closed_ = x.closed_;
        this->form_ = x.form_;
      }

      return *this;
    }

    ShellType::
    ~ShellType ()
    {
    }

    // BodySetType
    //

    BodySetType::
    BodySetType (const N_type& N)
    : ::xml_schema::type (),
      Body_ (this),
      N_ (N, this)
    {
    }

    BodySetType::
    BodySetType (const BodySetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Body_ (x.Body_, f, this),
      N_ (x.N_, f, this)
    {
    }

    BodySetType::
    BodySetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Body_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BodySetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Body
        //
        if (n.name () == "Body" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Body_type > r (
            Body_traits::create (i, f, this));

          this->Body_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    BodySetType* BodySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BodySetType (*this, f, c);
    }

    BodySetType& BodySetType::
    operator= (const BodySetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Body_ = x.Body_;
        this->N_ = x.N_;
      }

      return *this;
    }

    BodySetType::
    ~BodySetType ()
    {
    }

    // BodyType
    //

    BodyType::
    BodyType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      Transform_ (this),
      ShellIds_ (this),
      FaceIds_ (this),
      LoopIds_ (this),
      EdgeIds_ (this),
      VertexIds_ (this)
    {
    }

    BodyType::
    BodyType (const BodyType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Transform_ (x.Transform_, f, this),
      ShellIds_ (x.ShellIds_, f, this),
      FaceIds_ (x.FaceIds_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      EdgeIds_ (x.EdgeIds_, f, this),
      VertexIds_ (x.VertexIds_, f, this)
    {
    }

    BodyType::
    BodyType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Transform_ (this),
      ShellIds_ (this),
      FaceIds_ (this),
      LoopIds_ (this),
      EdgeIds_ (this),
      VertexIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BodyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // ShellIds
        //
        if (n.name () == "ShellIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ShellIds_type > r (
            ShellIds_traits::create (i, f, this));

          if (!this->ShellIds_)
          {
            this->ShellIds_.set (r);
            continue;
          }
        }

        // FaceIds
        //
        if (n.name () == "FaceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FaceIds_type > r (
            FaceIds_traits::create (i, f, this));

          if (!this->FaceIds_)
          {
            this->FaceIds_.set (r);
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == "LoopIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (r);
            continue;
          }
        }

        // EdgeIds
        //
        if (n.name () == "EdgeIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeIds_type > r (
            EdgeIds_traits::create (i, f, this));

          if (!this->EdgeIds_)
          {
            this->EdgeIds_.set (r);
            continue;
          }
        }

        // VertexIds
        //
        if (n.name () == "VertexIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexIds_type > r (
            VertexIds_traits::create (i, f, this));

          if (!this->VertexIds_)
          {
            this->VertexIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    BodyType* BodyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BodyType (*this, f, c);
    }

    BodyType& BodyType::
    operator= (const BodyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::TopologyBaseType& > (*this) = x;
        this->Transform_ = x.Transform_;
        this->ShellIds_ = x.ShellIds_;
        this->FaceIds_ = x.FaceIds_;
        this->LoopIds_ = x.LoopIds_;
        this->EdgeIds_ = x.EdgeIds_;
        this->VertexIds_ = x.VertexIds_;
      }

      return *this;
    }

    BodyType::
    ~BodyType ()
    {
    }

    // PointCloudSetType
    //

    PointCloudSetType::
    PointCloudSetType (const N_type& N)
    : ::xml_schema::type (),
      PointCloud_ (this),
      N_ (N, this)
    {
    }

    PointCloudSetType::
    PointCloudSetType (const PointCloudSetType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointCloud_ (x.PointCloud_, f, this),
      N_ (x.N_, f, this)
    {
    }

    PointCloudSetType::
    PointCloudSetType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointCloud_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointCloudSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointCloud
        //
        if (n.name () == "PointCloud" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointCloud_type > r (
            PointCloud_traits::create (i, f, this));

          this->PointCloud_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    PointCloudSetType* PointCloudSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCloudSetType (*this, f, c);
    }

    PointCloudSetType& PointCloudSetType::
    operator= (const PointCloudSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointCloud_ = x.PointCloud_;
        this->N_ = x.N_;
      }

      return *this;
    }

    PointCloudSetType::
    ~PointCloudSetType ()
    {
    }

    // PointCloudType
    //

    PointCloudType::
    PointCloudType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      Points_ (this),
      PointsBinary_ (this),
      Normals_ (this),
      NormalsBinary_ (this),
      PointsVisible_ (this),
      PointsVisibleBinary_ (this),
      PointsHidden_ (this),
      PointsHiddenBinary_ (this),
      PointsColor_ (this),
      PointsColorBinary_ (this)
    {
    }

    PointCloudType::
    PointCloudType (const PointCloudType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Points_ (x.Points_, f, this),
      PointsBinary_ (x.PointsBinary_, f, this),
      Normals_ (x.Normals_, f, this),
      NormalsBinary_ (x.NormalsBinary_, f, this),
      PointsVisible_ (x.PointsVisible_, f, this),
      PointsVisibleBinary_ (x.PointsVisibleBinary_, f, this),
      PointsHidden_ (x.PointsHidden_, f, this),
      PointsHiddenBinary_ (x.PointsHiddenBinary_, f, this),
      PointsColor_ (x.PointsColor_, f, this),
      PointsColorBinary_ (x.PointsColorBinary_, f, this)
    {
    }

    PointCloudType::
    PointCloudType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Points_ (this),
      PointsBinary_ (this),
      Normals_ (this),
      NormalsBinary_ (this),
      PointsVisible_ (this),
      PointsVisibleBinary_ (this),
      PointsHidden_ (this),
      PointsHiddenBinary_ (this),
      PointsColor_ (this),
      PointsColorBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointCloudType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Points
        //
        if (n.name () == "Points" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (r);
            continue;
          }
        }

        // PointsBinary
        //
        if (n.name () == "PointsBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsBinary_type > r (
            PointsBinary_traits::create (i, f, this));

          if (!this->PointsBinary_)
          {
            this->PointsBinary_.set (r);
            continue;
          }
        }

        // Normals
        //
        if (n.name () == "Normals" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normals_type > r (
            Normals_traits::create (i, f, this));

          if (!this->Normals_)
          {
            this->Normals_.set (r);
            continue;
          }
        }

        // NormalsBinary
        //
        if (n.name () == "NormalsBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NormalsBinary_type > r (
            NormalsBinary_traits::create (i, f, this));

          if (!this->NormalsBinary_)
          {
            this->NormalsBinary_.set (r);
            continue;
          }
        }

        // PointsVisible
        //
        if (n.name () == "PointsVisible" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsVisible_type > r (
            PointsVisible_traits::create (i, f, this));

          if (!this->PointsVisible_)
          {
            this->PointsVisible_.set (r);
            continue;
          }
        }

        // PointsVisibleBinary
        //
        if (n.name () == "PointsVisibleBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsVisibleBinary_type > r (
            PointsVisibleBinary_traits::create (i, f, this));

          if (!this->PointsVisibleBinary_)
          {
            this->PointsVisibleBinary_.set (r);
            continue;
          }
        }

        // PointsHidden
        //
        if (n.name () == "PointsHidden" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsHidden_type > r (
            PointsHidden_traits::create (i, f, this));

          if (!this->PointsHidden_)
          {
            this->PointsHidden_.set (r);
            continue;
          }
        }

        // PointsHiddenBinary
        //
        if (n.name () == "PointsHiddenBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsHiddenBinary_type > r (
            PointsHiddenBinary_traits::create (i, f, this));

          if (!this->PointsHiddenBinary_)
          {
            this->PointsHiddenBinary_.set (r);
            continue;
          }
        }

        // PointsColor
        //
        if (n.name () == "PointsColor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsColor_type > r (
            PointsColor_traits::create (i, f, this));

          if (!this->PointsColor_)
          {
            this->PointsColor_.set (r);
            continue;
          }
        }

        // PointsColorBinary
        //
        if (n.name () == "PointsColorBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsColorBinary_type > r (
            PointsColorBinary_traits::create (i, f, this));

          if (!this->PointsColorBinary_)
          {
            this->PointsColorBinary_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointCloudType* PointCloudType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCloudType (*this, f, c);
    }

    PointCloudType& PointCloudType::
    operator= (const PointCloudType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::TopologyBaseType& > (*this) = x;
        this->Points_ = x.Points_;
        this->PointsBinary_ = x.PointsBinary_;
        this->Normals_ = x.Normals_;
        this->NormalsBinary_ = x.NormalsBinary_;
        this->PointsVisible_ = x.PointsVisible_;
        this->PointsVisibleBinary_ = x.PointsVisibleBinary_;
        this->PointsHidden_ = x.PointsHidden_;
        this->PointsHiddenBinary_ = x.PointsHiddenBinary_;
        this->PointsColor_ = x.PointsColor_;
        this->PointsColorBinary_ = x.PointsColorBinary_;
      }

      return *this;
    }

    PointCloudType::
    ~PointCloudType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LoopType >
    _xsd_Loop_element_factory_init (
      "LoopBase",
      "http://qifstandards.org/xsd/qif2",
      "Loop",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LoopMeshType >
    _xsd_LoopMesh_element_factory_init (
      "LoopBase",
      "http://qifstandards.org/xsd/qif2",
      "LoopMesh",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::FaceType >
    _xsd_Face_element_factory_init (
      "FaceBase",
      "http://qifstandards.org/xsd/qif2",
      "Face",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::FaceMeshType >
    _xsd_FaceMesh_element_factory_init (
      "FaceBase",
      "http://qifstandards.org/xsd/qif2",
      "FaceMesh",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::TopologySetType > (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TopologySetType > (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TopologySetType > (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TopologySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TopologySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::TopologySetType > (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TopologySetType > (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TopologySetType > (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::TopologySetType > (
          ::xsd::qif2::TopologySet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TopologySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TopologySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TopologySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TopologySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TopologySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TopologySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexSetType > (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexSetType > (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexSetType > (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::VertexSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::VertexSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexSetType > (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexSetType > (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexSetType > (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::VertexSetType > (
          ::xsd::qif2::VertexSet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "VertexSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "VertexSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "VertexSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "VertexSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexType > (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexType > (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexType > (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Vertex (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Vertex (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexType > (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexType > (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::VertexType > (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::VertexType > (
          ::xsd::qif2::Vertex (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Vertex" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Vertex",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Vertex" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Vertex",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeSetType > (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeSetType > (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeSetType > (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgeSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgeSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeSetType > (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeSetType > (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeSetType > (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::EdgeSetType > (
          ::xsd::qif2::EdgeSet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EdgeSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgeSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EdgeSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgeSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeType > (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeType > (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeType > (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Edge (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Edge (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeType > (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeType > (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::EdgeType > (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::EdgeType > (
          ::xsd::qif2::Edge (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Edge" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Edge",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Edge" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Edge",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopSetType > (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopSetType > (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopSetType > (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopSetType > (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopSetType > (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopSetType > (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::LoopSetType > (
          ::xsd::qif2::LoopSet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LoopSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LoopSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopBaseType > (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopBaseType > (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopBaseType > (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopBaseType > (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopBaseType > (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopBaseType > (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::LoopBaseType > (
          ::xsd::qif2::LoopBase (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LoopBase",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LoopBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
          dynamic_cast< ::xsd::qif2::LoopBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LoopBase",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LoopBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
          dynamic_cast< ::xsd::qif2::LoopBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopType > (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopType > (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopType > (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Loop (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Loop (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopType > (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopType > (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopType > (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::LoopType > (
          ::xsd::qif2::Loop (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Loop",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LoopType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::LoopType > r (
          dynamic_cast< ::xsd::qif2::LoopType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Loop",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Loop",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LoopType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::LoopType > r (
          dynamic_cast< ::xsd::qif2::LoopType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Loop",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopMeshType > (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopMeshType > (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopMeshType > (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopMeshType > (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopMeshType > (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LoopMeshType > (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::LoopMeshType > (
          ::xsd::qif2::LoopMesh (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LoopMesh",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LoopMeshType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
          dynamic_cast< ::xsd::qif2::LoopMeshType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LoopMesh",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LoopMeshType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
          dynamic_cast< ::xsd::qif2::LoopMeshType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceSetType > (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceSetType > (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceSetType > (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceSetType > (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceSetType > (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceSetType > (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::FaceSetType > (
          ::xsd::qif2::FaceSet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FaceSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FaceSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceBaseType > (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceBaseType > (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceBaseType > (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceBaseType > (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceBaseType > (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceBaseType > (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::FaceBaseType > (
          ::xsd::qif2::FaceBase (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "FaceBase",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FaceBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
          dynamic_cast< ::xsd::qif2::FaceBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "FaceBase",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FaceBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
          dynamic_cast< ::xsd::qif2::FaceBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceType > (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceType > (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceType > (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Face (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Face (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceType > (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceType > (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceType > (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::FaceType > (
          ::xsd::qif2::Face (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Face",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FaceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::FaceType > r (
          dynamic_cast< ::xsd::qif2::FaceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Face",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Face",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FaceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::FaceType > r (
          dynamic_cast< ::xsd::qif2::FaceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Face",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceMeshType > (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceMeshType > (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceMeshType > (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceMeshType > (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceMeshType > (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FaceMeshType > (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::FaceMeshType > (
          ::xsd::qif2::FaceMesh (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "FaceMesh",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FaceMeshType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
          dynamic_cast< ::xsd::qif2::FaceMeshType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "FaceMesh",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FaceMeshType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
          dynamic_cast< ::xsd::qif2::FaceMeshType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellSetType > (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellSetType > (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellSetType > (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ShellSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ShellSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellSetType > (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellSetType > (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellSetType > (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ShellSetType > (
          ::xsd::qif2::ShellSet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ShellSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ShellSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ShellSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ShellSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellType > (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellType > (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellType > (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Shell (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Shell (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellType > (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellType > (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ShellType > (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ShellType > (
          ::xsd::qif2::Shell (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Shell" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Shell",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Shell" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Shell",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BodySetType > (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodySetType > (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodySetType > (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BodySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BodySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BodySetType > (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodySetType > (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodySetType > (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::BodySetType > (
          ::xsd::qif2::BodySet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "BodySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BodySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "BodySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BodySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BodyType > (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodyType > (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodyType > (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Body (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Body (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BodyType > (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodyType > (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BodyType > (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::BodyType > (
          ::xsd::qif2::Body (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Body" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodyType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Body",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Body" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodyType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Body",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloudSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloudSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > (
          ::xsd::qif2::PointCloudSet (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointCloudSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloudSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointCloudSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloudSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudType > (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudType > (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudType > (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloud (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloud (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudType > (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudType > (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointCloudType > (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::PointCloudType > (
          ::xsd::qif2::PointCloud (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointCloud" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloud",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointCloud" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloud",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const TopologySetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // VertexSet
      //
      if (i.VertexSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "VertexSet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.VertexSet ();
      }

      // EdgeSet
      //
      if (i.EdgeSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EdgeSet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EdgeSet ();
      }

      // LoopSet
      //
      if (i.LoopSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LoopSet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LoopSet ();
      }

      // FaceSet
      //
      if (i.FaceSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FaceSet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FaceSet ();
      }

      // ShellSet
      //
      if (i.ShellSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ShellSet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ShellSet ();
      }

      // BodySet
      //
      if (i.BodySet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BodySet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BodySet ();
      }

      // PointCloudSet
      //
      if (i.PointCloudSet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointCloudSet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointCloudSet ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TopologyBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::DrawableBaseType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const VertexSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Vertex
      //
      for (VertexSetType::Vertex_const_iterator
           b (i.Vertex ().begin ()), n (i.Vertex ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Vertex",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const VertexType& i)
    {
      e << static_cast< const ::xsd::qif2::TopologyBaseType& > (i);

      // Point
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Point",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Point ();
      }

      // tolerance
      //
      if (i.tolerance ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "tolerance",
            e));

        a << ::xml_schema::as_double(*i.tolerance ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Edge
      //
      for (EdgeSetType::Edge_const_iterator
           b (i.Edge ().begin ()), n (i.Edge ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Edge",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeType& i)
    {
      e << static_cast< const ::xsd::qif2::TopologyBaseType& > (i);

      // Curve
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Curve",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Curve ();
      }

      // VertexBeg
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "VertexBeg",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.VertexBeg ();
      }

      // VertexEnd
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "VertexEnd",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.VertexEnd ();
      }

      // tolerance
      //
      if (i.tolerance ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "tolerance",
            e));

        a << ::xml_schema::as_double(*i.tolerance ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LoopSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LoopBase
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (LoopSetType::LoopBase_const_iterator
             b (i.LoopBase ().begin ()), n (i.LoopBase ().end ());
             b != n; ++b)
        {
          if (typeid (LoopSetType::LoopBase_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "LoopBase",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "LoopBase",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LoopBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::TopologyBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LoopBaseType >
    _xsd_LoopBaseType_type_serializer_init (
      "LoopBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LoopFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const LoopFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LoopFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgeOrientedType& i)
    {
      e << static_cast< const ::xsd::qif2::ElementReferenceType& > (i);

      // turned
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "turned",
            e));

        a << i.turned ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoEdgeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EdgeOriented
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EdgeOriented",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.EdgeOriented ();
      }

      // Curve12
      //
      if (i.Curve12 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Curve12",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Curve12 ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoEdgesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoEdge
      //
      for (CoEdgesType::CoEdge_const_iterator
           b (i.CoEdge ().begin ()), n (i.CoEdge ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoEdge",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoEdgeMeshType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EdgeOriented
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EdgeOriented",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.EdgeOriented ();
      }

      // CurveMesh
      //
      if (i.CurveMesh ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CurveMesh",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CurveMesh ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoEdgesMeshType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoEdgeMesh
      //
      for (CoEdgesMeshType::CoEdgeMesh_const_iterator
           b (i.CoEdgeMesh ().begin ()), n (i.CoEdgeMesh ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoEdgeMesh",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LoopType& i)
    {
      e << static_cast< const ::xsd::qif2::LoopBaseType& > (i);

      // CoEdges
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoEdges",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CoEdges ();
      }

      // form
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "form",
            e));

        a << i.form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LoopType >
    _xsd_LoopType_type_serializer_init (
      "LoopType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LoopMeshType& i)
    {
      e << static_cast< const ::xsd::qif2::LoopBaseType& > (i);

      // CoEdgesMesh
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoEdgesMesh",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CoEdgesMesh ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LoopMeshType >
    _xsd_LoopMeshType_type_serializer_init (
      "LoopMeshType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const FaceSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FaceBase
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (FaceSetType::FaceBase_const_iterator
             b (i.FaceBase ().begin ()), n (i.FaceBase ().end ());
             b != n; ++b)
        {
          if (typeid (FaceSetType::FaceBase_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FaceBase",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "FaceBase",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FaceBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::TopologyBaseType& > (i);

      // InertiaMatrix
      //
      if (i.InertiaMatrix ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InertiaMatrix",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.InertiaMatrix ();
      }

      // turned
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "turned",
            e));

        a << i.turned ();
      }

      // area
      //
      if (i.area ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "area",
            e));

        a << ::xml_schema::as_double(*i.area ());
      }

      // volume
      //
      if (i.volume ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "volume",
            e));

        a << ::xml_schema::as_double(*i.volume ());
      }

      // massCenter
      //
      if (i.massCenter ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "massCenter",
            e));

        a << *i.massCenter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaceBaseType >
    _xsd_FaceBaseType_type_serializer_init (
      "FaceBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const FaceType& i)
    {
      e << static_cast< const ::xsd::qif2::FaceBaseType& > (i);

      // Surface
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Surface",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Surface ();
      }

      // LoopIds
      //
      if (i.LoopIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LoopIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LoopIds ();
      }

      // hasOuter
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "hasOuter",
            e));

        a << i.hasOuter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaceType >
    _xsd_FaceType_type_serializer_init (
      "FaceType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const FaceMeshType& i)
    {
      e << static_cast< const ::xsd::qif2::FaceBaseType& > (i);

      // Mesh
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Mesh",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Mesh ();
      }

      // LoopIds
      //
      if (i.LoopIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LoopIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LoopIds ();
      }

      // Triangles
      //
      if (i.Triangles ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Triangles",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Triangles ();
      }

      // TrianglesBinary
      //
      if (i.TrianglesBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrianglesBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TrianglesBinary ();
      }

      // TrianglesVisible
      //
      if (i.TrianglesVisible ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrianglesVisible",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TrianglesVisible ();
      }

      // TrianglesVisibleBinary
      //
      if (i.TrianglesVisibleBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrianglesVisibleBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TrianglesVisibleBinary ();
      }

      // TrianglesHidden
      //
      if (i.TrianglesHidden ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrianglesHidden",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TrianglesHidden ();
      }

      // TrianglesHiddenBinary
      //
      if (i.TrianglesHiddenBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrianglesHiddenBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TrianglesHiddenBinary ();
      }

      // TrianglesColor
      //
      if (i.TrianglesColor ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrianglesColor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TrianglesColor ();
      }

      // TrianglesColorBinary
      //
      if (i.TrianglesColorBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TrianglesColorBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TrianglesColorBinary ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaceMeshType >
    _xsd_FaceMeshType_type_serializer_init (
      "FaceMeshType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ShellSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Shell
      //
      for (ShellSetType::Shell_const_iterator
           b (i.Shell ().begin ()), n (i.Shell ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Shell",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShellFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ShellFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ShellFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShellType& i)
    {
      e << static_cast< const ::xsd::qif2::TopologyBaseType& > (i);

      // FaceIds
      //
      if (i.FaceIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FaceIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FaceIds ();
      }

      // turned
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "turned",
            e));

        a << i.turned ();
      }

      // closed
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "closed",
            e));

        a << i.closed ();
      }

      // form
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "form",
            e));

        a << i.form ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BodySetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Body
      //
      for (BodySetType::Body_const_iterator
           b (i.Body ().begin ()), n (i.Body ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BodyType& i)
    {
      e << static_cast< const ::xsd::qif2::TopologyBaseType& > (i);

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // ShellIds
      //
      if (i.ShellIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ShellIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ShellIds ();
      }

      // FaceIds
      //
      if (i.FaceIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FaceIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FaceIds ();
      }

      // LoopIds
      //
      if (i.LoopIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LoopIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LoopIds ();
      }

      // EdgeIds
      //
      if (i.EdgeIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EdgeIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EdgeIds ();
      }

      // VertexIds
      //
      if (i.VertexIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "VertexIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.VertexIds ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointCloudSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointCloud
      //
      for (PointCloudSetType::PointCloud_const_iterator
           b (i.PointCloud ().begin ()), n (i.PointCloud ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointCloud",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointCloudType& i)
    {
      e << static_cast< const ::xsd::qif2::TopologyBaseType& > (i);

      // Points
      //
      if (i.Points ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Points",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Points ();
      }

      // PointsBinary
      //
      if (i.PointsBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointsBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointsBinary ();
      }

      // Normals
      //
      if (i.Normals ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normals",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normals ();
      }

      // NormalsBinary
      //
      if (i.NormalsBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NormalsBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NormalsBinary ();
      }

      // PointsVisible
      //
      if (i.PointsVisible ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointsVisible",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointsVisible ();
      }

      // PointsVisibleBinary
      //
      if (i.PointsVisibleBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointsVisibleBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointsVisibleBinary ();
      }

      // PointsHidden
      //
      if (i.PointsHidden ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointsHidden",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointsHidden ();
      }

      // PointsHiddenBinary
      //
      if (i.PointsHiddenBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointsHiddenBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointsHiddenBinary ();
      }

      // PointsColor
      //
      if (i.PointsColor ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointsColor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointsColor ();
      }

      // PointsColorBinary
      //
      if (i.PointsColorBinary ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointsColorBinary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointsColorBinary ();
      }
    }

    void
    TopologySet (::std::ostream& o,
                 const ::xsd::qif2::TopologySetType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TopologySet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    TopologySet (::std::ostream& o,
                 const ::xsd::qif2::TopologySetType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TopologySet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TopologySet (::std::ostream& o,
                 const ::xsd::qif2::TopologySetType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TopologySet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TopologySet (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::TopologySetType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TopologySet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    TopologySet (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::TopologySetType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TopologySet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TopologySet (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::TopologySetType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TopologySet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TopologySet (::xercesc::DOMDocument& d,
                 const ::xsd::qif2::TopologySetType& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TopologySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "TopologySet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    TopologySet (const ::xsd::qif2::TopologySetType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "TopologySet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::TopologySet (*d, s, f);
      return d;
    }

    void
    VertexSet (::std::ostream& o,
               const ::xsd::qif2::VertexSetType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::VertexSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    VertexSet (::std::ostream& o,
               const ::xsd::qif2::VertexSetType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::VertexSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    VertexSet (::std::ostream& o,
               const ::xsd::qif2::VertexSetType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::VertexSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    VertexSet (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::VertexSetType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::VertexSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    VertexSet (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::VertexSetType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::VertexSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    VertexSet (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::VertexSetType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::VertexSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    VertexSet (::xercesc::DOMDocument& d,
               const ::xsd::qif2::VertexSetType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "VertexSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "VertexSet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    VertexSet (const ::xsd::qif2::VertexSetType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "VertexSet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::VertexSet (*d, s, f);
      return d;
    }

    void
    Vertex (::std::ostream& o,
            const ::xsd::qif2::VertexType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Vertex (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Vertex (::std::ostream& o,
            const ::xsd::qif2::VertexType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Vertex (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Vertex (::std::ostream& o,
            const ::xsd::qif2::VertexType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Vertex (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Vertex (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::VertexType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Vertex (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Vertex (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::VertexType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Vertex (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Vertex (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::VertexType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Vertex (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Vertex (::xercesc::DOMDocument& d,
            const ::xsd::qif2::VertexType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Vertex" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Vertex",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Vertex (const ::xsd::qif2::VertexType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Vertex",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::Vertex (*d, s, f);
      return d;
    }

    void
    EdgeSet (::std::ostream& o,
             const ::xsd::qif2::EdgeSetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::EdgeSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    EdgeSet (::std::ostream& o,
             const ::xsd::qif2::EdgeSetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::EdgeSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    EdgeSet (::std::ostream& o,
             const ::xsd::qif2::EdgeSetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::EdgeSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    EdgeSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::EdgeSetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::EdgeSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    EdgeSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::EdgeSetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::EdgeSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    EdgeSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::EdgeSetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::EdgeSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    EdgeSet (::xercesc::DOMDocument& d,
             const ::xsd::qif2::EdgeSetType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EdgeSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "EdgeSet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    EdgeSet (const ::xsd::qif2::EdgeSetType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "EdgeSet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::EdgeSet (*d, s, f);
      return d;
    }

    void
    Edge (::std::ostream& o,
          const ::xsd::qif2::EdgeType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Edge (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Edge (::std::ostream& o,
          const ::xsd::qif2::EdgeType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Edge (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Edge (::std::ostream& o,
          const ::xsd::qif2::EdgeType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Edge (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Edge (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::EdgeType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Edge (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Edge (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::EdgeType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Edge (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Edge (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::EdgeType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Edge (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Edge (::xercesc::DOMDocument& d,
          const ::xsd::qif2::EdgeType& s,
          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Edge" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Edge",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Edge (const ::xsd::qif2::EdgeType& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Edge",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::Edge (*d, s, f);
      return d;
    }

    void
    LoopSet (::std::ostream& o,
             const ::xsd::qif2::LoopSetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LoopSet (::std::ostream& o,
             const ::xsd::qif2::LoopSetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopSet (::std::ostream& o,
             const ::xsd::qif2::LoopSetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::LoopSetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LoopSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::LoopSetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::LoopSetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopSet (::xercesc::DOMDocument& d,
             const ::xsd::qif2::LoopSetType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LoopSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "LoopSet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    LoopSet (const ::xsd::qif2::LoopSetType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "LoopSet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::LoopSet (*d, s, f);
      return d;
    }

    void
    LoopBase (::std::ostream& o,
              const ::xsd::qif2::LoopBaseType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopBase (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LoopBase (::std::ostream& o,
              const ::xsd::qif2::LoopBaseType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopBase (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopBase (::std::ostream& o,
              const ::xsd::qif2::LoopBaseType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopBase (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopBase (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LoopBaseType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopBase (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LoopBase (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LoopBaseType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopBase (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopBase (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LoopBaseType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopBase (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopBase (::xercesc::DOMDocument& d,
              const ::xsd::qif2::LoopBaseType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::LoopBaseType) == typeid (s))
      {
        if (n.name () == "LoopBase" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "LoopBase",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LoopBase",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    LoopBase (const ::xsd::qif2::LoopBaseType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::LoopBaseType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "LoopBase",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LoopBase",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::LoopBase (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LoopType >
    _xsd_Loop_element_serializer_init (
      "LoopBase",
      "http://qifstandards.org/xsd/qif2",
      "Loop",
      "http://qifstandards.org/xsd/qif2");


    void
    Loop (::std::ostream& o,
          const ::xsd::qif2::LoopType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Loop (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Loop (::std::ostream& o,
          const ::xsd::qif2::LoopType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Loop (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Loop (::std::ostream& o,
          const ::xsd::qif2::LoopType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Loop (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Loop (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::LoopType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Loop (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Loop (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::LoopType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Loop (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Loop (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::LoopType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Loop (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Loop (::xercesc::DOMDocument& d,
          const ::xsd::qif2::LoopType& s,
          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::LoopType) == typeid (s))
      {
        if (n.name () == "Loop" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Loop",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Loop",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Loop (const ::xsd::qif2::LoopType& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::LoopType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Loop",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Loop",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Loop (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LoopMeshType >
    _xsd_LoopMesh_element_serializer_init (
      "LoopBase",
      "http://qifstandards.org/xsd/qif2",
      "LoopMesh",
      "http://qifstandards.org/xsd/qif2");


    void
    LoopMesh (::std::ostream& o,
              const ::xsd::qif2::LoopMeshType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopMesh (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LoopMesh (::std::ostream& o,
              const ::xsd::qif2::LoopMeshType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopMesh (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopMesh (::std::ostream& o,
              const ::xsd::qif2::LoopMeshType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopMesh (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopMesh (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LoopMeshType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopMesh (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LoopMesh (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LoopMeshType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopMesh (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopMesh (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LoopMeshType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LoopMesh (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LoopMesh (::xercesc::DOMDocument& d,
              const ::xsd::qif2::LoopMeshType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::LoopMeshType) == typeid (s))
      {
        if (n.name () == "LoopMesh" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "LoopMesh",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LoopMesh",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    LoopMesh (const ::xsd::qif2::LoopMeshType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::LoopMeshType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "LoopMesh",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LoopMesh",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::LoopMesh (*d, s, f);
      return d;
    }

    void
    FaceSet (::std::ostream& o,
             const ::xsd::qif2::FaceSetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FaceSet (::std::ostream& o,
             const ::xsd::qif2::FaceSetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceSet (::std::ostream& o,
             const ::xsd::qif2::FaceSetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::FaceSetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FaceSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::FaceSetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceSet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::FaceSetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceSet (::xercesc::DOMDocument& d,
             const ::xsd::qif2::FaceSetType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FaceSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "FaceSet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    FaceSet (const ::xsd::qif2::FaceSetType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "FaceSet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::FaceSet (*d, s, f);
      return d;
    }

    void
    FaceBase (::std::ostream& o,
              const ::xsd::qif2::FaceBaseType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceBase (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FaceBase (::std::ostream& o,
              const ::xsd::qif2::FaceBaseType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceBase (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceBase (::std::ostream& o,
              const ::xsd::qif2::FaceBaseType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceBase (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceBase (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::FaceBaseType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceBase (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FaceBase (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::FaceBaseType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceBase (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceBase (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::FaceBaseType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceBase (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceBase (::xercesc::DOMDocument& d,
              const ::xsd::qif2::FaceBaseType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::FaceBaseType) == typeid (s))
      {
        if (n.name () == "FaceBase" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "FaceBase",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "FaceBase",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    FaceBase (const ::xsd::qif2::FaceBaseType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::FaceBaseType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "FaceBase",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "FaceBase",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::FaceBase (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::FaceType >
    _xsd_Face_element_serializer_init (
      "FaceBase",
      "http://qifstandards.org/xsd/qif2",
      "Face",
      "http://qifstandards.org/xsd/qif2");


    void
    Face (::std::ostream& o,
          const ::xsd::qif2::FaceType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Face (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Face (::std::ostream& o,
          const ::xsd::qif2::FaceType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Face (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Face (::std::ostream& o,
          const ::xsd::qif2::FaceType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Face (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Face (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::FaceType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Face (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Face (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::FaceType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Face (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Face (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::FaceType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Face (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Face (::xercesc::DOMDocument& d,
          const ::xsd::qif2::FaceType& s,
          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::FaceType) == typeid (s))
      {
        if (n.name () == "Face" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Face",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Face",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Face (const ::xsd::qif2::FaceType& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::FaceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Face",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Face",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Face (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::FaceMeshType >
    _xsd_FaceMesh_element_serializer_init (
      "FaceBase",
      "http://qifstandards.org/xsd/qif2",
      "FaceMesh",
      "http://qifstandards.org/xsd/qif2");


    void
    FaceMesh (::std::ostream& o,
              const ::xsd::qif2::FaceMeshType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceMesh (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FaceMesh (::std::ostream& o,
              const ::xsd::qif2::FaceMeshType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceMesh (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceMesh (::std::ostream& o,
              const ::xsd::qif2::FaceMeshType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceMesh (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceMesh (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::FaceMeshType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceMesh (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FaceMesh (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::FaceMeshType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceMesh (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceMesh (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::FaceMeshType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FaceMesh (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FaceMesh (::xercesc::DOMDocument& d,
              const ::xsd::qif2::FaceMeshType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::FaceMeshType) == typeid (s))
      {
        if (n.name () == "FaceMesh" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "FaceMesh",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "FaceMesh",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    FaceMesh (const ::xsd::qif2::FaceMeshType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::FaceMeshType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "FaceMesh",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "FaceMesh",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::FaceMesh (*d, s, f);
      return d;
    }

    void
    ShellSet (::std::ostream& o,
              const ::xsd::qif2::ShellSetType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ShellSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ShellSet (::std::ostream& o,
              const ::xsd::qif2::ShellSetType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ShellSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ShellSet (::std::ostream& o,
              const ::xsd::qif2::ShellSetType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ShellSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ShellSet (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::ShellSetType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ShellSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ShellSet (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::ShellSetType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ShellSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ShellSet (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::ShellSetType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ShellSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ShellSet (::xercesc::DOMDocument& d,
              const ::xsd::qif2::ShellSetType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ShellSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "ShellSet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    ShellSet (const ::xsd::qif2::ShellSetType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "ShellSet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::ShellSet (*d, s, f);
      return d;
    }

    void
    Shell (::std::ostream& o,
           const ::xsd::qif2::ShellType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Shell (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Shell (::std::ostream& o,
           const ::xsd::qif2::ShellType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Shell (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Shell (::std::ostream& o,
           const ::xsd::qif2::ShellType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Shell (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Shell (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::ShellType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Shell (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Shell (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::ShellType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Shell (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Shell (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::ShellType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Shell (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Shell (::xercesc::DOMDocument& d,
           const ::xsd::qif2::ShellType& s,
           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Shell" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Shell",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Shell (const ::xsd::qif2::ShellType& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Shell",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::Shell (*d, s, f);
      return d;
    }

    void
    BodySet (::std::ostream& o,
             const ::xsd::qif2::BodySetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BodySet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    BodySet (::std::ostream& o,
             const ::xsd::qif2::BodySetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BodySet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BodySet (::std::ostream& o,
             const ::xsd::qif2::BodySetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BodySet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BodySet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::BodySetType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BodySet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    BodySet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::BodySetType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BodySet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BodySet (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::BodySetType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BodySet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BodySet (::xercesc::DOMDocument& d,
             const ::xsd::qif2::BodySetType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "BodySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "BodySet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    BodySet (const ::xsd::qif2::BodySetType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "BodySet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::BodySet (*d, s, f);
      return d;
    }

    void
    Body (::std::ostream& o,
          const ::xsd::qif2::BodyType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Body (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Body (::std::ostream& o,
          const ::xsd::qif2::BodyType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Body (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Body (::std::ostream& o,
          const ::xsd::qif2::BodyType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Body (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Body (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::BodyType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Body (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Body (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::BodyType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Body (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Body (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::BodyType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Body (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Body (::xercesc::DOMDocument& d,
          const ::xsd::qif2::BodyType& s,
          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Body" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Body",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Body (const ::xsd::qif2::BodyType& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Body",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::Body (*d, s, f);
      return d;
    }

    void
    PointCloudSet (::std::ostream& o,
                   const ::xsd::qif2::PointCloudSetType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloudSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    PointCloudSet (::std::ostream& o,
                   const ::xsd::qif2::PointCloudSetType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloudSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloudSet (::std::ostream& o,
                   const ::xsd::qif2::PointCloudSetType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloudSet (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloudSet (::xercesc::XMLFormatTarget& t,
                   const ::xsd::qif2::PointCloudSetType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloudSet (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    PointCloudSet (::xercesc::XMLFormatTarget& t,
                   const ::xsd::qif2::PointCloudSetType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloudSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloudSet (::xercesc::XMLFormatTarget& t,
                   const ::xsd::qif2::PointCloudSetType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloudSet (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloudSet (::xercesc::DOMDocument& d,
                   const ::xsd::qif2::PointCloudSetType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointCloudSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "PointCloudSet",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    PointCloudSet (const ::xsd::qif2::PointCloudSetType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "PointCloudSet",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::PointCloudSet (*d, s, f);
      return d;
    }

    void
    PointCloud (::std::ostream& o,
                const ::xsd::qif2::PointCloudType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloud (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    PointCloud (::std::ostream& o,
                const ::xsd::qif2::PointCloudType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloud (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloud (::std::ostream& o,
                const ::xsd::qif2::PointCloudType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloud (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloud (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::PointCloudType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloud (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    PointCloud (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::PointCloudType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloud (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloud (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::PointCloudType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointCloud (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointCloud (::xercesc::DOMDocument& d,
                const ::xsd::qif2::PointCloudType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointCloud" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "PointCloud",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    PointCloud (const ::xsd::qif2::PointCloudType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "PointCloud",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::PointCloud (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

