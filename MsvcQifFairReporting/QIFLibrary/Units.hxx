// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef UNITS_HXX
#define UNITS_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif2
  {
    class PositiveDecimalType;
    class NonNegativeDecimalType;
    class UnitConversionType;
    class SpecifiedDecimalType;
    class ActualDecimalType;
    class AngularUnitType;
    class AngularValueType;
    class ActualAngularValueType;
    class AreaUnitType;
    class AreaValueType;
    class ActualAreaValueType;
    class ForceUnitType;
    class ForceValueType;
    class ActualForceValueType;
    class LinearUnitType;
    class LinearValueType;
    class ActualLinearValueType;
    class MassUnitType;
    class MassValueType;
    class ActualMassValueType;
    class PressureUnitType;
    class PressureValueType;
    class ActualPressureValueType;
    class SpeedUnitType;
    class SpeedValueType;
    class ActualSpeedValueType;
    class TemperatureUnitType;
    class TemperatureValueType;
    class ActualTemperatureValueType;
    class TimeUnitType;
    class TimeValueType;
    class ActualTimeValueType;
    class PrimaryUnitsType;
    class OtherUnitsType;
    class UserDefinedUnitType;
    class UserDefinedUnitValueType;
    class ActualUserDefinedUnitValueType;
    class UserDefinedUnitsType;
    class FileUnitsType;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace xsd
{
  namespace qif2
  {
    class PositiveDecimalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      PositiveDecimalType (const ::xml_schema::decimal&);

      PositiveDecimalType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PositiveDecimalType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PositiveDecimalType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PositiveDecimalType (const PositiveDecimalType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PositiveDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~PositiveDecimalType ();
    };

    class NonNegativeDecimalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      NonNegativeDecimalType (const ::xml_schema::decimal&);

      NonNegativeDecimalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      NonNegativeDecimalType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      NonNegativeDecimalType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      NonNegativeDecimalType (const NonNegativeDecimalType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual NonNegativeDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~NonNegativeDecimalType ();
    };

    class UnitConversionType: public ::xml_schema::type
    {
      public:
      // Factor
      //
      typedef ::xsd::qif2::PositiveDecimalType Factor_type;
      typedef ::xsd::cxx::tree::traits< Factor_type, char > Factor_traits;

      const Factor_type&
      Factor () const;

      Factor_type&
      Factor ();

      void
      Factor (const Factor_type& x);

      void
      Factor (::std::auto_ptr< Factor_type > p);

      // Offset
      //
      typedef ::xml_schema::decimal Offset_type;
      typedef ::xsd::cxx::tree::optional< Offset_type > Offset_optional;
      typedef ::xsd::cxx::tree::traits< Offset_type, char, ::xsd::cxx::tree::schema_type::decimal > Offset_traits;

      const Offset_optional&
      Offset () const;

      Offset_optional&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (const Offset_optional& x);

      static Offset_type
      Offset_default_value ();

      // Constructors.
      //
      UnitConversionType (const Factor_type&);

      UnitConversionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      UnitConversionType (const UnitConversionType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual UnitConversionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UnitConversionType&
      operator= (const UnitConversionType& x);

      virtual 
      ~UnitConversionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Factor_type > Factor_;
      Offset_optional Offset_;
    };

    class SpecifiedDecimalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // Constructors.
      //
      SpecifiedDecimalType (const ::xml_schema::decimal&);

      SpecifiedDecimalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      SpecifiedDecimalType (const SpecifiedDecimalType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual SpecifiedDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpecifiedDecimalType&
      operator= (const SpecifiedDecimalType& x);

      virtual 
      ~SpecifiedDecimalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
    };

    class ActualDecimalType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // combinedUncertainty
      //
      typedef ::xsd::qif2::NonNegativeDecimalType combinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< combinedUncertainty_type > combinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< combinedUncertainty_type, char > combinedUncertainty_traits;

      const combinedUncertainty_optional&
      combinedUncertainty () const;

      combinedUncertainty_optional&
      combinedUncertainty ();

      void
      combinedUncertainty (const combinedUncertainty_type& x);

      void
      combinedUncertainty (const combinedUncertainty_optional& x);

      void
      combinedUncertainty (::std::auto_ptr< combinedUncertainty_type > p);

      // meanError
      //
      typedef ::xsd::qif2::NonNegativeDecimalType meanError_type;
      typedef ::xsd::cxx::tree::optional< meanError_type > meanError_optional;
      typedef ::xsd::cxx::tree::traits< meanError_type, char > meanError_traits;

      const meanError_optional&
      meanError () const;

      meanError_optional&
      meanError ();

      void
      meanError (const meanError_type& x);

      void
      meanError (const meanError_optional& x);

      void
      meanError (::std::auto_ptr< meanError_type > p);

      // Constructors.
      //
      ActualDecimalType (const ::xml_schema::decimal&);

      ActualDecimalType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ActualDecimalType (const ActualDecimalType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ActualDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualDecimalType&
      operator= (const ActualDecimalType& x);

      virtual 
      ~ActualDecimalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      combinedUncertainty_optional combinedUncertainty_;
      meanError_optional meanError_;
    };

    class AngularUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      AngularUnitType (const UnitName_type&);

      AngularUnitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AngularUnitType (const AngularUnitType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AngularUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularUnitType&
      operator= (const AngularUnitType& x);

      virtual 
      ~AngularUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class AngularValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, char > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::auto_ptr< angularUnit_type > p);

      // Constructors.
      //
      AngularValueType (const ::xml_schema::decimal&);

      AngularValueType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      AngularValueType (const AngularValueType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual AngularValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularValueType&
      operator= (const AngularValueType& x);

      virtual 
      ~AngularValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class ActualAngularValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, char > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::auto_ptr< angularUnit_type > p);

      // Constructors.
      //
      ActualAngularValueType (const ::xml_schema::decimal&);

      ActualAngularValueType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ActualAngularValueType (const ActualAngularValueType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ActualAngularValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualAngularValueType&
      operator= (const ActualAngularValueType& x);

      virtual 
      ~ActualAngularValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class AreaUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      AreaUnitType (const UnitName_type&);

      AreaUnitType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      AreaUnitType (const AreaUnitType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual AreaUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AreaUnitType&
      operator= (const AreaUnitType& x);

      virtual 
      ~AreaUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class AreaValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, char > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::auto_ptr< areaUnit_type > p);

      // Constructors.
      //
      AreaValueType (const ::xml_schema::decimal&);

      AreaValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      AreaValueType (const AreaValueType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual AreaValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AreaValueType&
      operator= (const AreaValueType& x);

      virtual 
      ~AreaValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class ActualAreaValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, char > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::auto_ptr< areaUnit_type > p);

      // Constructors.
      //
      ActualAreaValueType (const ::xml_schema::decimal&);

      ActualAreaValueType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ActualAreaValueType (const ActualAreaValueType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ActualAreaValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualAreaValueType&
      operator= (const ActualAreaValueType& x);

      virtual 
      ~ActualAreaValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class ForceUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      ForceUnitType (const UnitName_type&);

      ForceUnitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ForceUnitType (const ForceUnitType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ForceUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ForceUnitType&
      operator= (const ForceUnitType& x);

      virtual 
      ~ForceUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class ForceValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, char > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::auto_ptr< forceUnit_type > p);

      // Constructors.
      //
      ForceValueType (const ::xml_schema::decimal&);

      ForceValueType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ForceValueType (const ForceValueType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ForceValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ForceValueType&
      operator= (const ForceValueType& x);

      virtual 
      ~ForceValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class ActualForceValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, char > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::auto_ptr< forceUnit_type > p);

      // Constructors.
      //
      ActualForceValueType (const ::xml_schema::decimal&);

      ActualForceValueType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ActualForceValueType (const ActualForceValueType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ActualForceValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualForceValueType&
      operator= (const ActualForceValueType& x);

      virtual 
      ~ActualForceValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class LinearUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      LinearUnitType (const UnitName_type&);

      LinearUnitType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      LinearUnitType (const LinearUnitType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual LinearUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearUnitType&
      operator= (const LinearUnitType& x);

      virtual 
      ~LinearUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class LinearValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // Constructors.
      //
      LinearValueType (const ::xml_schema::decimal&);

      LinearValueType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LinearValueType (const LinearValueType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LinearValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearValueType&
      operator= (const LinearValueType& x);

      virtual 
      ~LinearValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class ActualLinearValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // Constructors.
      //
      ActualLinearValueType (const ::xml_schema::decimal&);

      ActualLinearValueType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ActualLinearValueType (const ActualLinearValueType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ActualLinearValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualLinearValueType&
      operator= (const ActualLinearValueType& x);

      virtual 
      ~ActualLinearValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class MassUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      MassUnitType (const UnitName_type&);

      MassUnitType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      MassUnitType (const MassUnitType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual MassUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MassUnitType&
      operator= (const MassUnitType& x);

      virtual 
      ~MassUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class MassValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, char > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::auto_ptr< massUnit_type > p);

      // Constructors.
      //
      MassValueType (const ::xml_schema::decimal&);

      MassValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      MassValueType (const MassValueType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual MassValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MassValueType&
      operator= (const MassValueType& x);

      virtual 
      ~MassValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class ActualMassValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, char > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::auto_ptr< massUnit_type > p);

      // Constructors.
      //
      ActualMassValueType (const ::xml_schema::decimal&);

      ActualMassValueType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ActualMassValueType (const ActualMassValueType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ActualMassValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualMassValueType&
      operator= (const ActualMassValueType& x);

      virtual 
      ~ActualMassValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class PressureUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      PressureUnitType (const UnitName_type&);

      PressureUnitType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PressureUnitType (const PressureUnitType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PressureUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PressureUnitType&
      operator= (const PressureUnitType& x);

      virtual 
      ~PressureUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class PressureValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, char > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::auto_ptr< pressureUnit_type > p);

      // Constructors.
      //
      PressureValueType (const ::xml_schema::decimal&);

      PressureValueType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PressureValueType (const PressureValueType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PressureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PressureValueType&
      operator= (const PressureValueType& x);

      virtual 
      ~PressureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class ActualPressureValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, char > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::auto_ptr< pressureUnit_type > p);

      // Constructors.
      //
      ActualPressureValueType (const ::xml_schema::decimal&);

      ActualPressureValueType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ActualPressureValueType (const ActualPressureValueType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ActualPressureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualPressureValueType&
      operator= (const ActualPressureValueType& x);

      virtual 
      ~ActualPressureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class SpeedUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      SpeedUnitType (const UnitName_type&);

      SpeedUnitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      SpeedUnitType (const SpeedUnitType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual SpeedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpeedUnitType&
      operator= (const SpeedUnitType& x);

      virtual 
      ~SpeedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class SpeedValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, char > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::auto_ptr< speedUnit_type > p);

      // Constructors.
      //
      SpeedValueType (const ::xml_schema::decimal&);

      SpeedValueType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SpeedValueType (const SpeedValueType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SpeedValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpeedValueType&
      operator= (const SpeedValueType& x);

      virtual 
      ~SpeedValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class ActualSpeedValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, char > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::auto_ptr< speedUnit_type > p);

      // Constructors.
      //
      ActualSpeedValueType (const ::xml_schema::decimal&);

      ActualSpeedValueType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ActualSpeedValueType (const ActualSpeedValueType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ActualSpeedValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualSpeedValueType&
      operator= (const ActualSpeedValueType& x);

      virtual 
      ~ActualSpeedValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class TemperatureUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      TemperatureUnitType (const UnitName_type&);

      TemperatureUnitType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TemperatureUnitType (const TemperatureUnitType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual TemperatureUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureUnitType&
      operator= (const TemperatureUnitType& x);

      virtual 
      ~TemperatureUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class TemperatureValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, char > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::auto_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      TemperatureValueType (const ::xml_schema::decimal&);

      TemperatureValueType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      TemperatureValueType (const TemperatureValueType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual TemperatureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureValueType&
      operator= (const TemperatureValueType& x);

      virtual 
      ~TemperatureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class ActualTemperatureValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, char > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::auto_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      ActualTemperatureValueType (const ::xml_schema::decimal&);

      ActualTemperatureValueType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ActualTemperatureValueType (const ActualTemperatureValueType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ActualTemperatureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualTemperatureValueType&
      operator= (const ActualTemperatureValueType& x);

      virtual 
      ~ActualTemperatureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class TimeUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, char > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::auto_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif2::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, char > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::auto_ptr< UnitConversion_type > p);

      // Constructors.
      //
      TimeUnitType (const UnitName_type&);

      TimeUnitType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      TimeUnitType (const TimeUnitType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual TimeUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TimeUnitType&
      operator= (const TimeUnitType& x);

      virtual 
      ~TimeUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class TimeValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, char > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::auto_ptr< timeUnit_type > p);

      // Constructors.
      //
      TimeValueType (const ::xml_schema::decimal&);

      TimeValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      TimeValueType (const TimeValueType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual TimeValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TimeValueType&
      operator= (const TimeValueType& x);

      virtual 
      ~TimeValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class ActualTimeValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, char > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::auto_ptr< timeUnit_type > p);

      // Constructors.
      //
      ActualTimeValueType (const ::xml_schema::decimal&);

      ActualTimeValueType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ActualTimeValueType (const ActualTimeValueType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ActualTimeValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualTimeValueType&
      operator= (const ActualTimeValueType& x);

      virtual 
      ~ActualTimeValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class PrimaryUnitsType: public ::xml_schema::type
    {
      public:
      // AreaUnit
      //
      typedef ::xsd::qif2::AreaUnitType AreaUnit_type;
      typedef ::xsd::cxx::tree::optional< AreaUnit_type > AreaUnit_optional;
      typedef ::xsd::cxx::tree::traits< AreaUnit_type, char > AreaUnit_traits;

      const AreaUnit_optional&
      AreaUnit () const;

      AreaUnit_optional&
      AreaUnit ();

      void
      AreaUnit (const AreaUnit_type& x);

      void
      AreaUnit (const AreaUnit_optional& x);

      void
      AreaUnit (::std::auto_ptr< AreaUnit_type > p);

      // AngularUnit
      //
      typedef ::xsd::qif2::AngularUnitType AngularUnit_type;
      typedef ::xsd::cxx::tree::optional< AngularUnit_type > AngularUnit_optional;
      typedef ::xsd::cxx::tree::traits< AngularUnit_type, char > AngularUnit_traits;

      const AngularUnit_optional&
      AngularUnit () const;

      AngularUnit_optional&
      AngularUnit ();

      void
      AngularUnit (const AngularUnit_type& x);

      void
      AngularUnit (const AngularUnit_optional& x);

      void
      AngularUnit (::std::auto_ptr< AngularUnit_type > p);

      // ForceUnit
      //
      typedef ::xsd::qif2::ForceUnitType ForceUnit_type;
      typedef ::xsd::cxx::tree::optional< ForceUnit_type > ForceUnit_optional;
      typedef ::xsd::cxx::tree::traits< ForceUnit_type, char > ForceUnit_traits;

      const ForceUnit_optional&
      ForceUnit () const;

      ForceUnit_optional&
      ForceUnit ();

      void
      ForceUnit (const ForceUnit_type& x);

      void
      ForceUnit (const ForceUnit_optional& x);

      void
      ForceUnit (::std::auto_ptr< ForceUnit_type > p);

      // LinearUnit
      //
      typedef ::xsd::qif2::LinearUnitType LinearUnit_type;
      typedef ::xsd::cxx::tree::optional< LinearUnit_type > LinearUnit_optional;
      typedef ::xsd::cxx::tree::traits< LinearUnit_type, char > LinearUnit_traits;

      const LinearUnit_optional&
      LinearUnit () const;

      LinearUnit_optional&
      LinearUnit ();

      void
      LinearUnit (const LinearUnit_type& x);

      void
      LinearUnit (const LinearUnit_optional& x);

      void
      LinearUnit (::std::auto_ptr< LinearUnit_type > p);

      // MassUnit
      //
      typedef ::xsd::qif2::MassUnitType MassUnit_type;
      typedef ::xsd::cxx::tree::optional< MassUnit_type > MassUnit_optional;
      typedef ::xsd::cxx::tree::traits< MassUnit_type, char > MassUnit_traits;

      const MassUnit_optional&
      MassUnit () const;

      MassUnit_optional&
      MassUnit ();

      void
      MassUnit (const MassUnit_type& x);

      void
      MassUnit (const MassUnit_optional& x);

      void
      MassUnit (::std::auto_ptr< MassUnit_type > p);

      // PressureUnit
      //
      typedef ::xsd::qif2::PressureUnitType PressureUnit_type;
      typedef ::xsd::cxx::tree::optional< PressureUnit_type > PressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< PressureUnit_type, char > PressureUnit_traits;

      const PressureUnit_optional&
      PressureUnit () const;

      PressureUnit_optional&
      PressureUnit ();

      void
      PressureUnit (const PressureUnit_type& x);

      void
      PressureUnit (const PressureUnit_optional& x);

      void
      PressureUnit (::std::auto_ptr< PressureUnit_type > p);

      // SpeedUnit
      //
      typedef ::xsd::qif2::SpeedUnitType SpeedUnit_type;
      typedef ::xsd::cxx::tree::optional< SpeedUnit_type > SpeedUnit_optional;
      typedef ::xsd::cxx::tree::traits< SpeedUnit_type, char > SpeedUnit_traits;

      const SpeedUnit_optional&
      SpeedUnit () const;

      SpeedUnit_optional&
      SpeedUnit ();

      void
      SpeedUnit (const SpeedUnit_type& x);

      void
      SpeedUnit (const SpeedUnit_optional& x);

      void
      SpeedUnit (::std::auto_ptr< SpeedUnit_type > p);

      // TemperatureUnit
      //
      typedef ::xsd::qif2::TemperatureUnitType TemperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< TemperatureUnit_type > TemperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureUnit_type, char > TemperatureUnit_traits;

      const TemperatureUnit_optional&
      TemperatureUnit () const;

      TemperatureUnit_optional&
      TemperatureUnit ();

      void
      TemperatureUnit (const TemperatureUnit_type& x);

      void
      TemperatureUnit (const TemperatureUnit_optional& x);

      void
      TemperatureUnit (::std::auto_ptr< TemperatureUnit_type > p);

      // TimeUnit
      //
      typedef ::xsd::qif2::TimeUnitType TimeUnit_type;
      typedef ::xsd::cxx::tree::optional< TimeUnit_type > TimeUnit_optional;
      typedef ::xsd::cxx::tree::traits< TimeUnit_type, char > TimeUnit_traits;

      const TimeUnit_optional&
      TimeUnit () const;

      TimeUnit_optional&
      TimeUnit ();

      void
      TimeUnit (const TimeUnit_type& x);

      void
      TimeUnit (const TimeUnit_optional& x);

      void
      TimeUnit (::std::auto_ptr< TimeUnit_type > p);

      // Constructors.
      //
      PrimaryUnitsType ();

      PrimaryUnitsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PrimaryUnitsType (const PrimaryUnitsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PrimaryUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrimaryUnitsType&
      operator= (const PrimaryUnitsType& x);

      virtual 
      ~PrimaryUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      AreaUnit_optional AreaUnit_;
      AngularUnit_optional AngularUnit_;
      ForceUnit_optional ForceUnit_;
      LinearUnit_optional LinearUnit_;
      MassUnit_optional MassUnit_;
      PressureUnit_optional PressureUnit_;
      SpeedUnit_optional SpeedUnit_;
      TemperatureUnit_optional TemperatureUnit_;
      TimeUnit_optional TimeUnit_;
    };

    class OtherUnitsType: public ::xml_schema::type
    {
      public:
      // AreaUnit
      //
      typedef ::xsd::qif2::AreaUnitType AreaUnit_type;
      typedef ::xsd::cxx::tree::sequence< AreaUnit_type > AreaUnit_sequence;
      typedef AreaUnit_sequence::iterator AreaUnit_iterator;
      typedef AreaUnit_sequence::const_iterator AreaUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< AreaUnit_type, char > AreaUnit_traits;

      const AreaUnit_sequence&
      AreaUnit () const;

      AreaUnit_sequence&
      AreaUnit ();

      void
      AreaUnit (const AreaUnit_sequence& s);

      // AngularUnit
      //
      typedef ::xsd::qif2::AngularUnitType AngularUnit_type;
      typedef ::xsd::cxx::tree::sequence< AngularUnit_type > AngularUnit_sequence;
      typedef AngularUnit_sequence::iterator AngularUnit_iterator;
      typedef AngularUnit_sequence::const_iterator AngularUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< AngularUnit_type, char > AngularUnit_traits;

      const AngularUnit_sequence&
      AngularUnit () const;

      AngularUnit_sequence&
      AngularUnit ();

      void
      AngularUnit (const AngularUnit_sequence& s);

      // ForceUnit
      //
      typedef ::xsd::qif2::ForceUnitType ForceUnit_type;
      typedef ::xsd::cxx::tree::sequence< ForceUnit_type > ForceUnit_sequence;
      typedef ForceUnit_sequence::iterator ForceUnit_iterator;
      typedef ForceUnit_sequence::const_iterator ForceUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< ForceUnit_type, char > ForceUnit_traits;

      const ForceUnit_sequence&
      ForceUnit () const;

      ForceUnit_sequence&
      ForceUnit ();

      void
      ForceUnit (const ForceUnit_sequence& s);

      // LinearUnit
      //
      typedef ::xsd::qif2::LinearUnitType LinearUnit_type;
      typedef ::xsd::cxx::tree::sequence< LinearUnit_type > LinearUnit_sequence;
      typedef LinearUnit_sequence::iterator LinearUnit_iterator;
      typedef LinearUnit_sequence::const_iterator LinearUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< LinearUnit_type, char > LinearUnit_traits;

      const LinearUnit_sequence&
      LinearUnit () const;

      LinearUnit_sequence&
      LinearUnit ();

      void
      LinearUnit (const LinearUnit_sequence& s);

      // MassUnit
      //
      typedef ::xsd::qif2::MassUnitType MassUnit_type;
      typedef ::xsd::cxx::tree::sequence< MassUnit_type > MassUnit_sequence;
      typedef MassUnit_sequence::iterator MassUnit_iterator;
      typedef MassUnit_sequence::const_iterator MassUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< MassUnit_type, char > MassUnit_traits;

      const MassUnit_sequence&
      MassUnit () const;

      MassUnit_sequence&
      MassUnit ();

      void
      MassUnit (const MassUnit_sequence& s);

      // PressureUnit
      //
      typedef ::xsd::qif2::PressureUnitType PressureUnit_type;
      typedef ::xsd::cxx::tree::sequence< PressureUnit_type > PressureUnit_sequence;
      typedef PressureUnit_sequence::iterator PressureUnit_iterator;
      typedef PressureUnit_sequence::const_iterator PressureUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< PressureUnit_type, char > PressureUnit_traits;

      const PressureUnit_sequence&
      PressureUnit () const;

      PressureUnit_sequence&
      PressureUnit ();

      void
      PressureUnit (const PressureUnit_sequence& s);

      // SpeedUnit
      //
      typedef ::xsd::qif2::SpeedUnitType SpeedUnit_type;
      typedef ::xsd::cxx::tree::sequence< SpeedUnit_type > SpeedUnit_sequence;
      typedef SpeedUnit_sequence::iterator SpeedUnit_iterator;
      typedef SpeedUnit_sequence::const_iterator SpeedUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< SpeedUnit_type, char > SpeedUnit_traits;

      const SpeedUnit_sequence&
      SpeedUnit () const;

      SpeedUnit_sequence&
      SpeedUnit ();

      void
      SpeedUnit (const SpeedUnit_sequence& s);

      // TemperatureUnit
      //
      typedef ::xsd::qif2::TemperatureUnitType TemperatureUnit_type;
      typedef ::xsd::cxx::tree::sequence< TemperatureUnit_type > TemperatureUnit_sequence;
      typedef TemperatureUnit_sequence::iterator TemperatureUnit_iterator;
      typedef TemperatureUnit_sequence::const_iterator TemperatureUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< TemperatureUnit_type, char > TemperatureUnit_traits;

      const TemperatureUnit_sequence&
      TemperatureUnit () const;

      TemperatureUnit_sequence&
      TemperatureUnit ();

      void
      TemperatureUnit (const TemperatureUnit_sequence& s);

      // TimeUnit
      //
      typedef ::xsd::qif2::TimeUnitType TimeUnit_type;
      typedef ::xsd::cxx::tree::sequence< TimeUnit_type > TimeUnit_sequence;
      typedef TimeUnit_sequence::iterator TimeUnit_iterator;
      typedef TimeUnit_sequence::const_iterator TimeUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< TimeUnit_type, char > TimeUnit_traits;

      const TimeUnit_sequence&
      TimeUnit () const;

      TimeUnit_sequence&
      TimeUnit ();

      void
      TimeUnit (const TimeUnit_sequence& s);

      // Constructors.
      //
      OtherUnitsType ();

      OtherUnitsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      OtherUnitsType (const OtherUnitsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual OtherUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherUnitsType&
      operator= (const OtherUnitsType& x);

      virtual 
      ~OtherUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      AreaUnit_sequence AreaUnit_;
      AngularUnit_sequence AngularUnit_;
      ForceUnit_sequence ForceUnit_;
      LinearUnit_sequence LinearUnit_;
      MassUnit_sequence MassUnit_;
      PressureUnit_sequence PressureUnit_;
      SpeedUnit_sequence SpeedUnit_;
      TemperatureUnit_sequence TemperatureUnit_;
      TimeUnit_sequence TimeUnit_;
    };

    class UserDefinedUnitType: public ::xml_schema::type
    {
      public:
      // WhatIsMeasured
      //
      typedef ::xml_schema::string WhatIsMeasured_type;
      typedef ::xsd::cxx::tree::traits< WhatIsMeasured_type, char > WhatIsMeasured_traits;

      const WhatIsMeasured_type&
      WhatIsMeasured () const;

      WhatIsMeasured_type&
      WhatIsMeasured ();

      void
      WhatIsMeasured (const WhatIsMeasured_type& x);

      void
      WhatIsMeasured (::std::auto_ptr< WhatIsMeasured_type > p);

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, char > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::auto_ptr< UnitName_type > p);

      // StandardName
      //
      typedef ::xml_schema::string StandardName_type;
      typedef ::xsd::cxx::tree::optional< StandardName_type > StandardName_optional;
      typedef ::xsd::cxx::tree::traits< StandardName_type, char > StandardName_traits;

      const StandardName_optional&
      StandardName () const;

      StandardName_optional&
      StandardName ();

      void
      StandardName (const StandardName_type& x);

      void
      StandardName (const StandardName_optional& x);

      void
      StandardName (::std::auto_ptr< StandardName_type > p);

      // Constructors.
      //
      UserDefinedUnitType (const WhatIsMeasured_type&,
                           const UnitName_type&);

      UserDefinedUnitType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      UserDefinedUnitType (const UserDefinedUnitType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual UserDefinedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitType&
      operator= (const UserDefinedUnitType& x);

      virtual 
      ~UserDefinedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatIsMeasured_type > WhatIsMeasured_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      StandardName_optional StandardName_;
    };

    class UserDefinedUnitValueType: public ::xsd::qif2::SpecifiedDecimalType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, char > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::auto_ptr< unitName_type > p);

      // Constructors.
      //
      UserDefinedUnitValueType (const ::xml_schema::decimal&,
                                const unitName_type&);

      UserDefinedUnitValueType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      UserDefinedUnitValueType (const UserDefinedUnitValueType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual UserDefinedUnitValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitValueType&
      operator= (const UserDefinedUnitValueType& x);

      virtual 
      ~UserDefinedUnitValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class ActualUserDefinedUnitValueType: public ::xsd::qif2::ActualDecimalType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, char > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::auto_ptr< unitName_type > p);

      // Constructors.
      //
      ActualUserDefinedUnitValueType (const ::xml_schema::decimal&,
                                      const unitName_type&);

      ActualUserDefinedUnitValueType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ActualUserDefinedUnitValueType (const ActualUserDefinedUnitValueType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ActualUserDefinedUnitValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualUserDefinedUnitValueType&
      operator= (const ActualUserDefinedUnitValueType& x);

      virtual 
      ~ActualUserDefinedUnitValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class UserDefinedUnitsType: public ::xml_schema::type
    {
      public:
      // UserDefinedUnit
      //
      typedef ::xsd::qif2::UserDefinedUnitType UserDefinedUnit_type;
      typedef ::xsd::cxx::tree::sequence< UserDefinedUnit_type > UserDefinedUnit_sequence;
      typedef UserDefinedUnit_sequence::iterator UserDefinedUnit_iterator;
      typedef UserDefinedUnit_sequence::const_iterator UserDefinedUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnit_type, char > UserDefinedUnit_traits;

      const UserDefinedUnit_sequence&
      UserDefinedUnit () const;

      UserDefinedUnit_sequence&
      UserDefinedUnit ();

      void
      UserDefinedUnit (const UserDefinedUnit_sequence& s);

      // Constructors.
      //
      UserDefinedUnitsType ();

      UserDefinedUnitsType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UserDefinedUnitsType (const UserDefinedUnitsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual UserDefinedUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitsType&
      operator= (const UserDefinedUnitsType& x);

      virtual 
      ~UserDefinedUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      UserDefinedUnit_sequence UserDefinedUnit_;
    };

    class FileUnitsType: public ::xml_schema::type
    {
      public:
      // PrimaryUnits
      //
      typedef ::xsd::qif2::PrimaryUnitsType PrimaryUnits_type;
      typedef ::xsd::cxx::tree::traits< PrimaryUnits_type, char > PrimaryUnits_traits;

      const PrimaryUnits_type&
      PrimaryUnits () const;

      PrimaryUnits_type&
      PrimaryUnits ();

      void
      PrimaryUnits (const PrimaryUnits_type& x);

      void
      PrimaryUnits (::std::auto_ptr< PrimaryUnits_type > p);

      // OtherUnits
      //
      typedef ::xsd::qif2::OtherUnitsType OtherUnits_type;
      typedef ::xsd::cxx::tree::optional< OtherUnits_type > OtherUnits_optional;
      typedef ::xsd::cxx::tree::traits< OtherUnits_type, char > OtherUnits_traits;

      const OtherUnits_optional&
      OtherUnits () const;

      OtherUnits_optional&
      OtherUnits ();

      void
      OtherUnits (const OtherUnits_type& x);

      void
      OtherUnits (const OtherUnits_optional& x);

      void
      OtherUnits (::std::auto_ptr< OtherUnits_type > p);

      // UserDefinedUnits
      //
      typedef ::xsd::qif2::UserDefinedUnitsType UserDefinedUnits_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedUnits_type > UserDefinedUnits_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnits_type, char > UserDefinedUnits_traits;

      const UserDefinedUnits_optional&
      UserDefinedUnits () const;

      UserDefinedUnits_optional&
      UserDefinedUnits ();

      void
      UserDefinedUnits (const UserDefinedUnits_type& x);

      void
      UserDefinedUnits (const UserDefinedUnits_optional& x);

      void
      UserDefinedUnits (::std::auto_ptr< UserDefinedUnits_type > p);

      // Constructors.
      //
      FileUnitsType (const PrimaryUnits_type&);

      FileUnitsType (::std::auto_ptr< PrimaryUnits_type >);

      FileUnitsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      FileUnitsType (const FileUnitsType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual FileUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileUnitsType&
      operator= (const FileUnitsType& x);

      virtual 
      ~FileUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PrimaryUnits_type > PrimaryUnits_;
      OtherUnits_optional OtherUnits_;
      UserDefinedUnits_optional UserDefinedUnits_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif2
  {
    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement&, const PositiveDecimalType&);

    void
    operator<< (::xercesc::DOMAttr&, const PositiveDecimalType&);

    void
    operator<< (::xml_schema::list_stream&,
                const PositiveDecimalType&);

    void
    operator<< (::xercesc::DOMElement&, const NonNegativeDecimalType&);

    void
    operator<< (::xercesc::DOMAttr&, const NonNegativeDecimalType&);

    void
    operator<< (::xml_schema::list_stream&,
                const NonNegativeDecimalType&);

    void
    operator<< (::xercesc::DOMElement&, const UnitConversionType&);

    void
    operator<< (::xercesc::DOMElement&, const SpecifiedDecimalType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualDecimalType&);

    void
    operator<< (::xercesc::DOMElement&, const AngularUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const AngularValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualAngularValueType&);

    void
    operator<< (::xercesc::DOMElement&, const AreaUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const AreaValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualAreaValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ForceUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const ForceValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualForceValueType&);

    void
    operator<< (::xercesc::DOMElement&, const LinearUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const LinearValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualLinearValueType&);

    void
    operator<< (::xercesc::DOMElement&, const MassUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const MassValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualMassValueType&);

    void
    operator<< (::xercesc::DOMElement&, const PressureUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const PressureValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualPressureValueType&);

    void
    operator<< (::xercesc::DOMElement&, const SpeedUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const SpeedValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualSpeedValueType&);

    void
    operator<< (::xercesc::DOMElement&, const TemperatureUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const TemperatureValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualTemperatureValueType&);

    void
    operator<< (::xercesc::DOMElement&, const TimeUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const TimeValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualTimeValueType&);

    void
    operator<< (::xercesc::DOMElement&, const PrimaryUnitsType&);

    void
    operator<< (::xercesc::DOMElement&, const OtherUnitsType&);

    void
    operator<< (::xercesc::DOMElement&, const UserDefinedUnitType&);

    void
    operator<< (::xercesc::DOMElement&, const UserDefinedUnitValueType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualUserDefinedUnitValueType&);

    void
    operator<< (::xercesc::DOMElement&, const UserDefinedUnitsType&);

    void
    operator<< (::xercesc::DOMElement&, const FileUnitsType&);

    // Serialize to std::ostream.
    //

    void
    FileUnits (::std::ostream& os,
               const ::xsd::qif2::FileUnitsType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

    void
    FileUnits (::std::ostream& os,
               const ::xsd::qif2::FileUnitsType& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

    void
    FileUnits (::std::ostream& os,
               const ::xsd::qif2::FileUnitsType& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    FileUnits (::xercesc::XMLFormatTarget& ft,
               const ::xsd::qif2::FileUnitsType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

    void
    FileUnits (::xercesc::XMLFormatTarget& ft,
               const ::xsd::qif2::FileUnitsType& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

    void
    FileUnits (::xercesc::XMLFormatTarget& ft,
               const ::xsd::qif2::FileUnitsType& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    FileUnits (::xercesc::DOMDocument& d,
               const ::xsd::qif2::FileUnitsType& x,
               ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    FileUnits (const ::xsd::qif2::FileUnitsType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // UNITS_HXX
