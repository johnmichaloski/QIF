// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "GenericExpressions.hxx"

namespace xsd
{
  namespace qif2
  {
    // BooleanExpressionBaseType
    // 


    // NotType
    // 

    const NotType::BooleanExpression_type& NotType::
    BooleanExpression () const
    {
      return this->BooleanExpression_.get ();
    }

    NotType::BooleanExpression_type& NotType::
    BooleanExpression ()
    {
      return this->BooleanExpression_.get ();
    }

    void NotType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void NotType::
    BooleanExpression (::std::auto_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (x);
    }


    // BinaryBooleanExpressionBaseType
    // 

    const BinaryBooleanExpressionBaseType::BooleanExpression_sequence& BinaryBooleanExpressionBaseType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    BinaryBooleanExpressionBaseType::BooleanExpression_sequence& BinaryBooleanExpressionBaseType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void BinaryBooleanExpressionBaseType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }


    // AndType
    // 

    const AndType::BooleanExpression_sequence& AndType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    AndType::BooleanExpression_sequence& AndType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void AndType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }


    // OrType
    // 

    const OrType::BooleanExpression_sequence& OrType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    OrType::BooleanExpression_sequence& OrType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void OrType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }


    // BooleanEqualType
    // 


    // ConstantIsType
    // 

    const ConstantIsType::val_type& ConstantIsType::
    val () const
    {
      return this->val_.get ();
    }

    ConstantIsType::val_type& ConstantIsType::
    val ()
    {
      return this->val_.get ();
    }

    void ConstantIsType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }

    void ConstantIsType::
    val (::std::auto_ptr< val_type > x)
    {
      this->val_.set (x);
    }


    // ArithmeticComparisonBaseType
    // 

    const ArithmeticComparisonBaseType::ArithmeticExpression_sequence& ArithmeticComparisonBaseType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_;
    }

    ArithmeticComparisonBaseType::ArithmeticExpression_sequence& ArithmeticComparisonBaseType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_;
    }

    void ArithmeticComparisonBaseType::
    ArithmeticExpression (const ArithmeticExpression_sequence& s)
    {
      this->ArithmeticExpression_ = s;
    }


    // ArithmeticEqualType
    // 


    // GreaterThanType
    // 


    // GreaterOrEqualType
    // 


    // LessThanType
    // 


    // LessOrEqualType
    // 


    // BooleanConstantEnumType
    // 

    BooleanConstantEnumType::
    BooleanConstantEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_BooleanConstantEnumType_literals_[v])
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const BooleanConstantEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    BooleanConstantEnumType& BooleanConstantEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_BooleanConstantEnumType_literals_[v]);

      return *this;
    }


    // ArithmeticExpressionBaseType
    // 


    // ArithmeticConstantType
    // 

    const ArithmeticConstantType::val_type& ArithmeticConstantType::
    val () const
    {
      return this->val_.get ();
    }

    ArithmeticConstantType::val_type& ArithmeticConstantType::
    val ()
    {
      return this->val_.get ();
    }

    void ArithmeticConstantType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }


    // NegateType
    // 

    const NegateType::ArithmeticExpression_type& NegateType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_.get ();
    }

    NegateType::ArithmeticExpression_type& NegateType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_.get ();
    }

    void NegateType::
    ArithmeticExpression (const ArithmeticExpression_type& x)
    {
      this->ArithmeticExpression_.set (x);
    }

    void NegateType::
    ArithmeticExpression (::std::auto_ptr< ArithmeticExpression_type > x)
    {
      this->ArithmeticExpression_.set (x);
    }


    // BinaryArithmeticExpressionBaseType
    // 

    const BinaryArithmeticExpressionBaseType::ArithmeticExpression_sequence& BinaryArithmeticExpressionBaseType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_;
    }

    BinaryArithmeticExpressionBaseType::ArithmeticExpression_sequence& BinaryArithmeticExpressionBaseType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_;
    }

    void BinaryArithmeticExpressionBaseType::
    ArithmeticExpression (const ArithmeticExpression_sequence& s)
    {
      this->ArithmeticExpression_ = s;
    }


    // PlusType
    // 


    // MinusType
    // 


    // TimesType
    // 


    // DividedByType
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // BooleanExpressionBaseType
    //

    BooleanExpressionBaseType::
    BooleanExpressionBaseType ()
    : ::xml_schema::type ()
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const BooleanExpressionBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    BooleanExpressionBaseType* BooleanExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanExpressionBaseType (*this, f, c);
    }

    BooleanExpressionBaseType::
    ~BooleanExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BooleanExpressionBaseType >
    _xsd_BooleanExpressionBaseType_type_factory_init (
      "BooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // NotType
    //

    NotType::
    NotType (const BooleanExpression_type& BooleanExpression)
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (BooleanExpression, this)
    {
    }

    NotType::
    NotType (::std::auto_ptr< BooleanExpression_type > BooleanExpression)
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (BooleanExpression, this)
    {
    }

    NotType::
    NotType (const NotType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    NotType::
    NotType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NotType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!BooleanExpression_.present ())
            {
              ::std::auto_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->BooleanExpression_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!BooleanExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BooleanExpression",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NotType* NotType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotType (*this, f, c);
    }

    NotType& NotType::
    operator= (const NotType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    NotType::
    ~NotType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NotType >
    _xsd_NotType_type_factory_init (
      "NotType",
      "http://qifstandards.org/xsd/qif2");

    // BinaryBooleanExpressionBaseType
    //

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType (const BinaryBooleanExpressionBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BinaryBooleanExpressionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BooleanExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    BinaryBooleanExpressionBaseType* BinaryBooleanExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryBooleanExpressionBaseType (*this, f, c);
    }

    BinaryBooleanExpressionBaseType& BinaryBooleanExpressionBaseType::
    operator= (const BinaryBooleanExpressionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    BinaryBooleanExpressionBaseType::
    ~BinaryBooleanExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BinaryBooleanExpressionBaseType >
    _xsd_BinaryBooleanExpressionBaseType_type_factory_init (
      "BinaryBooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // AndType
    //

    AndType::
    AndType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    AndType::
    AndType (const AndType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    AndType::
    AndType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AndType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BooleanExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AndType* AndType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AndType (*this, f, c);
    }

    AndType& AndType::
    operator= (const AndType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    AndType::
    ~AndType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AndType >
    _xsd_AndType_type_factory_init (
      "AndType",
      "http://qifstandards.org/xsd/qif2");

    // OrType
    //

    OrType::
    OrType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    OrType::
    OrType (const OrType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    OrType::
    OrType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BooleanExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    OrType* OrType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrType (*this, f, c);
    }

    OrType& OrType::
    operator= (const OrType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    OrType::
    ~OrType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrType >
    _xsd_OrType_type_factory_init (
      "OrType",
      "http://qifstandards.org/xsd/qif2");

    // BooleanEqualType
    //

    BooleanEqualType::
    BooleanEqualType ()
    : ::xsd::qif2::BinaryBooleanExpressionBaseType ()
    {
    }

    BooleanEqualType::
    BooleanEqualType (const BooleanEqualType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::BinaryBooleanExpressionBaseType (x, f, c)
    {
    }

    BooleanEqualType::
    BooleanEqualType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::BinaryBooleanExpressionBaseType (e, f, c)
    {
    }

    BooleanEqualType* BooleanEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanEqualType (*this, f, c);
    }

    BooleanEqualType::
    ~BooleanEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BooleanEqualType >
    _xsd_BooleanEqualType_type_factory_init (
      "BooleanEqualType",
      "http://qifstandards.org/xsd/qif2");

    // ConstantIsType
    //

    ConstantIsType::
    ConstantIsType (const val_type& val)
    : ::xsd::qif2::BooleanExpressionBaseType (),
      val_ (val, this)
    {
    }

    ConstantIsType::
    ConstantIsType (const ConstantIsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    ConstantIsType::
    ConstantIsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ConstantIsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "val",
          "");
      }
    }

    ConstantIsType* ConstantIsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConstantIsType (*this, f, c);
    }

    ConstantIsType& ConstantIsType::
    operator= (const ConstantIsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    ConstantIsType::
    ~ConstantIsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConstantIsType >
    _xsd_ConstantIsType_type_factory_init (
      "ConstantIsType",
      "http://qifstandards.org/xsd/qif2");

    // ArithmeticComparisonBaseType
    //

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType (const ArithmeticComparisonBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticComparisonBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ArithmeticExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< ArithmeticExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ArithmeticExpression_type > r (
              dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArithmeticExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    ArithmeticComparisonBaseType* ArithmeticComparisonBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticComparisonBaseType (*this, f, c);
    }

    ArithmeticComparisonBaseType& ArithmeticComparisonBaseType::
    operator= (const ArithmeticComparisonBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    ArithmeticComparisonBaseType::
    ~ArithmeticComparisonBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticComparisonBaseType >
    _xsd_ArithmeticComparisonBaseType_type_factory_init (
      "ArithmeticComparisonBaseType",
      "http://qifstandards.org/xsd/qif2");

    // ArithmeticEqualType
    //

    ArithmeticEqualType::
    ArithmeticEqualType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    ArithmeticEqualType::
    ArithmeticEqualType (const ArithmeticEqualType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    ArithmeticEqualType::
    ArithmeticEqualType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    ArithmeticEqualType* ArithmeticEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticEqualType (*this, f, c);
    }

    ArithmeticEqualType::
    ~ArithmeticEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticEqualType >
    _xsd_ArithmeticEqualType_type_factory_init (
      "ArithmeticEqualType",
      "http://qifstandards.org/xsd/qif2");

    // GreaterThanType
    //

    GreaterThanType::
    GreaterThanType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    GreaterThanType::
    GreaterThanType (const GreaterThanType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    GreaterThanType::
    GreaterThanType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    GreaterThanType* GreaterThanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GreaterThanType (*this, f, c);
    }

    GreaterThanType::
    ~GreaterThanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GreaterThanType >
    _xsd_GreaterThanType_type_factory_init (
      "GreaterThanType",
      "http://qifstandards.org/xsd/qif2");

    // GreaterOrEqualType
    //

    GreaterOrEqualType::
    GreaterOrEqualType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    GreaterOrEqualType::
    GreaterOrEqualType (const GreaterOrEqualType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    GreaterOrEqualType::
    GreaterOrEqualType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    GreaterOrEqualType* GreaterOrEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GreaterOrEqualType (*this, f, c);
    }

    GreaterOrEqualType::
    ~GreaterOrEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GreaterOrEqualType >
    _xsd_GreaterOrEqualType_type_factory_init (
      "GreaterOrEqualType",
      "http://qifstandards.org/xsd/qif2");

    // LessThanType
    //

    LessThanType::
    LessThanType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    LessThanType::
    LessThanType (const LessThanType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    LessThanType::
    LessThanType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    LessThanType* LessThanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LessThanType (*this, f, c);
    }

    LessThanType::
    ~LessThanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LessThanType >
    _xsd_LessThanType_type_factory_init (
      "LessThanType",
      "http://qifstandards.org/xsd/qif2");

    // LessOrEqualType
    //

    LessOrEqualType::
    LessOrEqualType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    LessOrEqualType::
    LessOrEqualType (const LessOrEqualType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    LessOrEqualType::
    LessOrEqualType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    LessOrEqualType* LessOrEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LessOrEqualType (*this, f, c);
    }

    LessOrEqualType::
    ~LessOrEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LessOrEqualType >
    _xsd_LessOrEqualType_type_factory_init (
      "LessOrEqualType",
      "http://qifstandards.org/xsd/qif2");

    // BooleanConstantEnumType
    //

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType* BooleanConstantEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanConstantEnumType (*this, f, c);
    }

    BooleanConstantEnumType::value BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BooleanConstantEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_BooleanConstantEnumType_indexes_,
                        _xsd_BooleanConstantEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_BooleanConstantEnumType_indexes_ + 2 || _xsd_BooleanConstantEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_literals_[2] =
    {
      "QIF_TRUE",
      "QIF_FALSE"
    };

    const BooleanConstantEnumType::value BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_indexes_[2] =
    {
      ::xsd::qif2::BooleanConstantEnumType::QIF_FALSE,
      ::xsd::qif2::BooleanConstantEnumType::QIF_TRUE
    };

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::NotType >
    _xsd_Not_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Not",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConstantIsType >
    _xsd_ConstantIs_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ConstantIs",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::AndType >
    _xsd_And_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "And",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OrType >
    _xsd_Or_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Or",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::BooleanEqualType >
    _xsd_BooleanEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "BooleanEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArithmeticEqualType >
    _xsd_ArithmeticEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GreaterThanType >
    _xsd_GreaterThan_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterThan",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GreaterOrEqualType >
    _xsd_GreaterOrEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterOrEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LessThanType >
    _xsd_LessThan_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessThan",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LessOrEqualType >
    _xsd_LessOrEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessOrEqual",
      "http://qifstandards.org/xsd/qif2");


    // ArithmeticExpressionBaseType
    //

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType ()
    : ::xml_schema::type ()
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ArithmeticExpressionBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    ArithmeticExpressionBaseType* ArithmeticExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticExpressionBaseType (*this, f, c);
    }

    ArithmeticExpressionBaseType::
    ~ArithmeticExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticExpressionBaseType >
    _xsd_ArithmeticExpressionBaseType_type_factory_init (
      "ArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // ArithmeticConstantType
    //

    ArithmeticConstantType::
    ArithmeticConstantType (const val_type& val)
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      val_ (val, this)
    {
    }

    ArithmeticConstantType::
    ArithmeticConstantType (const ArithmeticConstantType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    ArithmeticConstantType::
    ArithmeticConstantType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArithmeticConstantType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "val",
          "");
      }
    }

    ArithmeticConstantType* ArithmeticConstantType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticConstantType (*this, f, c);
    }

    ArithmeticConstantType& ArithmeticConstantType::
    operator= (const ArithmeticConstantType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ArithmeticExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    ArithmeticConstantType::
    ~ArithmeticConstantType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticConstantType >
    _xsd_ArithmeticConstantType_type_factory_init (
      "ArithmeticConstantType",
      "http://qifstandards.org/xsd/qif2");

    // NegateType
    //

    NegateType::
    NegateType (const ArithmeticExpression_type& ArithmeticExpression)
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (ArithmeticExpression, this)
    {
    }

    NegateType::
    NegateType (::std::auto_ptr< ArithmeticExpression_type > ArithmeticExpression)
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (ArithmeticExpression, this)
    {
    }

    NegateType::
    NegateType (const NegateType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    NegateType::
    NegateType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NegateType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ArithmeticExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< ArithmeticExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArithmeticExpression_.present ())
            {
              ::std::auto_ptr< ArithmeticExpression_type > r (
                dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ArithmeticExpression_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!ArithmeticExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ArithmeticExpression",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NegateType* NegateType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NegateType (*this, f, c);
    }

    NegateType& NegateType::
    operator= (const NegateType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ArithmeticExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    NegateType::
    ~NegateType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NegateType >
    _xsd_NegateType_type_factory_init (
      "NegateType",
      "http://qifstandards.org/xsd/qif2");

    // BinaryArithmeticExpressionBaseType
    //

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType ()
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType (const BinaryArithmeticExpressionBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BinaryArithmeticExpressionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ArithmeticExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< ArithmeticExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ArithmeticExpression_type > r (
              dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArithmeticExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    BinaryArithmeticExpressionBaseType* BinaryArithmeticExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryArithmeticExpressionBaseType (*this, f, c);
    }

    BinaryArithmeticExpressionBaseType& BinaryArithmeticExpressionBaseType::
    operator= (const BinaryArithmeticExpressionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ArithmeticExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    BinaryArithmeticExpressionBaseType::
    ~BinaryArithmeticExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BinaryArithmeticExpressionBaseType >
    _xsd_BinaryArithmeticExpressionBaseType_type_factory_init (
      "BinaryArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // PlusType
    //

    PlusType::
    PlusType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    PlusType::
    PlusType (const PlusType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    PlusType::
    PlusType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    PlusType* PlusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlusType (*this, f, c);
    }

    PlusType::
    ~PlusType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PlusType >
    _xsd_PlusType_type_factory_init (
      "PlusType",
      "http://qifstandards.org/xsd/qif2");

    // MinusType
    //

    MinusType::
    MinusType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    MinusType::
    MinusType (const MinusType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    MinusType::
    MinusType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    MinusType* MinusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MinusType (*this, f, c);
    }

    MinusType::
    ~MinusType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MinusType >
    _xsd_MinusType_type_factory_init (
      "MinusType",
      "http://qifstandards.org/xsd/qif2");

    // TimesType
    //

    TimesType::
    TimesType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    TimesType::
    TimesType (const TimesType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    TimesType::
    TimesType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    TimesType* TimesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimesType (*this, f, c);
    }

    TimesType::
    ~TimesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TimesType >
    _xsd_TimesType_type_factory_init (
      "TimesType",
      "http://qifstandards.org/xsd/qif2");

    // DividedByType
    //

    DividedByType::
    DividedByType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    DividedByType::
    DividedByType (const DividedByType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    DividedByType::
    DividedByType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    DividedByType* DividedByType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DividedByType (*this, f, c);
    }

    DividedByType::
    ~DividedByType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DividedByType >
    _xsd_DividedByType_type_factory_init (
      "DividedByType",
      "http://qifstandards.org/xsd/qif2");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArithmeticConstantType >
    _xsd_ArithmeticConstant_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticConstant",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PlusType >
    _xsd_Plus_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Plus",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::MinusType >
    _xsd_Minus_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Minus",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::NegateType >
    _xsd_Negate_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Negate",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TimesType >
    _xsd_Times_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Times",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DividedByType >
    _xsd_DividedBy_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "DividedBy",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > (
        ::xsd::qif2::BooleanExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > (
        ::xsd::qif2::BooleanExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > (
        ::xsd::qif2::BooleanExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BooleanExpression (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BooleanExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BooleanExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BooleanExpression (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BooleanExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BooleanExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > (
        ::xsd::qif2::BooleanExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > (
        ::xsd::qif2::BooleanExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > (
        ::xsd::qif2::BooleanExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > (
          ::xsd::qif2::BooleanExpression (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "BooleanExpression",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::BooleanExpressionBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > r (
          dynamic_cast< ::xsd::qif2::BooleanExpressionBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BooleanExpression",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType >
    BooleanExpression (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "BooleanExpression",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::BooleanExpressionBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::BooleanExpressionBaseType > r (
          dynamic_cast< ::xsd::qif2::BooleanExpressionBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BooleanExpression",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::NotType > (
        ::xsd::qif2::Not (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NotType > (
        ::xsd::qif2::Not (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NotType > (
        ::xsd::qif2::Not (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Not (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Not (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Not (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Not (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Not (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Not (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::NotType > (
        ::xsd::qif2::Not (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NotType > (
        ::xsd::qif2::Not (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NotType > (
        ::xsd::qif2::Not (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::NotType > (
          ::xsd::qif2::Not (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Not",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::NotType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::NotType > r (
          dynamic_cast< ::xsd::qif2::NotType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Not",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NotType >
    Not (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Not",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::NotType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::NotType > r (
          dynamic_cast< ::xsd::qif2::NotType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Not",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ConstantIsType > (
        ::xsd::qif2::ConstantIs (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ConstantIsType > (
        ::xsd::qif2::ConstantIs (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ConstantIsType > (
        ::xsd::qif2::ConstantIs (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConstantIs (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConstantIs (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConstantIs (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConstantIs (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConstantIs (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConstantIs (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ConstantIsType > (
        ::xsd::qif2::ConstantIs (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ConstantIsType > (
        ::xsd::qif2::ConstantIs (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ConstantIsType > (
        ::xsd::qif2::ConstantIs (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ConstantIsType > (
          ::xsd::qif2::ConstantIs (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ConstantIs",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ConstantIsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::ConstantIsType > r (
          dynamic_cast< ::xsd::qif2::ConstantIsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConstantIs",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConstantIsType >
    ConstantIs (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ConstantIs",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ConstantIsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::ConstantIsType > r (
          dynamic_cast< ::xsd::qif2::ConstantIsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConstantIs",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::AndType > (
        ::xsd::qif2::And (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::AndType > (
        ::xsd::qif2::And (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::AndType > (
        ::xsd::qif2::And (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::And (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::And (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::And (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::And (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::And (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::And (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::AndType > (
        ::xsd::qif2::And (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::AndType > (
        ::xsd::qif2::And (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::AndType > (
        ::xsd::qif2::And (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::AndType > (
          ::xsd::qif2::And (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "And",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::AndType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::AndType > r (
          dynamic_cast< ::xsd::qif2::AndType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "And",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AndType >
    And (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "And",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::AndType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::AndType > r (
          dynamic_cast< ::xsd::qif2::AndType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "And",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::OrType > (
        ::xsd::qif2::Or (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::OrType > (
        ::xsd::qif2::Or (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::OrType > (
        ::xsd::qif2::Or (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Or (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Or (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Or (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Or (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Or (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Or (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::OrType > (
        ::xsd::qif2::Or (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::OrType > (
        ::xsd::qif2::Or (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::OrType > (
        ::xsd::qif2::Or (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::OrType > (
          ::xsd::qif2::Or (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Or",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::OrType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::OrType > r (
          dynamic_cast< ::xsd::qif2::OrType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Or",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OrType >
    Or (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Or",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::OrType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::OrType > r (
          dynamic_cast< ::xsd::qif2::OrType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Or",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > (
        ::xsd::qif2::BooleanEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > (
        ::xsd::qif2::BooleanEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > (
        ::xsd::qif2::BooleanEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BooleanEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BooleanEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BooleanEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BooleanEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BooleanEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BooleanEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > (
        ::xsd::qif2::BooleanEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > (
        ::xsd::qif2::BooleanEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > (
        ::xsd::qif2::BooleanEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > (
          ::xsd::qif2::BooleanEqual (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "BooleanEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::BooleanEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > r (
          dynamic_cast< ::xsd::qif2::BooleanEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BooleanEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BooleanEqualType >
    BooleanEqual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "BooleanEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::BooleanEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::BooleanEqualType > r (
          dynamic_cast< ::xsd::qif2::BooleanEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BooleanEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > (
        ::xsd::qif2::ArithmeticEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > (
        ::xsd::qif2::ArithmeticEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > (
        ::xsd::qif2::ArithmeticEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > (
        ::xsd::qif2::ArithmeticEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > (
        ::xsd::qif2::ArithmeticEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > (
        ::xsd::qif2::ArithmeticEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > (
          ::xsd::qif2::ArithmeticEqual (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ArithmeticEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ArithmeticEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > r (
          dynamic_cast< ::xsd::qif2::ArithmeticEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArithmeticEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType >
    ArithmeticEqual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ArithmeticEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ArithmeticEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::ArithmeticEqualType > r (
          dynamic_cast< ::xsd::qif2::ArithmeticEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArithmeticEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterThanType > (
        ::xsd::qif2::GreaterThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterThanType > (
        ::xsd::qif2::GreaterThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterThanType > (
        ::xsd::qif2::GreaterThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GreaterThan (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GreaterThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GreaterThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GreaterThan (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GreaterThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GreaterThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterThanType > (
        ::xsd::qif2::GreaterThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterThanType > (
        ::xsd::qif2::GreaterThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterThanType > (
        ::xsd::qif2::GreaterThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::GreaterThanType > (
          ::xsd::qif2::GreaterThan (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GreaterThan",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::GreaterThanType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::GreaterThanType > r (
          dynamic_cast< ::xsd::qif2::GreaterThanType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GreaterThan",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterThanType >
    GreaterThan (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GreaterThan",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::GreaterThanType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::GreaterThanType > r (
          dynamic_cast< ::xsd::qif2::GreaterThanType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GreaterThan",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > (
        ::xsd::qif2::GreaterOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > (
        ::xsd::qif2::GreaterOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > (
        ::xsd::qif2::GreaterOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GreaterOrEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GreaterOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GreaterOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GreaterOrEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GreaterOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GreaterOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > (
        ::xsd::qif2::GreaterOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > (
        ::xsd::qif2::GreaterOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > (
        ::xsd::qif2::GreaterOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > (
          ::xsd::qif2::GreaterOrEqual (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GreaterOrEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::GreaterOrEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > r (
          dynamic_cast< ::xsd::qif2::GreaterOrEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GreaterOrEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType >
    GreaterOrEqual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GreaterOrEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::GreaterOrEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::GreaterOrEqualType > r (
          dynamic_cast< ::xsd::qif2::GreaterOrEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GreaterOrEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LessThanType > (
        ::xsd::qif2::LessThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessThanType > (
        ::xsd::qif2::LessThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessThanType > (
        ::xsd::qif2::LessThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LessThan (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LessThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LessThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LessThan (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LessThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LessThan (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LessThanType > (
        ::xsd::qif2::LessThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessThanType > (
        ::xsd::qif2::LessThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessThanType > (
        ::xsd::qif2::LessThan (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::LessThanType > (
          ::xsd::qif2::LessThan (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LessThan",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LessThanType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::LessThanType > r (
          dynamic_cast< ::xsd::qif2::LessThanType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LessThan",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LessThanType >
    LessThan (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LessThan",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LessThanType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::LessThanType > r (
          dynamic_cast< ::xsd::qif2::LessThanType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LessThan",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > (
        ::xsd::qif2::LessOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > (
        ::xsd::qif2::LessOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > (
        ::xsd::qif2::LessOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LessOrEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LessOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LessOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LessOrEqual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LessOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LessOrEqual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > (
        ::xsd::qif2::LessOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > (
        ::xsd::qif2::LessOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > (
        ::xsd::qif2::LessOrEqual (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > (
          ::xsd::qif2::LessOrEqual (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LessOrEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LessOrEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > r (
          dynamic_cast< ::xsd::qif2::LessOrEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LessOrEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LessOrEqualType >
    LessOrEqual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LessOrEqual",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::LessOrEqualType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::LessOrEqualType > r (
          dynamic_cast< ::xsd::qif2::LessOrEqualType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LessOrEqual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > (
        ::xsd::qif2::ArithmeticExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > (
        ::xsd::qif2::ArithmeticExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > (
        ::xsd::qif2::ArithmeticExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticExpression (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticExpression (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticExpression (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > (
        ::xsd::qif2::ArithmeticExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > (
        ::xsd::qif2::ArithmeticExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > (
        ::xsd::qif2::ArithmeticExpression (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > (
          ::xsd::qif2::ArithmeticExpression (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ArithmeticExpression",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ArithmeticExpressionBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > r (
          dynamic_cast< ::xsd::qif2::ArithmeticExpressionBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArithmeticExpression",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType >
    ArithmeticExpression (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ArithmeticExpression",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ArithmeticExpressionBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::ArithmeticExpressionBaseType > r (
          dynamic_cast< ::xsd::qif2::ArithmeticExpressionBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArithmeticExpression",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > (
        ::xsd::qif2::ArithmeticConstant (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > (
        ::xsd::qif2::ArithmeticConstant (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > (
        ::xsd::qif2::ArithmeticConstant (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticConstant (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticConstant (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArithmeticConstant (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticConstant (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticConstant (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArithmeticConstant (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > (
        ::xsd::qif2::ArithmeticConstant (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > (
        ::xsd::qif2::ArithmeticConstant (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > (
        ::xsd::qif2::ArithmeticConstant (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > (
          ::xsd::qif2::ArithmeticConstant (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ArithmeticConstant",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ArithmeticConstantType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > r (
          dynamic_cast< ::xsd::qif2::ArithmeticConstantType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArithmeticConstant",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType >
    ArithmeticConstant (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ArithmeticConstant",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ArithmeticConstantType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::ArithmeticConstantType > r (
          dynamic_cast< ::xsd::qif2::ArithmeticConstantType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArithmeticConstant",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PlusType > (
        ::xsd::qif2::Plus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PlusType > (
        ::xsd::qif2::Plus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PlusType > (
        ::xsd::qif2::Plus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Plus (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Plus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Plus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Plus (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Plus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Plus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PlusType > (
        ::xsd::qif2::Plus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PlusType > (
        ::xsd::qif2::Plus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PlusType > (
        ::xsd::qif2::Plus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::PlusType > (
          ::xsd::qif2::Plus (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Plus",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::PlusType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::PlusType > r (
          dynamic_cast< ::xsd::qif2::PlusType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Plus",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlusType >
    Plus (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Plus",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::PlusType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::PlusType > r (
          dynamic_cast< ::xsd::qif2::PlusType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Plus",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::MinusType > (
        ::xsd::qif2::Minus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MinusType > (
        ::xsd::qif2::Minus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MinusType > (
        ::xsd::qif2::Minus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Minus (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Minus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Minus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Minus (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Minus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Minus (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::MinusType > (
        ::xsd::qif2::Minus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MinusType > (
        ::xsd::qif2::Minus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MinusType > (
        ::xsd::qif2::Minus (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::MinusType > (
          ::xsd::qif2::Minus (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Minus",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::MinusType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::MinusType > r (
          dynamic_cast< ::xsd::qif2::MinusType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Minus",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MinusType >
    Minus (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Minus",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::MinusType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::MinusType > r (
          dynamic_cast< ::xsd::qif2::MinusType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Minus",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::NegateType > (
        ::xsd::qif2::Negate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NegateType > (
        ::xsd::qif2::Negate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NegateType > (
        ::xsd::qif2::Negate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Negate (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Negate (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Negate (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Negate (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Negate (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Negate (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::NegateType > (
        ::xsd::qif2::Negate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NegateType > (
        ::xsd::qif2::Negate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::NegateType > (
        ::xsd::qif2::Negate (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::NegateType > (
          ::xsd::qif2::Negate (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Negate",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::NegateType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::NegateType > r (
          dynamic_cast< ::xsd::qif2::NegateType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Negate",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NegateType >
    Negate (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Negate",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::NegateType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::NegateType > r (
          dynamic_cast< ::xsd::qif2::NegateType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Negate",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::TimesType > (
        ::xsd::qif2::Times (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TimesType > (
        ::xsd::qif2::Times (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TimesType > (
        ::xsd::qif2::Times (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Times (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Times (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Times (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Times (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Times (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Times (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::TimesType > (
        ::xsd::qif2::Times (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TimesType > (
        ::xsd::qif2::Times (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TimesType > (
        ::xsd::qif2::Times (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::TimesType > (
          ::xsd::qif2::Times (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Times",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::TimesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::TimesType > r (
          dynamic_cast< ::xsd::qif2::TimesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Times",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TimesType >
    Times (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Times",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::TimesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::TimesType > r (
          dynamic_cast< ::xsd::qif2::TimesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Times",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::DividedByType > (
        ::xsd::qif2::DividedBy (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DividedByType > (
        ::xsd::qif2::DividedBy (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DividedByType > (
        ::xsd::qif2::DividedBy (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DividedBy (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DividedBy (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DividedBy (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DividedBy (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DividedBy (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DividedBy (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::DividedByType > (
        ::xsd::qif2::DividedBy (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DividedByType > (
        ::xsd::qif2::DividedBy (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DividedByType > (
        ::xsd::qif2::DividedBy (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::DividedByType > (
          ::xsd::qif2::DividedBy (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "DividedBy",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::DividedByType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::DividedByType > r (
          dynamic_cast< ::xsd::qif2::DividedByType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DividedBy",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::DividedByType >
    DividedBy (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "DividedBy",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::DividedByType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::DividedByType > r (
          dynamic_cast< ::xsd::qif2::DividedByType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DividedBy",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const BooleanExpressionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const BooleanExpressionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const BooleanExpressionBaseType&)
    {
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BooleanExpressionBaseType >
    _xsd_BooleanExpressionBaseType_type_serializer_init (
      "BooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const NotType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const NotType::BooleanExpression_type& x (i.BooleanExpression ());
        if (typeid (NotType::BooleanExpression_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BooleanExpression",
            "http://qifstandards.org/xsd/qif2",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NotType >
    _xsd_NotType_type_serializer_init (
      "NotType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BinaryBooleanExpressionBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (BinaryBooleanExpressionBaseType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          if (typeid (BinaryBooleanExpressionBaseType::BooleanExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BooleanExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BinaryBooleanExpressionBaseType >
    _xsd_BinaryBooleanExpressionBaseType_type_serializer_init (
      "BinaryBooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const AndType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (AndType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          if (typeid (AndType::BooleanExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BooleanExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AndType >
    _xsd_AndType_type_serializer_init (
      "AndType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OrType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (OrType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          if (typeid (OrType::BooleanExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BooleanExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrType >
    _xsd_OrType_type_serializer_init (
      "OrType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BooleanEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryBooleanExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BooleanEqualType >
    _xsd_BooleanEqualType_type_serializer_init (
      "BooleanEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConstantIsType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // val
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConstantIsType >
    _xsd_ConstantIsType_type_serializer_init (
      "ConstantIsType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticComparisonBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ArithmeticComparisonBaseType::ArithmeticExpression_const_iterator
             b (i.ArithmeticExpression ().begin ()), n (i.ArithmeticExpression ().end ());
             b != n; ++b)
        {
          if (typeid (ArithmeticComparisonBaseType::ArithmeticExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ArithmeticExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticComparisonBaseType >
    _xsd_ArithmeticComparisonBaseType_type_serializer_init (
      "ArithmeticComparisonBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticEqualType >
    _xsd_ArithmeticEqualType_type_serializer_init (
      "ArithmeticEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GreaterThanType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GreaterThanType >
    _xsd_GreaterThanType_type_serializer_init (
      "GreaterThanType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GreaterOrEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GreaterOrEqualType >
    _xsd_GreaterOrEqualType_type_serializer_init (
      "GreaterOrEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LessThanType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LessThanType >
    _xsd_LessThanType_type_serializer_init (
      "LessThanType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LessOrEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LessOrEqualType >
    _xsd_LessOrEqualType_type_serializer_init (
      "LessOrEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BooleanConstantEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const BooleanConstantEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const BooleanConstantEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    BooleanExpression (::std::ostream& o,
                       const ::xsd::qif2::BooleanExpressionBaseType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanExpression (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    BooleanExpression (::std::ostream& o,
                       const ::xsd::qif2::BooleanExpressionBaseType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanExpression (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanExpression (::std::ostream& o,
                       const ::xsd::qif2::BooleanExpressionBaseType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanExpression (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanExpression (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::BooleanExpressionBaseType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanExpression (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    BooleanExpression (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::BooleanExpressionBaseType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanExpression (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanExpression (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::BooleanExpressionBaseType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanExpression (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanExpression (::xercesc::DOMDocument& d,
                       const ::xsd::qif2::BooleanExpressionBaseType& s,
                       ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::BooleanExpressionBaseType) == typeid (s))
      {
        if (n.name () == "BooleanExpression" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "BooleanExpression",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "BooleanExpression",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    BooleanExpression (const ::xsd::qif2::BooleanExpressionBaseType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::BooleanExpressionBaseType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "BooleanExpression",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "BooleanExpression",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::BooleanExpression (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::NotType >
    _xsd_Not_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Not",
      "http://qifstandards.org/xsd/qif2");


    void
    Not (::std::ostream& o,
         const ::xsd::qif2::NotType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Not (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Not (::std::ostream& o,
         const ::xsd::qif2::NotType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Not (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Not (::std::ostream& o,
         const ::xsd::qif2::NotType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Not (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Not (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::NotType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Not (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Not (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::NotType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Not (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Not (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::NotType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Not (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Not (::xercesc::DOMDocument& d,
         const ::xsd::qif2::NotType& s,
         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::NotType) == typeid (s))
      {
        if (n.name () == "Not" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Not",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Not",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Not (const ::xsd::qif2::NotType& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::NotType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Not",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Not",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Not (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConstantIsType >
    _xsd_ConstantIs_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ConstantIs",
      "http://qifstandards.org/xsd/qif2");


    void
    ConstantIs (::std::ostream& o,
                const ::xsd::qif2::ConstantIsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ConstantIs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ConstantIs (::std::ostream& o,
                const ::xsd::qif2::ConstantIsType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ConstantIs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ConstantIs (::std::ostream& o,
                const ::xsd::qif2::ConstantIsType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ConstantIs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ConstantIs (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::ConstantIsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ConstantIs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ConstantIs (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::ConstantIsType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ConstantIs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ConstantIs (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::ConstantIsType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ConstantIs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ConstantIs (::xercesc::DOMDocument& d,
                const ::xsd::qif2::ConstantIsType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::ConstantIsType) == typeid (s))
      {
        if (n.name () == "ConstantIs" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ConstantIs",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ConstantIs",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    ConstantIs (const ::xsd::qif2::ConstantIsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::ConstantIsType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ConstantIs",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ConstantIs",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::ConstantIs (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::AndType >
    _xsd_And_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "And",
      "http://qifstandards.org/xsd/qif2");


    void
    And (::std::ostream& o,
         const ::xsd::qif2::AndType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::And (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    And (::std::ostream& o,
         const ::xsd::qif2::AndType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::And (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    And (::std::ostream& o,
         const ::xsd::qif2::AndType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::And (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    And (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::AndType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::And (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    And (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::AndType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::And (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    And (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::AndType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::And (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    And (::xercesc::DOMDocument& d,
         const ::xsd::qif2::AndType& s,
         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::AndType) == typeid (s))
      {
        if (n.name () == "And" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "And",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "And",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    And (const ::xsd::qif2::AndType& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::AndType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "And",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "And",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::And (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OrType >
    _xsd_Or_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Or",
      "http://qifstandards.org/xsd/qif2");


    void
    Or (::std::ostream& o,
        const ::xsd::qif2::OrType& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Or (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Or (::std::ostream& o,
        const ::xsd::qif2::OrType& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Or (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Or (::std::ostream& o,
        const ::xsd::qif2::OrType& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Or (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Or (::xercesc::XMLFormatTarget& t,
        const ::xsd::qif2::OrType& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Or (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Or (::xercesc::XMLFormatTarget& t,
        const ::xsd::qif2::OrType& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Or (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Or (::xercesc::XMLFormatTarget& t,
        const ::xsd::qif2::OrType& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Or (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Or (::xercesc::DOMDocument& d,
        const ::xsd::qif2::OrType& s,
        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::OrType) == typeid (s))
      {
        if (n.name () == "Or" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Or",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Or",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Or (const ::xsd::qif2::OrType& s,
        const ::xml_schema::namespace_infomap& m,
        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::OrType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Or",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Or",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Or (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::BooleanEqualType >
    _xsd_BooleanEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "BooleanEqual",
      "http://qifstandards.org/xsd/qif2");


    void
    BooleanEqual (::std::ostream& o,
                  const ::xsd::qif2::BooleanEqualType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    BooleanEqual (::std::ostream& o,
                  const ::xsd::qif2::BooleanEqualType& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanEqual (::std::ostream& o,
                  const ::xsd::qif2::BooleanEqualType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanEqual (::xercesc::XMLFormatTarget& t,
                  const ::xsd::qif2::BooleanEqualType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    BooleanEqual (::xercesc::XMLFormatTarget& t,
                  const ::xsd::qif2::BooleanEqualType& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanEqual (::xercesc::XMLFormatTarget& t,
                  const ::xsd::qif2::BooleanEqualType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::BooleanEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    BooleanEqual (::xercesc::DOMDocument& d,
                  const ::xsd::qif2::BooleanEqualType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::BooleanEqualType) == typeid (s))
      {
        if (n.name () == "BooleanEqual" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "BooleanEqual",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "BooleanEqual",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    BooleanEqual (const ::xsd::qif2::BooleanEqualType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::BooleanEqualType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "BooleanEqual",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "BooleanEqual",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::BooleanEqual (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArithmeticEqualType >
    _xsd_ArithmeticEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticEqual",
      "http://qifstandards.org/xsd/qif2");


    void
    ArithmeticEqual (::std::ostream& o,
                     const ::xsd::qif2::ArithmeticEqualType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ArithmeticEqual (::std::ostream& o,
                     const ::xsd::qif2::ArithmeticEqualType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticEqual (::std::ostream& o,
                     const ::xsd::qif2::ArithmeticEqualType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticEqual (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::ArithmeticEqualType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ArithmeticEqual (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::ArithmeticEqualType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticEqual (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::ArithmeticEqualType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticEqual (::xercesc::DOMDocument& d,
                     const ::xsd::qif2::ArithmeticEqualType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::ArithmeticEqualType) == typeid (s))
      {
        if (n.name () == "ArithmeticEqual" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ArithmeticEqual",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ArithmeticEqual",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    ArithmeticEqual (const ::xsd::qif2::ArithmeticEqualType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::ArithmeticEqualType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ArithmeticEqual",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ArithmeticEqual",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::ArithmeticEqual (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GreaterThanType >
    _xsd_GreaterThan_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterThan",
      "http://qifstandards.org/xsd/qif2");


    void
    GreaterThan (::std::ostream& o,
                 const ::xsd::qif2::GreaterThanType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterThan (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    GreaterThan (::std::ostream& o,
                 const ::xsd::qif2::GreaterThanType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterThan (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterThan (::std::ostream& o,
                 const ::xsd::qif2::GreaterThanType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterThan (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterThan (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::GreaterThanType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterThan (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    GreaterThan (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::GreaterThanType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterThan (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterThan (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::GreaterThanType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterThan (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterThan (::xercesc::DOMDocument& d,
                 const ::xsd::qif2::GreaterThanType& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::GreaterThanType) == typeid (s))
      {
        if (n.name () == "GreaterThan" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "GreaterThan",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "GreaterThan",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    GreaterThan (const ::xsd::qif2::GreaterThanType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::GreaterThanType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "GreaterThan",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "GreaterThan",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::GreaterThan (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GreaterOrEqualType >
    _xsd_GreaterOrEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterOrEqual",
      "http://qifstandards.org/xsd/qif2");


    void
    GreaterOrEqual (::std::ostream& o,
                    const ::xsd::qif2::GreaterOrEqualType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterOrEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    GreaterOrEqual (::std::ostream& o,
                    const ::xsd::qif2::GreaterOrEqualType& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterOrEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterOrEqual (::std::ostream& o,
                    const ::xsd::qif2::GreaterOrEqualType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterOrEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterOrEqual (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::GreaterOrEqualType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterOrEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    GreaterOrEqual (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::GreaterOrEqualType& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterOrEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterOrEqual (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::GreaterOrEqualType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GreaterOrEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GreaterOrEqual (::xercesc::DOMDocument& d,
                    const ::xsd::qif2::GreaterOrEqualType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::GreaterOrEqualType) == typeid (s))
      {
        if (n.name () == "GreaterOrEqual" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "GreaterOrEqual",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "GreaterOrEqual",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    GreaterOrEqual (const ::xsd::qif2::GreaterOrEqualType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::GreaterOrEqualType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "GreaterOrEqual",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "GreaterOrEqual",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::GreaterOrEqual (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LessThanType >
    _xsd_LessThan_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessThan",
      "http://qifstandards.org/xsd/qif2");


    void
    LessThan (::std::ostream& o,
              const ::xsd::qif2::LessThanType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessThan (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LessThan (::std::ostream& o,
              const ::xsd::qif2::LessThanType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessThan (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessThan (::std::ostream& o,
              const ::xsd::qif2::LessThanType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessThan (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessThan (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LessThanType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessThan (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LessThan (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LessThanType& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessThan (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessThan (::xercesc::XMLFormatTarget& t,
              const ::xsd::qif2::LessThanType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessThan (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessThan (::xercesc::DOMDocument& d,
              const ::xsd::qif2::LessThanType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::LessThanType) == typeid (s))
      {
        if (n.name () == "LessThan" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "LessThan",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LessThan",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    LessThan (const ::xsd::qif2::LessThanType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::LessThanType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "LessThan",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LessThan",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::LessThan (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LessOrEqualType >
    _xsd_LessOrEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessOrEqual",
      "http://qifstandards.org/xsd/qif2");


    void
    LessOrEqual (::std::ostream& o,
                 const ::xsd::qif2::LessOrEqualType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessOrEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LessOrEqual (::std::ostream& o,
                 const ::xsd::qif2::LessOrEqualType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessOrEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessOrEqual (::std::ostream& o,
                 const ::xsd::qif2::LessOrEqualType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessOrEqual (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessOrEqual (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::LessOrEqualType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessOrEqual (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    LessOrEqual (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::LessOrEqualType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessOrEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessOrEqual (::xercesc::XMLFormatTarget& t,
                 const ::xsd::qif2::LessOrEqualType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::LessOrEqual (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    LessOrEqual (::xercesc::DOMDocument& d,
                 const ::xsd::qif2::LessOrEqualType& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::LessOrEqualType) == typeid (s))
      {
        if (n.name () == "LessOrEqual" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "LessOrEqual",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LessOrEqual",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    LessOrEqual (const ::xsd::qif2::LessOrEqualType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::LessOrEqualType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "LessOrEqual",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "LessOrEqual",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::LessOrEqual (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticExpressionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const ArithmeticExpressionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const ArithmeticExpressionBaseType&)
    {
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticExpressionBaseType >
    _xsd_ArithmeticExpressionBaseType_type_serializer_init (
      "ArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticConstantType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticExpressionBaseType& > (i);

      // val
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "val",
            e));

        a << ::xml_schema::as_decimal(i.val ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticConstantType >
    _xsd_ArithmeticConstantType_type_serializer_init (
      "ArithmeticConstantType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const NegateType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const NegateType::ArithmeticExpression_type& x (i.ArithmeticExpression ());
        if (typeid (NegateType::ArithmeticExpression_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ArithmeticExpression",
            "http://qifstandards.org/xsd/qif2",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NegateType >
    _xsd_NegateType_type_serializer_init (
      "NegateType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BinaryArithmeticExpressionBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (BinaryArithmeticExpressionBaseType::ArithmeticExpression_const_iterator
             b (i.ArithmeticExpression ().begin ()), n (i.ArithmeticExpression ().end ());
             b != n; ++b)
        {
          if (typeid (BinaryArithmeticExpressionBaseType::ArithmeticExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ArithmeticExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BinaryArithmeticExpressionBaseType >
    _xsd_BinaryArithmeticExpressionBaseType_type_serializer_init (
      "BinaryArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PlusType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PlusType >
    _xsd_PlusType_type_serializer_init (
      "PlusType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MinusType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MinusType >
    _xsd_MinusType_type_serializer_init (
      "MinusType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TimesType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimesType >
    _xsd_TimesType_type_serializer_init (
      "TimesType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DividedByType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DividedByType >
    _xsd_DividedByType_type_serializer_init (
      "DividedByType",
      "http://qifstandards.org/xsd/qif2");


    void
    ArithmeticExpression (::std::ostream& o,
                          const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticExpression (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ArithmeticExpression (::std::ostream& o,
                          const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticExpression (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticExpression (::std::ostream& o,
                          const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticExpression (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticExpression (::xercesc::XMLFormatTarget& t,
                          const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticExpression (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ArithmeticExpression (::xercesc::XMLFormatTarget& t,
                          const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticExpression (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticExpression (::xercesc::XMLFormatTarget& t,
                          const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticExpression (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticExpression (::xercesc::DOMDocument& d,
                          const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::ArithmeticExpressionBaseType) == typeid (s))
      {
        if (n.name () == "ArithmeticExpression" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ArithmeticExpression",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ArithmeticExpression",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    ArithmeticExpression (const ::xsd::qif2::ArithmeticExpressionBaseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::ArithmeticExpressionBaseType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ArithmeticExpression",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ArithmeticExpression",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::ArithmeticExpression (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArithmeticConstantType >
    _xsd_ArithmeticConstant_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticConstant",
      "http://qifstandards.org/xsd/qif2");


    void
    ArithmeticConstant (::std::ostream& o,
                        const ::xsd::qif2::ArithmeticConstantType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticConstant (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ArithmeticConstant (::std::ostream& o,
                        const ::xsd::qif2::ArithmeticConstantType& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticConstant (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticConstant (::std::ostream& o,
                        const ::xsd::qif2::ArithmeticConstantType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticConstant (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticConstant (::xercesc::XMLFormatTarget& t,
                        const ::xsd::qif2::ArithmeticConstantType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticConstant (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ArithmeticConstant (::xercesc::XMLFormatTarget& t,
                        const ::xsd::qif2::ArithmeticConstantType& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticConstant (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticConstant (::xercesc::XMLFormatTarget& t,
                        const ::xsd::qif2::ArithmeticConstantType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ArithmeticConstant (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ArithmeticConstant (::xercesc::DOMDocument& d,
                        const ::xsd::qif2::ArithmeticConstantType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::ArithmeticConstantType) == typeid (s))
      {
        if (n.name () == "ArithmeticConstant" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ArithmeticConstant",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ArithmeticConstant",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    ArithmeticConstant (const ::xsd::qif2::ArithmeticConstantType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::ArithmeticConstantType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ArithmeticConstant",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ArithmeticConstant",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::ArithmeticConstant (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PlusType >
    _xsd_Plus_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Plus",
      "http://qifstandards.org/xsd/qif2");


    void
    Plus (::std::ostream& o,
          const ::xsd::qif2::PlusType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Plus (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Plus (::std::ostream& o,
          const ::xsd::qif2::PlusType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Plus (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Plus (::std::ostream& o,
          const ::xsd::qif2::PlusType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Plus (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Plus (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::PlusType& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Plus (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Plus (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::PlusType& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Plus (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Plus (::xercesc::XMLFormatTarget& t,
          const ::xsd::qif2::PlusType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Plus (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Plus (::xercesc::DOMDocument& d,
          const ::xsd::qif2::PlusType& s,
          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::PlusType) == typeid (s))
      {
        if (n.name () == "Plus" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Plus",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Plus",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Plus (const ::xsd::qif2::PlusType& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::PlusType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Plus",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Plus",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Plus (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::MinusType >
    _xsd_Minus_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Minus",
      "http://qifstandards.org/xsd/qif2");


    void
    Minus (::std::ostream& o,
           const ::xsd::qif2::MinusType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Minus (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Minus (::std::ostream& o,
           const ::xsd::qif2::MinusType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Minus (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Minus (::std::ostream& o,
           const ::xsd::qif2::MinusType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Minus (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Minus (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::MinusType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Minus (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Minus (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::MinusType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Minus (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Minus (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::MinusType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Minus (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Minus (::xercesc::DOMDocument& d,
           const ::xsd::qif2::MinusType& s,
           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::MinusType) == typeid (s))
      {
        if (n.name () == "Minus" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Minus",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Minus",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Minus (const ::xsd::qif2::MinusType& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::MinusType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Minus",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Minus",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Minus (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::NegateType >
    _xsd_Negate_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Negate",
      "http://qifstandards.org/xsd/qif2");


    void
    Negate (::std::ostream& o,
            const ::xsd::qif2::NegateType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Negate (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Negate (::std::ostream& o,
            const ::xsd::qif2::NegateType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Negate (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Negate (::std::ostream& o,
            const ::xsd::qif2::NegateType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Negate (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Negate (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::NegateType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Negate (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Negate (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::NegateType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Negate (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Negate (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::NegateType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Negate (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Negate (::xercesc::DOMDocument& d,
            const ::xsd::qif2::NegateType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::NegateType) == typeid (s))
      {
        if (n.name () == "Negate" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Negate",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Negate",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Negate (const ::xsd::qif2::NegateType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::NegateType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Negate",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Negate",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Negate (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TimesType >
    _xsd_Times_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Times",
      "http://qifstandards.org/xsd/qif2");


    void
    Times (::std::ostream& o,
           const ::xsd::qif2::TimesType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Times (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Times (::std::ostream& o,
           const ::xsd::qif2::TimesType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Times (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Times (::std::ostream& o,
           const ::xsd::qif2::TimesType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Times (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Times (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::TimesType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Times (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Times (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::TimesType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Times (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Times (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::TimesType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Times (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Times (::xercesc::DOMDocument& d,
           const ::xsd::qif2::TimesType& s,
           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::TimesType) == typeid (s))
      {
        if (n.name () == "Times" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Times",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Times",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Times (const ::xsd::qif2::TimesType& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::TimesType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Times",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Times",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Times (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DividedByType >
    _xsd_DividedBy_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "DividedBy",
      "http://qifstandards.org/xsd/qif2");


    void
    DividedBy (::std::ostream& o,
               const ::xsd::qif2::DividedByType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DividedBy (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    DividedBy (::std::ostream& o,
               const ::xsd::qif2::DividedByType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DividedBy (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DividedBy (::std::ostream& o,
               const ::xsd::qif2::DividedByType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DividedBy (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DividedBy (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::DividedByType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DividedBy (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    DividedBy (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::DividedByType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DividedBy (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DividedBy (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::DividedByType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DividedBy (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DividedBy (::xercesc::DOMDocument& d,
               const ::xsd::qif2::DividedByType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::DividedByType) == typeid (s))
      {
        if (n.name () == "DividedBy" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "DividedBy",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "DividedBy",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    DividedBy (const ::xsd::qif2::DividedByType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::DividedByType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "DividedBy",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "DividedBy",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::DividedBy (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

