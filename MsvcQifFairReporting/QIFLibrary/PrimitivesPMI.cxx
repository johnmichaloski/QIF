// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "PrimitivesPMI.hxx"

namespace xsd
{
  namespace qif2
  {
    // RectangularUnitAreaType
    // 

    const RectangularUnitAreaType::RectangularUnitAreaLength_type& RectangularUnitAreaType::
    RectangularUnitAreaLength () const
    {
      return this->RectangularUnitAreaLength_.get ();
    }

    RectangularUnitAreaType::RectangularUnitAreaLength_type& RectangularUnitAreaType::
    RectangularUnitAreaLength ()
    {
      return this->RectangularUnitAreaLength_.get ();
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaLength (const RectangularUnitAreaLength_type& x)
    {
      this->RectangularUnitAreaLength_.set (x);
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaLength (::std::auto_ptr< RectangularUnitAreaLength_type > x)
    {
      this->RectangularUnitAreaLength_.set (x);
    }

    const RectangularUnitAreaType::RectangularUnitAreaWidth_type& RectangularUnitAreaType::
    RectangularUnitAreaWidth () const
    {
      return this->RectangularUnitAreaWidth_.get ();
    }

    RectangularUnitAreaType::RectangularUnitAreaWidth_type& RectangularUnitAreaType::
    RectangularUnitAreaWidth ()
    {
      return this->RectangularUnitAreaWidth_.get ();
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaWidth (const RectangularUnitAreaWidth_type& x)
    {
      this->RectangularUnitAreaWidth_.set (x);
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaWidth (::std::auto_ptr< RectangularUnitAreaWidth_type > x)
    {
      this->RectangularUnitAreaWidth_.set (x);
    }

    const RectangularUnitAreaType::RectangularUnitAreaOrientation_optional& RectangularUnitAreaType::
    RectangularUnitAreaOrientation () const
    {
      return this->RectangularUnitAreaOrientation_;
    }

    RectangularUnitAreaType::RectangularUnitAreaOrientation_optional& RectangularUnitAreaType::
    RectangularUnitAreaOrientation ()
    {
      return this->RectangularUnitAreaOrientation_;
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaOrientation (const RectangularUnitAreaOrientation_type& x)
    {
      this->RectangularUnitAreaOrientation_.set (x);
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaOrientation (const RectangularUnitAreaOrientation_optional& x)
    {
      this->RectangularUnitAreaOrientation_ = x;
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaOrientation (::std::auto_ptr< RectangularUnitAreaOrientation_type > x)
    {
      this->RectangularUnitAreaOrientation_.set (x);
    }


    // CircularUnitAreaType
    // 

    const CircularUnitAreaType::CircularUnitAreaDiameter_type& CircularUnitAreaType::
    CircularUnitAreaDiameter () const
    {
      return this->CircularUnitAreaDiameter_.get ();
    }

    CircularUnitAreaType::CircularUnitAreaDiameter_type& CircularUnitAreaType::
    CircularUnitAreaDiameter ()
    {
      return this->CircularUnitAreaDiameter_.get ();
    }

    void CircularUnitAreaType::
    CircularUnitAreaDiameter (const CircularUnitAreaDiameter_type& x)
    {
      this->CircularUnitAreaDiameter_.set (x);
    }

    void CircularUnitAreaType::
    CircularUnitAreaDiameter (::std::auto_ptr< CircularUnitAreaDiameter_type > x)
    {
      this->CircularUnitAreaDiameter_.set (x);
    }


    // ActualZoneAxisType
    // 

    const ActualZoneAxisType::Length_type& ActualZoneAxisType::
    Length () const
    {
      return this->Length_.get ();
    }

    ActualZoneAxisType::Length_type& ActualZoneAxisType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ActualZoneAxisType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ActualZoneAxisType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // BottomEnumType
    // 

    BottomEnumType::
    BottomEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_BottomEnumType_literals_[v])
    {
    }

    BottomEnumType::
    BottomEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BottomEnumType::
    BottomEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BottomEnumType::
    BottomEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BottomEnumType::
    BottomEnumType (const BottomEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    BottomEnumType& BottomEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_BottomEnumType_literals_[v]);

      return *this;
    }


    // BottomType
    // 

    const BottomType::BottomEnum_optional& BottomType::
    BottomEnum () const
    {
      return this->BottomEnum_;
    }

    BottomType::BottomEnum_optional& BottomType::
    BottomEnum ()
    {
      return this->BottomEnum_;
    }

    void BottomType::
    BottomEnum (const BottomEnum_type& x)
    {
      this->BottomEnum_.set (x);
    }

    void BottomType::
    BottomEnum (const BottomEnum_optional& x)
    {
      this->BottomEnum_ = x;
    }

    void BottomType::
    BottomEnum (::std::auto_ptr< BottomEnum_type > x)
    {
      this->BottomEnum_.set (x);
    }

    const BottomType::OtherBottom_optional& BottomType::
    OtherBottom () const
    {
      return this->OtherBottom_;
    }

    BottomType::OtherBottom_optional& BottomType::
    OtherBottom ()
    {
      return this->OtherBottom_;
    }

    void BottomType::
    OtherBottom (const OtherBottom_type& x)
    {
      this->OtherBottom_.set (x);
    }

    void BottomType::
    OtherBottom (const OtherBottom_optional& x)
    {
      this->OtherBottom_ = x;
    }

    void BottomType::
    OtherBottom (::std::auto_ptr< OtherBottom_type > x)
    {
      this->OtherBottom_.set (x);
    }


    // BoundingBoxType
    // 

    const BoundingBoxType::Length_type& BoundingBoxType::
    Length () const
    {
      return this->Length_.get ();
    }

    BoundingBoxType::Length_type& BoundingBoxType::
    Length ()
    {
      return this->Length_.get ();
    }

    void BoundingBoxType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void BoundingBoxType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const BoundingBoxType::Width_type& BoundingBoxType::
    Width () const
    {
      return this->Width_.get ();
    }

    BoundingBoxType::Width_type& BoundingBoxType::
    Width ()
    {
      return this->Width_.get ();
    }

    void BoundingBoxType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void BoundingBoxType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const BoundingBoxType::Height_type& BoundingBoxType::
    Height () const
    {
      return this->Height_.get ();
    }

    BoundingBoxType::Height_type& BoundingBoxType::
    Height ()
    {
      return this->Height_.get ();
    }

    void BoundingBoxType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }

    void BoundingBoxType::
    Height (::std::auto_ptr< Height_type > x)
    {
      this->Height_.set (x);
    }


    // ShapeClassEnumType
    // 

    ShapeClassEnumType::
    ShapeClassEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ShapeClassEnumType_literals_[v])
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ShapeClassEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ShapeClassEnumType& ShapeClassEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ShapeClassEnumType_literals_[v]);

      return *this;
    }


    // ShapeClassType
    // 

    const ShapeClassType::ShapeClassEnum_optional& ShapeClassType::
    ShapeClassEnum () const
    {
      return this->ShapeClassEnum_;
    }

    ShapeClassType::ShapeClassEnum_optional& ShapeClassType::
    ShapeClassEnum ()
    {
      return this->ShapeClassEnum_;
    }

    void ShapeClassType::
    ShapeClassEnum (const ShapeClassEnum_type& x)
    {
      this->ShapeClassEnum_.set (x);
    }

    void ShapeClassType::
    ShapeClassEnum (const ShapeClassEnum_optional& x)
    {
      this->ShapeClassEnum_ = x;
    }

    void ShapeClassType::
    ShapeClassEnum (::std::auto_ptr< ShapeClassEnum_type > x)
    {
      this->ShapeClassEnum_.set (x);
    }

    const ShapeClassType::OtherShapeClass_optional& ShapeClassType::
    OtherShapeClass () const
    {
      return this->OtherShapeClass_;
    }

    ShapeClassType::OtherShapeClass_optional& ShapeClassType::
    OtherShapeClass ()
    {
      return this->OtherShapeClass_;
    }

    void ShapeClassType::
    OtherShapeClass (const OtherShapeClass_type& x)
    {
      this->OtherShapeClass_.set (x);
    }

    void ShapeClassType::
    OtherShapeClass (const OtherShapeClass_optional& x)
    {
      this->OtherShapeClass_ = x;
    }

    void ShapeClassType::
    OtherShapeClass (::std::auto_ptr< OtherShapeClass_type > x)
    {
      this->OtherShapeClass_.set (x);
    }


    // ManufacturingMethodEnumType
    // 

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ManufacturingMethodEnumType_literals_[v])
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ManufacturingMethodEnumType& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ManufacturingMethodEnumType& ManufacturingMethodEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ManufacturingMethodEnumType_literals_[v]);

      return *this;
    }


    // ManufacturingMethodType
    // 

    const ManufacturingMethodType::ManufacturingMethodEnum_optional& ManufacturingMethodType::
    ManufacturingMethodEnum () const
    {
      return this->ManufacturingMethodEnum_;
    }

    ManufacturingMethodType::ManufacturingMethodEnum_optional& ManufacturingMethodType::
    ManufacturingMethodEnum ()
    {
      return this->ManufacturingMethodEnum_;
    }

    void ManufacturingMethodType::
    ManufacturingMethodEnum (const ManufacturingMethodEnum_type& x)
    {
      this->ManufacturingMethodEnum_.set (x);
    }

    void ManufacturingMethodType::
    ManufacturingMethodEnum (const ManufacturingMethodEnum_optional& x)
    {
      this->ManufacturingMethodEnum_ = x;
    }

    void ManufacturingMethodType::
    ManufacturingMethodEnum (::std::auto_ptr< ManufacturingMethodEnum_type > x)
    {
      this->ManufacturingMethodEnum_.set (x);
    }

    const ManufacturingMethodType::OtherManufacturingMethod_optional& ManufacturingMethodType::
    OtherManufacturingMethod () const
    {
      return this->OtherManufacturingMethod_;
    }

    ManufacturingMethodType::OtherManufacturingMethod_optional& ManufacturingMethodType::
    OtherManufacturingMethod ()
    {
      return this->OtherManufacturingMethod_;
    }

    void ManufacturingMethodType::
    OtherManufacturingMethod (const OtherManufacturingMethod_type& x)
    {
      this->OtherManufacturingMethod_.set (x);
    }

    void ManufacturingMethodType::
    OtherManufacturingMethod (const OtherManufacturingMethod_optional& x)
    {
      this->OtherManufacturingMethod_ = x;
    }

    void ManufacturingMethodType::
    OtherManufacturingMethod (::std::auto_ptr< OtherManufacturingMethod_type > x)
    {
      this->OtherManufacturingMethod_.set (x);
    }


    // InternalExternalEnumType
    // 

    InternalExternalEnumType::
    InternalExternalEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_InternalExternalEnumType_literals_[v])
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const InternalExternalEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    InternalExternalEnumType& InternalExternalEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_InternalExternalEnumType_literals_[v]);

      return *this;
    }


    // DimensionCountEnumType
    // 

    DimensionCountEnumType::
    DimensionCountEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DimensionCountEnumType_literals_[v])
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const DimensionCountEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DimensionCountEnumType& DimensionCountEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DimensionCountEnumType_literals_[v]);

      return *this;
    }


    // CoordinateEnumType
    // 

    CoordinateEnumType::
    CoordinateEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CoordinateEnumType_literals_[v])
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const CoordinateEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CoordinateEnumType& CoordinateEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CoordinateEnumType_literals_[v]);

      return *this;
    }


    // TypeOfCoordinatesType
    // 

    const TypeOfCoordinatesType::CoordinateEnum_optional& TypeOfCoordinatesType::
    CoordinateEnum () const
    {
      return this->CoordinateEnum_;
    }

    TypeOfCoordinatesType::CoordinateEnum_optional& TypeOfCoordinatesType::
    CoordinateEnum ()
    {
      return this->CoordinateEnum_;
    }

    void TypeOfCoordinatesType::
    CoordinateEnum (const CoordinateEnum_type& x)
    {
      this->CoordinateEnum_.set (x);
    }

    void TypeOfCoordinatesType::
    CoordinateEnum (const CoordinateEnum_optional& x)
    {
      this->CoordinateEnum_ = x;
    }

    void TypeOfCoordinatesType::
    CoordinateEnum (::std::auto_ptr< CoordinateEnum_type > x)
    {
      this->CoordinateEnum_.set (x);
    }

    const TypeOfCoordinatesType::OtherCoordinate_optional& TypeOfCoordinatesType::
    OtherCoordinate () const
    {
      return this->OtherCoordinate_;
    }

    TypeOfCoordinatesType::OtherCoordinate_optional& TypeOfCoordinatesType::
    OtherCoordinate ()
    {
      return this->OtherCoordinate_;
    }

    void TypeOfCoordinatesType::
    OtherCoordinate (const OtherCoordinate_type& x)
    {
      this->OtherCoordinate_.set (x);
    }

    void TypeOfCoordinatesType::
    OtherCoordinate (const OtherCoordinate_optional& x)
    {
      this->OtherCoordinate_ = x;
    }

    void TypeOfCoordinatesType::
    OtherCoordinate (::std::auto_ptr< OtherCoordinate_type > x)
    {
      this->OtherCoordinate_.set (x);
    }


    // RectangleType
    // 

    const RectangleType::Length_type& RectangleType::
    Length () const
    {
      return this->Length_.get ();
    }

    RectangleType::Length_type& RectangleType::
    Length ()
    {
      return this->Length_.get ();
    }

    void RectangleType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void RectangleType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const RectangleType::CornerPoint_type& RectangleType::
    CornerPoint () const
    {
      return this->CornerPoint_.get ();
    }

    RectangleType::CornerPoint_type& RectangleType::
    CornerPoint ()
    {
      return this->CornerPoint_.get ();
    }

    void RectangleType::
    CornerPoint (const CornerPoint_type& x)
    {
      this->CornerPoint_.set (x);
    }

    void RectangleType::
    CornerPoint (::std::auto_ptr< CornerPoint_type > x)
    {
      this->CornerPoint_.set (x);
    }

    const RectangleType::Width_type& RectangleType::
    Width () const
    {
      return this->Width_.get ();
    }

    RectangleType::Width_type& RectangleType::
    Width ()
    {
      return this->Width_.get ();
    }

    void RectangleType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void RectangleType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const RectangleType::WidthDirection_type& RectangleType::
    WidthDirection () const
    {
      return this->WidthDirection_.get ();
    }

    RectangleType::WidthDirection_type& RectangleType::
    WidthDirection ()
    {
      return this->WidthDirection_.get ();
    }

    void RectangleType::
    WidthDirection (const WidthDirection_type& x)
    {
      this->WidthDirection_.set (x);
    }

    void RectangleType::
    WidthDirection (::std::auto_ptr< WidthDirection_type > x)
    {
      this->WidthDirection_.set (x);
    }

    const RectangleType::LengthDirection_type& RectangleType::
    LengthDirection () const
    {
      return this->LengthDirection_.get ();
    }

    RectangleType::LengthDirection_type& RectangleType::
    LengthDirection ()
    {
      return this->LengthDirection_.get ();
    }

    void RectangleType::
    LengthDirection (const LengthDirection_type& x)
    {
      this->LengthDirection_.set (x);
    }

    void RectangleType::
    LengthDirection (::std::auto_ptr< LengthDirection_type > x)
    {
      this->LengthDirection_.set (x);
    }


    // CircleType
    // 

    const CircleType::CenterPoint_type& CircleType::
    CenterPoint () const
    {
      return this->CenterPoint_.get ();
    }

    CircleType::CenterPoint_type& CircleType::
    CenterPoint ()
    {
      return this->CenterPoint_.get ();
    }

    void CircleType::
    CenterPoint (const CenterPoint_type& x)
    {
      this->CenterPoint_.set (x);
    }

    void CircleType::
    CenterPoint (::std::auto_ptr< CenterPoint_type > x)
    {
      this->CenterPoint_.set (x);
    }

    const CircleType::Diameter_type& CircleType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CircleType::Diameter_type& CircleType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CircleType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CircleType::Normal_type& CircleType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    CircleType::Normal_type& CircleType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void CircleType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // CylinderType
    // 

    const CylinderType::CenterPoint_type& CylinderType::
    CenterPoint () const
    {
      return this->CenterPoint_.get ();
    }

    CylinderType::CenterPoint_type& CylinderType::
    CenterPoint ()
    {
      return this->CenterPoint_.get ();
    }

    void CylinderType::
    CenterPoint (const CenterPoint_type& x)
    {
      this->CenterPoint_.set (x);
    }

    void CylinderType::
    CenterPoint (::std::auto_ptr< CenterPoint_type > x)
    {
      this->CenterPoint_.set (x);
    }

    const CylinderType::Diameter_type& CylinderType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylinderType::Diameter_type& CylinderType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylinderType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylinderType::Axis_type& CylinderType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylinderType::Axis_type& CylinderType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylinderType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylinderType::Length_type& CylinderType::
    Length () const
    {
      return this->Length_.get ();
    }

    CylinderType::Length_type& CylinderType::
    Length ()
    {
      return this->Length_.get ();
    }

    void CylinderType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // SphereType
    // 

    const SphereType::CenterPoint_type& SphereType::
    CenterPoint () const
    {
      return this->CenterPoint_.get ();
    }

    SphereType::CenterPoint_type& SphereType::
    CenterPoint ()
    {
      return this->CenterPoint_.get ();
    }

    void SphereType::
    CenterPoint (const CenterPoint_type& x)
    {
      this->CenterPoint_.set (x);
    }

    void SphereType::
    CenterPoint (::std::auto_ptr< CenterPoint_type > x)
    {
      this->CenterPoint_.set (x);
    }

    const SphereType::Diameter_type& SphereType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphereType::Diameter_type& SphereType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphereType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }


    // PointAndVectorType
    // 

    const PointAndVectorType::StartPoint_type& PointAndVectorType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    PointAndVectorType::StartPoint_type& PointAndVectorType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void PointAndVectorType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void PointAndVectorType::
    StartPoint (::std::auto_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (x);
    }

    const PointAndVectorType::Vector_type& PointAndVectorType::
    Vector () const
    {
      return this->Vector_.get ();
    }

    PointAndVectorType::Vector_type& PointAndVectorType::
    Vector ()
    {
      return this->Vector_.get ();
    }

    void PointAndVectorType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointAndVectorType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }


    // ActualPointAndVectorType
    // 

    const ActualPointAndVectorType::StartPoint_type& ActualPointAndVectorType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    ActualPointAndVectorType::StartPoint_type& ActualPointAndVectorType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void ActualPointAndVectorType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void ActualPointAndVectorType::
    StartPoint (::std::auto_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (x);
    }

    const ActualPointAndVectorType::Vector_type& ActualPointAndVectorType::
    Vector () const
    {
      return this->Vector_.get ();
    }

    ActualPointAndVectorType::Vector_type& ActualPointAndVectorType::
    Vector ()
    {
      return this->Vector_.get ();
    }

    void ActualPointAndVectorType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void ActualPointAndVectorType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }


    // SlotEndEnumType
    // 

    SlotEndEnumType::
    SlotEndEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SlotEndEnumType_literals_[v])
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const SlotEndEnumType& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SlotEndEnumType& SlotEndEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SlotEndEnumType_literals_[v]);

      return *this;
    }


    // EndRadiusType
    // 

    const EndRadiusType::EndRadius_type& EndRadiusType::
    EndRadius () const
    {
      return this->EndRadius_.get ();
    }

    EndRadiusType::EndRadius_type& EndRadiusType::
    EndRadius ()
    {
      return this->EndRadius_.get ();
    }

    void EndRadiusType::
    EndRadius (const EndRadius_type& x)
    {
      this->EndRadius_.set (x);
    }

    void EndRadiusType::
    EndRadius (::std::auto_ptr< EndRadius_type > x)
    {
      this->EndRadius_.set (x);
    }

    const EndRadiusType::Expanded_optional& EndRadiusType::
    Expanded () const
    {
      return this->Expanded_;
    }

    EndRadiusType::Expanded_optional& EndRadiusType::
    Expanded ()
    {
      return this->Expanded_;
    }

    void EndRadiusType::
    Expanded (const Expanded_type& x)
    {
      this->Expanded_.set (x);
    }

    void EndRadiusType::
    Expanded (const Expanded_optional& x)
    {
      this->Expanded_ = x;
    }


    // ActualEndRadiusType
    // 

    const ActualEndRadiusType::EndRadius_type& ActualEndRadiusType::
    EndRadius () const
    {
      return this->EndRadius_.get ();
    }

    ActualEndRadiusType::EndRadius_type& ActualEndRadiusType::
    EndRadius ()
    {
      return this->EndRadius_.get ();
    }

    void ActualEndRadiusType::
    EndRadius (const EndRadius_type& x)
    {
      this->EndRadius_.set (x);
    }

    void ActualEndRadiusType::
    EndRadius (::std::auto_ptr< EndRadius_type > x)
    {
      this->EndRadius_.set (x);
    }

    const ActualEndRadiusType::Expanded_optional& ActualEndRadiusType::
    Expanded () const
    {
      return this->Expanded_;
    }

    ActualEndRadiusType::Expanded_optional& ActualEndRadiusType::
    Expanded ()
    {
      return this->Expanded_;
    }

    void ActualEndRadiusType::
    Expanded (const Expanded_type& x)
    {
      this->Expanded_.set (x);
    }

    void ActualEndRadiusType::
    Expanded (const Expanded_optional& x)
    {
      this->Expanded_ = x;
    }


    // SlotEndType
    // 

    const SlotEndType::SlotEndEnum_optional& SlotEndType::
    SlotEndEnum () const
    {
      return this->SlotEndEnum_;
    }

    SlotEndType::SlotEndEnum_optional& SlotEndType::
    SlotEndEnum ()
    {
      return this->SlotEndEnum_;
    }

    void SlotEndType::
    SlotEndEnum (const SlotEndEnum_type& x)
    {
      this->SlotEndEnum_.set (x);
    }

    void SlotEndType::
    SlotEndEnum (const SlotEndEnum_optional& x)
    {
      this->SlotEndEnum_ = x;
    }

    void SlotEndType::
    SlotEndEnum (::std::auto_ptr< SlotEndEnum_type > x)
    {
      this->SlotEndEnum_.set (x);
    }

    const SlotEndType::OtherSlotEnd_optional& SlotEndType::
    OtherSlotEnd () const
    {
      return this->OtherSlotEnd_;
    }

    SlotEndType::OtherSlotEnd_optional& SlotEndType::
    OtherSlotEnd ()
    {
      return this->OtherSlotEnd_;
    }

    void SlotEndType::
    OtherSlotEnd (const OtherSlotEnd_type& x)
    {
      this->OtherSlotEnd_.set (x);
    }

    void SlotEndType::
    OtherSlotEnd (const OtherSlotEnd_optional& x)
    {
      this->OtherSlotEnd_ = x;
    }

    void SlotEndType::
    OtherSlotEnd (::std::auto_ptr< OtherSlotEnd_type > x)
    {
      this->OtherSlotEnd_.set (x);
    }


    // ThreadSeriesEnumType
    // 

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ThreadSeriesEnumType_literals_[v])
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ThreadSeriesEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ThreadSeriesEnumType& ThreadSeriesEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ThreadSeriesEnumType_literals_[v]);

      return *this;
    }


    // ThreadSeriesType
    // 

    const ThreadSeriesType::ThreadSeriesEnum_optional& ThreadSeriesType::
    ThreadSeriesEnum () const
    {
      return this->ThreadSeriesEnum_;
    }

    ThreadSeriesType::ThreadSeriesEnum_optional& ThreadSeriesType::
    ThreadSeriesEnum ()
    {
      return this->ThreadSeriesEnum_;
    }

    void ThreadSeriesType::
    ThreadSeriesEnum (const ThreadSeriesEnum_type& x)
    {
      this->ThreadSeriesEnum_.set (x);
    }

    void ThreadSeriesType::
    ThreadSeriesEnum (const ThreadSeriesEnum_optional& x)
    {
      this->ThreadSeriesEnum_ = x;
    }

    void ThreadSeriesType::
    ThreadSeriesEnum (::std::auto_ptr< ThreadSeriesEnum_type > x)
    {
      this->ThreadSeriesEnum_.set (x);
    }

    const ThreadSeriesType::OtherThreadSeries_optional& ThreadSeriesType::
    OtherThreadSeries () const
    {
      return this->OtherThreadSeries_;
    }

    ThreadSeriesType::OtherThreadSeries_optional& ThreadSeriesType::
    OtherThreadSeries ()
    {
      return this->OtherThreadSeries_;
    }

    void ThreadSeriesType::
    OtherThreadSeries (const OtherThreadSeries_type& x)
    {
      this->OtherThreadSeries_.set (x);
    }

    void ThreadSeriesType::
    OtherThreadSeries (const OtherThreadSeries_optional& x)
    {
      this->OtherThreadSeries_ = x;
    }

    void ThreadSeriesType::
    OtherThreadSeries (::std::auto_ptr< OtherThreadSeries_type > x)
    {
      this->OtherThreadSeries_.set (x);
    }


    // ThreadClassType
    // 

    const ThreadClassType::ThreadClassEnum_optional& ThreadClassType::
    ThreadClassEnum () const
    {
      return this->ThreadClassEnum_;
    }

    ThreadClassType::ThreadClassEnum_optional& ThreadClassType::
    ThreadClassEnum ()
    {
      return this->ThreadClassEnum_;
    }

    void ThreadClassType::
    ThreadClassEnum (const ThreadClassEnum_type& x)
    {
      this->ThreadClassEnum_.set (x);
    }

    void ThreadClassType::
    ThreadClassEnum (const ThreadClassEnum_optional& x)
    {
      this->ThreadClassEnum_ = x;
    }

    void ThreadClassType::
    ThreadClassEnum (::std::auto_ptr< ThreadClassEnum_type > x)
    {
      this->ThreadClassEnum_.set (x);
    }

    const ThreadClassType::OtherThreadClass_optional& ThreadClassType::
    OtherThreadClass () const
    {
      return this->OtherThreadClass_;
    }

    ThreadClassType::OtherThreadClass_optional& ThreadClassType::
    OtherThreadClass ()
    {
      return this->OtherThreadClass_;
    }

    void ThreadClassType::
    OtherThreadClass (const OtherThreadClass_type& x)
    {
      this->OtherThreadClass_.set (x);
    }

    void ThreadClassType::
    OtherThreadClass (const OtherThreadClass_optional& x)
    {
      this->OtherThreadClass_ = x;
    }

    void ThreadClassType::
    OtherThreadClass (::std::auto_ptr< OtherThreadClass_type > x)
    {
      this->OtherThreadClass_.set (x);
    }


    // ThreadClassEnumType
    // 

    ThreadClassEnumType::
    ThreadClassEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ThreadClassEnumType_literals_[v])
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ThreadClassEnumType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ThreadClassEnumType& ThreadClassEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ThreadClassEnumType_literals_[v]);

      return *this;
    }


    // SecurityClassificationEnumType
    // 

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SecurityClassificationEnumType_literals_[v])
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const SecurityClassificationEnumType& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SecurityClassificationEnumType& SecurityClassificationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SecurityClassificationEnumType_literals_[v]);

      return *this;
    }


    // SecurityClassificationType
    // 

    const SecurityClassificationType::SecurityClassificationEnum_optional& SecurityClassificationType::
    SecurityClassificationEnum () const
    {
      return this->SecurityClassificationEnum_;
    }

    SecurityClassificationType::SecurityClassificationEnum_optional& SecurityClassificationType::
    SecurityClassificationEnum ()
    {
      return this->SecurityClassificationEnum_;
    }

    void SecurityClassificationType::
    SecurityClassificationEnum (const SecurityClassificationEnum_type& x)
    {
      this->SecurityClassificationEnum_.set (x);
    }

    void SecurityClassificationType::
    SecurityClassificationEnum (const SecurityClassificationEnum_optional& x)
    {
      this->SecurityClassificationEnum_ = x;
    }

    void SecurityClassificationType::
    SecurityClassificationEnum (::std::auto_ptr< SecurityClassificationEnum_type > x)
    {
      this->SecurityClassificationEnum_.set (x);
    }

    const SecurityClassificationType::OtherSecurityClassification_optional& SecurityClassificationType::
    OtherSecurityClassification () const
    {
      return this->OtherSecurityClassification_;
    }

    SecurityClassificationType::OtherSecurityClassification_optional& SecurityClassificationType::
    OtherSecurityClassification ()
    {
      return this->OtherSecurityClassification_;
    }

    void SecurityClassificationType::
    OtherSecurityClassification (const OtherSecurityClassification_type& x)
    {
      this->OtherSecurityClassification_.set (x);
    }

    void SecurityClassificationType::
    OtherSecurityClassification (const OtherSecurityClassification_optional& x)
    {
      this->OtherSecurityClassification_ = x;
    }

    void SecurityClassificationType::
    OtherSecurityClassification (::std::auto_ptr< OtherSecurityClassification_type > x)
    {
      this->OtherSecurityClassification_.set (x);
    }


    // DigitalModelFormatEnumType
    // 

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DigitalModelFormatEnumType_literals_[v])
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const DigitalModelFormatEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DigitalModelFormatEnumType& DigitalModelFormatEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DigitalModelFormatEnumType_literals_[v]);

      return *this;
    }


    // DigitalModelFormatType
    // 

    const DigitalModelFormatType::DigitalModelFormatEnum_optional& DigitalModelFormatType::
    DigitalModelFormatEnum () const
    {
      return this->DigitalModelFormatEnum_;
    }

    DigitalModelFormatType::DigitalModelFormatEnum_optional& DigitalModelFormatType::
    DigitalModelFormatEnum ()
    {
      return this->DigitalModelFormatEnum_;
    }

    void DigitalModelFormatType::
    DigitalModelFormatEnum (const DigitalModelFormatEnum_type& x)
    {
      this->DigitalModelFormatEnum_.set (x);
    }

    void DigitalModelFormatType::
    DigitalModelFormatEnum (const DigitalModelFormatEnum_optional& x)
    {
      this->DigitalModelFormatEnum_ = x;
    }

    void DigitalModelFormatType::
    DigitalModelFormatEnum (::std::auto_ptr< DigitalModelFormatEnum_type > x)
    {
      this->DigitalModelFormatEnum_.set (x);
    }

    const DigitalModelFormatType::OtherDigitalModelFormat_optional& DigitalModelFormatType::
    OtherDigitalModelFormat () const
    {
      return this->OtherDigitalModelFormat_;
    }

    DigitalModelFormatType::OtherDigitalModelFormat_optional& DigitalModelFormatType::
    OtherDigitalModelFormat ()
    {
      return this->OtherDigitalModelFormat_;
    }

    void DigitalModelFormatType::
    OtherDigitalModelFormat (const OtherDigitalModelFormat_type& x)
    {
      this->OtherDigitalModelFormat_.set (x);
    }

    void DigitalModelFormatType::
    OtherDigitalModelFormat (const OtherDigitalModelFormat_optional& x)
    {
      this->OtherDigitalModelFormat_ = x;
    }

    void DigitalModelFormatType::
    OtherDigitalModelFormat (::std::auto_ptr< OtherDigitalModelFormat_type > x)
    {
      this->OtherDigitalModelFormat_.set (x);
    }


    // UniformScaleType
    // 

    const UniformScaleType::ScaleFactor_type& UniformScaleType::
    ScaleFactor () const
    {
      return this->ScaleFactor_.get ();
    }

    UniformScaleType::ScaleFactor_type& UniformScaleType::
    ScaleFactor ()
    {
      return this->ScaleFactor_.get ();
    }

    void UniformScaleType::
    ScaleFactor (const ScaleFactor_type& x)
    {
      this->ScaleFactor_.set (x);
    }


    // RadialDifferentialScaleType
    // 

    const RadialDifferentialScaleType::PerpendicularScaleFactor_type& RadialDifferentialScaleType::
    PerpendicularScaleFactor () const
    {
      return this->PerpendicularScaleFactor_.get ();
    }

    RadialDifferentialScaleType::PerpendicularScaleFactor_type& RadialDifferentialScaleType::
    PerpendicularScaleFactor ()
    {
      return this->PerpendicularScaleFactor_.get ();
    }

    void RadialDifferentialScaleType::
    PerpendicularScaleFactor (const PerpendicularScaleFactor_type& x)
    {
      this->PerpendicularScaleFactor_.set (x);
    }

    const RadialDifferentialScaleType::ParallelScaleFactor_type& RadialDifferentialScaleType::
    ParallelScaleFactor () const
    {
      return this->ParallelScaleFactor_.get ();
    }

    RadialDifferentialScaleType::ParallelScaleFactor_type& RadialDifferentialScaleType::
    ParallelScaleFactor ()
    {
      return this->ParallelScaleFactor_.get ();
    }

    void RadialDifferentialScaleType::
    ParallelScaleFactor (const ParallelScaleFactor_type& x)
    {
      this->ParallelScaleFactor_.set (x);
    }

    const RadialDifferentialScaleType::Direction_type& RadialDifferentialScaleType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    RadialDifferentialScaleType::Direction_type& RadialDifferentialScaleType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void RadialDifferentialScaleType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void RadialDifferentialScaleType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }


    // AxialDifferentialScaleType
    // 

    const AxialDifferentialScaleType::XScaleFactor_type& AxialDifferentialScaleType::
    XScaleFactor () const
    {
      return this->XScaleFactor_.get ();
    }

    AxialDifferentialScaleType::XScaleFactor_type& AxialDifferentialScaleType::
    XScaleFactor ()
    {
      return this->XScaleFactor_.get ();
    }

    void AxialDifferentialScaleType::
    XScaleFactor (const XScaleFactor_type& x)
    {
      this->XScaleFactor_.set (x);
    }

    const AxialDifferentialScaleType::XaxisDirection_type& AxialDifferentialScaleType::
    XaxisDirection () const
    {
      return this->XaxisDirection_.get ();
    }

    AxialDifferentialScaleType::XaxisDirection_type& AxialDifferentialScaleType::
    XaxisDirection ()
    {
      return this->XaxisDirection_.get ();
    }

    void AxialDifferentialScaleType::
    XaxisDirection (const XaxisDirection_type& x)
    {
      this->XaxisDirection_.set (x);
    }

    void AxialDifferentialScaleType::
    XaxisDirection (::std::auto_ptr< XaxisDirection_type > x)
    {
      this->XaxisDirection_.set (x);
    }

    const AxialDifferentialScaleType::YScaleFactor_type& AxialDifferentialScaleType::
    YScaleFactor () const
    {
      return this->YScaleFactor_.get ();
    }

    AxialDifferentialScaleType::YScaleFactor_type& AxialDifferentialScaleType::
    YScaleFactor ()
    {
      return this->YScaleFactor_.get ();
    }

    void AxialDifferentialScaleType::
    YScaleFactor (const YScaleFactor_type& x)
    {
      this->YScaleFactor_.set (x);
    }

    const AxialDifferentialScaleType::YaxisDirection_type& AxialDifferentialScaleType::
    YaxisDirection () const
    {
      return this->YaxisDirection_.get ();
    }

    AxialDifferentialScaleType::YaxisDirection_type& AxialDifferentialScaleType::
    YaxisDirection ()
    {
      return this->YaxisDirection_.get ();
    }

    void AxialDifferentialScaleType::
    YaxisDirection (const YaxisDirection_type& x)
    {
      this->YaxisDirection_.set (x);
    }

    void AxialDifferentialScaleType::
    YaxisDirection (::std::auto_ptr< YaxisDirection_type > x)
    {
      this->YaxisDirection_.set (x);
    }

    const AxialDifferentialScaleType::ZScaleFactor_type& AxialDifferentialScaleType::
    ZScaleFactor () const
    {
      return this->ZScaleFactor_.get ();
    }

    AxialDifferentialScaleType::ZScaleFactor_type& AxialDifferentialScaleType::
    ZScaleFactor ()
    {
      return this->ZScaleFactor_.get ();
    }

    void AxialDifferentialScaleType::
    ZScaleFactor (const ZScaleFactor_type& x)
    {
      this->ZScaleFactor_.set (x);
    }

    const AxialDifferentialScaleType::ZaxisDirection_type& AxialDifferentialScaleType::
    ZaxisDirection () const
    {
      return this->ZaxisDirection_.get ();
    }

    AxialDifferentialScaleType::ZaxisDirection_type& AxialDifferentialScaleType::
    ZaxisDirection ()
    {
      return this->ZaxisDirection_.get ();
    }

    void AxialDifferentialScaleType::
    ZaxisDirection (const ZaxisDirection_type& x)
    {
      this->ZaxisDirection_.set (x);
    }

    void AxialDifferentialScaleType::
    ZaxisDirection (::std::auto_ptr< ZaxisDirection_type > x)
    {
      this->ZaxisDirection_.set (x);
    }


    // ScaleType
    // 

    const ScaleType::Origin_type& ScaleType::
    Origin () const
    {
      return this->Origin_.get ();
    }

    ScaleType::Origin_type& ScaleType::
    Origin ()
    {
      return this->Origin_.get ();
    }

    void ScaleType::
    Origin (const Origin_type& x)
    {
      this->Origin_.set (x);
    }

    void ScaleType::
    Origin (::std::auto_ptr< Origin_type > x)
    {
      this->Origin_.set (x);
    }

    const ScaleType::UniformScale_optional& ScaleType::
    UniformScale () const
    {
      return this->UniformScale_;
    }

    ScaleType::UniformScale_optional& ScaleType::
    UniformScale ()
    {
      return this->UniformScale_;
    }

    void ScaleType::
    UniformScale (const UniformScale_type& x)
    {
      this->UniformScale_.set (x);
    }

    void ScaleType::
    UniformScale (const UniformScale_optional& x)
    {
      this->UniformScale_ = x;
    }

    void ScaleType::
    UniformScale (::std::auto_ptr< UniformScale_type > x)
    {
      this->UniformScale_.set (x);
    }

    const ScaleType::RadialDifferentialScale_optional& ScaleType::
    RadialDifferentialScale () const
    {
      return this->RadialDifferentialScale_;
    }

    ScaleType::RadialDifferentialScale_optional& ScaleType::
    RadialDifferentialScale ()
    {
      return this->RadialDifferentialScale_;
    }

    void ScaleType::
    RadialDifferentialScale (const RadialDifferentialScale_type& x)
    {
      this->RadialDifferentialScale_.set (x);
    }

    void ScaleType::
    RadialDifferentialScale (const RadialDifferentialScale_optional& x)
    {
      this->RadialDifferentialScale_ = x;
    }

    void ScaleType::
    RadialDifferentialScale (::std::auto_ptr< RadialDifferentialScale_type > x)
    {
      this->RadialDifferentialScale_.set (x);
    }

    const ScaleType::AxialDifferentialScale_optional& ScaleType::
    AxialDifferentialScale () const
    {
      return this->AxialDifferentialScale_;
    }

    ScaleType::AxialDifferentialScale_optional& ScaleType::
    AxialDifferentialScale ()
    {
      return this->AxialDifferentialScale_;
    }

    void ScaleType::
    AxialDifferentialScale (const AxialDifferentialScale_type& x)
    {
      this->AxialDifferentialScale_.set (x);
    }

    void ScaleType::
    AxialDifferentialScale (const AxialDifferentialScale_optional& x)
    {
      this->AxialDifferentialScale_ = x;
    }

    void ScaleType::
    AxialDifferentialScale (::std::auto_ptr< AxialDifferentialScale_type > x)
    {
      this->AxialDifferentialScale_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // RectangularUnitAreaType
    //

    RectangularUnitAreaType::
    RectangularUnitAreaType (const RectangularUnitAreaLength_type& RectangularUnitAreaLength,
                             const RectangularUnitAreaWidth_type& RectangularUnitAreaWidth)
    : ::xml_schema::type (),
      RectangularUnitAreaLength_ (RectangularUnitAreaLength, this),
      RectangularUnitAreaWidth_ (RectangularUnitAreaWidth, this),
      RectangularUnitAreaOrientation_ (this)
    {
    }

    RectangularUnitAreaType::
    RectangularUnitAreaType (::std::auto_ptr< RectangularUnitAreaLength_type > RectangularUnitAreaLength,
                             ::std::auto_ptr< RectangularUnitAreaWidth_type > RectangularUnitAreaWidth)
    : ::xml_schema::type (),
      RectangularUnitAreaLength_ (RectangularUnitAreaLength, this),
      RectangularUnitAreaWidth_ (RectangularUnitAreaWidth, this),
      RectangularUnitAreaOrientation_ (this)
    {
    }

    RectangularUnitAreaType::
    RectangularUnitAreaType (const RectangularUnitAreaType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      RectangularUnitAreaLength_ (x.RectangularUnitAreaLength_, f, this),
      RectangularUnitAreaWidth_ (x.RectangularUnitAreaWidth_, f, this),
      RectangularUnitAreaOrientation_ (x.RectangularUnitAreaOrientation_, f, this)
    {
    }

    RectangularUnitAreaType::
    RectangularUnitAreaType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      RectangularUnitAreaLength_ (this),
      RectangularUnitAreaWidth_ (this),
      RectangularUnitAreaOrientation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RectangularUnitAreaType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // RectangularUnitAreaLength
        //
        if (n.name () == "RectangularUnitAreaLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RectangularUnitAreaLength_type > r (
            RectangularUnitAreaLength_traits::create (i, f, this));

          if (!RectangularUnitAreaLength_.present ())
          {
            this->RectangularUnitAreaLength_.set (r);
            continue;
          }
        }

        // RectangularUnitAreaWidth
        //
        if (n.name () == "RectangularUnitAreaWidth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RectangularUnitAreaWidth_type > r (
            RectangularUnitAreaWidth_traits::create (i, f, this));

          if (!RectangularUnitAreaWidth_.present ())
          {
            this->RectangularUnitAreaWidth_.set (r);
            continue;
          }
        }

        // RectangularUnitAreaOrientation
        //
        if (n.name () == "RectangularUnitAreaOrientation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RectangularUnitAreaOrientation_type > r (
            RectangularUnitAreaOrientation_traits::create (i, f, this));

          if (!this->RectangularUnitAreaOrientation_)
          {
            this->RectangularUnitAreaOrientation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!RectangularUnitAreaLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RectangularUnitAreaLength",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RectangularUnitAreaWidth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RectangularUnitAreaWidth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    RectangularUnitAreaType* RectangularUnitAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RectangularUnitAreaType (*this, f, c);
    }

    RectangularUnitAreaType& RectangularUnitAreaType::
    operator= (const RectangularUnitAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->RectangularUnitAreaLength_ = x.RectangularUnitAreaLength_;
        this->RectangularUnitAreaWidth_ = x.RectangularUnitAreaWidth_;
        this->RectangularUnitAreaOrientation_ = x.RectangularUnitAreaOrientation_;
      }

      return *this;
    }

    RectangularUnitAreaType::
    ~RectangularUnitAreaType ()
    {
    }

    // CircularUnitAreaType
    //

    CircularUnitAreaType::
    CircularUnitAreaType (const CircularUnitAreaDiameter_type& CircularUnitAreaDiameter)
    : ::xml_schema::type (),
      CircularUnitAreaDiameter_ (CircularUnitAreaDiameter, this)
    {
    }

    CircularUnitAreaType::
    CircularUnitAreaType (::std::auto_ptr< CircularUnitAreaDiameter_type > CircularUnitAreaDiameter)
    : ::xml_schema::type (),
      CircularUnitAreaDiameter_ (CircularUnitAreaDiameter, this)
    {
    }

    CircularUnitAreaType::
    CircularUnitAreaType (const CircularUnitAreaType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CircularUnitAreaDiameter_ (x.CircularUnitAreaDiameter_, f, this)
    {
    }

    CircularUnitAreaType::
    CircularUnitAreaType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CircularUnitAreaDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularUnitAreaType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CircularUnitAreaDiameter
        //
        if (n.name () == "CircularUnitAreaDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CircularUnitAreaDiameter_type > r (
            CircularUnitAreaDiameter_traits::create (i, f, this));

          if (!CircularUnitAreaDiameter_.present ())
          {
            this->CircularUnitAreaDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CircularUnitAreaDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CircularUnitAreaDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircularUnitAreaType* CircularUnitAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularUnitAreaType (*this, f, c);
    }

    CircularUnitAreaType& CircularUnitAreaType::
    operator= (const CircularUnitAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CircularUnitAreaDiameter_ = x.CircularUnitAreaDiameter_;
      }

      return *this;
    }

    CircularUnitAreaType::
    ~CircularUnitAreaType ()
    {
    }

    // ActualZoneAxisType
    //

    ActualZoneAxisType::
    ActualZoneAxisType (const AxisPoint_type& AxisPoint,
                        const Direction_type& Direction,
                        const Length_type& Length)
    : ::xsd::qif2::AxisType (AxisPoint,
                             Direction),
      Length_ (Length, this)
    {
    }

    ActualZoneAxisType::
    ActualZoneAxisType (::std::auto_ptr< AxisPoint_type > AxisPoint,
                        ::std::auto_ptr< Direction_type > Direction,
                        ::std::auto_ptr< Length_type > Length)
    : ::xsd::qif2::AxisType (AxisPoint,
                             Direction),
      Length_ (Length, this)
    {
    }

    ActualZoneAxisType::
    ActualZoneAxisType (const ActualZoneAxisType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::AxisType (x, f, c),
      Length_ (x.Length_, f, this)
    {
    }

    ActualZoneAxisType::
    ActualZoneAxisType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::AxisType (e, f | ::xml_schema::flags::base, c),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActualZoneAxisType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AxisType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ActualZoneAxisType* ActualZoneAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualZoneAxisType (*this, f, c);
    }

    ActualZoneAxisType& ActualZoneAxisType::
    operator= (const ActualZoneAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AxisType& > (*this) = x;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    ActualZoneAxisType::
    ~ActualZoneAxisType ()
    {
    }

    // BottomEnumType
    //

    BottomEnumType::
    BottomEnumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_BottomEnumType_convert ();
    }

    BottomEnumType::
    BottomEnumType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_BottomEnumType_convert ();
    }

    BottomEnumType::
    BottomEnumType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_BottomEnumType_convert ();
    }

    BottomEnumType* BottomEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BottomEnumType (*this, f, c);
    }

    BottomEnumType::value BottomEnumType::
    _xsd_BottomEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BottomEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_BottomEnumType_indexes_,
                        _xsd_BottomEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_BottomEnumType_indexes_ + 3 || _xsd_BottomEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const BottomEnumType::
    _xsd_BottomEnumType_literals_[3] =
    {
      "BLIND",
      "THROUGH",
      "UNDEFINED"
    };

    const BottomEnumType::value BottomEnumType::
    _xsd_BottomEnumType_indexes_[3] =
    {
      ::xsd::qif2::BottomEnumType::BLIND,
      ::xsd::qif2::BottomEnumType::THROUGH,
      ::xsd::qif2::BottomEnumType::UNDEFINED
    };

    // BottomType
    //

    BottomType::
    BottomType ()
    : ::xml_schema::type (),
      BottomEnum_ (this),
      OtherBottom_ (this)
    {
    }

    BottomType::
    BottomType (const BottomType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BottomEnum_ (x.BottomEnum_, f, this),
      OtherBottom_ (x.OtherBottom_, f, this)
    {
    }

    BottomType::
    BottomType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BottomEnum_ (this),
      OtherBottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BottomType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BottomEnum
        //
        if (n.name () == "BottomEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BottomEnum_type > r (
            BottomEnum_traits::create (i, f, this));

          if (!this->BottomEnum_)
          {
            this->BottomEnum_.set (r);
            continue;
          }
        }

        // OtherBottom
        //
        if (n.name () == "OtherBottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherBottom_type > r (
            OtherBottom_traits::create (i, f, this));

          if (!this->OtherBottom_)
          {
            this->OtherBottom_.set (r);
            continue;
          }
        }

        break;
      }
    }

    BottomType* BottomType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BottomType (*this, f, c);
    }

    BottomType& BottomType::
    operator= (const BottomType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BottomEnum_ = x.BottomEnum_;
        this->OtherBottom_ = x.OtherBottom_;
      }

      return *this;
    }

    BottomType::
    ~BottomType ()
    {
    }

    // BoundingBoxType
    //

    BoundingBoxType::
    BoundingBoxType (const Length_type& Length,
                     const Width_type& Width,
                     const Height_type& Height)
    : ::xml_schema::type (),
      Length_ (Length, this),
      Width_ (Width, this),
      Height_ (Height, this)
    {
    }

    BoundingBoxType::
    BoundingBoxType (::std::auto_ptr< Length_type > Length,
                     ::std::auto_ptr< Width_type > Width,
                     ::std::auto_ptr< Height_type > Height)
    : ::xml_schema::type (),
      Length_ (Length, this),
      Width_ (Width, this),
      Height_ (Height, this)
    {
    }

    BoundingBoxType::
    BoundingBoxType (const BoundingBoxType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Length_ (x.Length_, f, this),
      Width_ (x.Width_, f, this),
      Height_ (x.Height_, f, this)
    {
    }

    BoundingBoxType::
    BoundingBoxType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Length_ (this),
      Width_ (this),
      Height_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BoundingBoxType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Height
        //
        if (n.name () == "Height" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Height_type > r (
            Height_traits::create (i, f, this));

          if (!Height_.present ())
          {
            this->Height_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Height_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Height",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    BoundingBoxType* BoundingBoxType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BoundingBoxType (*this, f, c);
    }

    BoundingBoxType& BoundingBoxType::
    operator= (const BoundingBoxType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Length_ = x.Length_;
        this->Width_ = x.Width_;
        this->Height_ = x.Height_;
      }

      return *this;
    }

    BoundingBoxType::
    ~BoundingBoxType ()
    {
    }

    // ShapeClassEnumType
    //

    ShapeClassEnumType::
    ShapeClassEnumType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ShapeClassEnumType_convert ();
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ShapeClassEnumType_convert ();
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ShapeClassEnumType_convert ();
    }

    ShapeClassEnumType* ShapeClassEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShapeClassEnumType (*this, f, c);
    }

    ShapeClassEnumType::value ShapeClassEnumType::
    _xsd_ShapeClassEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ShapeClassEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ShapeClassEnumType_indexes_,
                        _xsd_ShapeClassEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ShapeClassEnumType_indexes_ + 5 || _xsd_ShapeClassEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ShapeClassEnumType::
    _xsd_ShapeClassEnumType_literals_[5] =
    {
      "GEAR",
      "FREEFORM",
      "PRISMATIC",
      "ROTATIONAL",
      "THINWALLED"
    };

    const ShapeClassEnumType::value ShapeClassEnumType::
    _xsd_ShapeClassEnumType_indexes_[5] =
    {
      ::xsd::qif2::ShapeClassEnumType::FREEFORM,
      ::xsd::qif2::ShapeClassEnumType::GEAR,
      ::xsd::qif2::ShapeClassEnumType::PRISMATIC,
      ::xsd::qif2::ShapeClassEnumType::ROTATIONAL,
      ::xsd::qif2::ShapeClassEnumType::THINWALLED
    };

    // ShapeClassType
    //

    ShapeClassType::
    ShapeClassType ()
    : ::xml_schema::type (),
      ShapeClassEnum_ (this),
      OtherShapeClass_ (this)
    {
    }

    ShapeClassType::
    ShapeClassType (const ShapeClassType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ShapeClassEnum_ (x.ShapeClassEnum_, f, this),
      OtherShapeClass_ (x.OtherShapeClass_, f, this)
    {
    }

    ShapeClassType::
    ShapeClassType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ShapeClassEnum_ (this),
      OtherShapeClass_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ShapeClassType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ShapeClassEnum
        //
        if (n.name () == "ShapeClassEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ShapeClassEnum_type > r (
            ShapeClassEnum_traits::create (i, f, this));

          if (!this->ShapeClassEnum_)
          {
            this->ShapeClassEnum_.set (r);
            continue;
          }
        }

        // OtherShapeClass
        //
        if (n.name () == "OtherShapeClass" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherShapeClass_type > r (
            OtherShapeClass_traits::create (i, f, this));

          if (!this->OtherShapeClass_)
          {
            this->OtherShapeClass_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ShapeClassType* ShapeClassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShapeClassType (*this, f, c);
    }

    ShapeClassType& ShapeClassType::
    operator= (const ShapeClassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ShapeClassEnum_ = x.ShapeClassEnum_;
        this->OtherShapeClass_ = x.OtherShapeClass_;
      }

      return *this;
    }

    ShapeClassType::
    ~ShapeClassType ()
    {
    }

    // ManufacturingMethodEnumType
    //

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ManufacturingMethodEnumType_convert ();
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ManufacturingMethodEnumType_convert ();
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ManufacturingMethodEnumType_convert ();
    }

    ManufacturingMethodEnumType* ManufacturingMethodEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManufacturingMethodEnumType (*this, f, c);
    }

    ManufacturingMethodEnumType::value ManufacturingMethodEnumType::
    _xsd_ManufacturingMethodEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ManufacturingMethodEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ManufacturingMethodEnumType_indexes_,
                        _xsd_ManufacturingMethodEnumType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_ManufacturingMethodEnumType_indexes_ + 8 || _xsd_ManufacturingMethodEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ManufacturingMethodEnumType::
    _xsd_ManufacturingMethodEnumType_literals_[8] =
    {
      "ADDITIVE",
      "CASTING",
      "COMPOSITE",
      "FABRICATION",
      "FORMING",
      "JOINING",
      "MACHINING",
      "MOLDING"
    };

    const ManufacturingMethodEnumType::value ManufacturingMethodEnumType::
    _xsd_ManufacturingMethodEnumType_indexes_[8] =
    {
      ::xsd::qif2::ManufacturingMethodEnumType::ADDITIVE,
      ::xsd::qif2::ManufacturingMethodEnumType::CASTING,
      ::xsd::qif2::ManufacturingMethodEnumType::COMPOSITE,
      ::xsd::qif2::ManufacturingMethodEnumType::FABRICATION,
      ::xsd::qif2::ManufacturingMethodEnumType::FORMING,
      ::xsd::qif2::ManufacturingMethodEnumType::JOINING,
      ::xsd::qif2::ManufacturingMethodEnumType::MACHINING,
      ::xsd::qif2::ManufacturingMethodEnumType::MOLDING
    };

    // ManufacturingMethodType
    //

    ManufacturingMethodType::
    ManufacturingMethodType ()
    : ::xml_schema::type (),
      ManufacturingMethodEnum_ (this),
      OtherManufacturingMethod_ (this)
    {
    }

    ManufacturingMethodType::
    ManufacturingMethodType (const ManufacturingMethodType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ManufacturingMethodEnum_ (x.ManufacturingMethodEnum_, f, this),
      OtherManufacturingMethod_ (x.OtherManufacturingMethod_, f, this)
    {
    }

    ManufacturingMethodType::
    ManufacturingMethodType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ManufacturingMethodEnum_ (this),
      OtherManufacturingMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ManufacturingMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ManufacturingMethodEnum
        //
        if (n.name () == "ManufacturingMethodEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ManufacturingMethodEnum_type > r (
            ManufacturingMethodEnum_traits::create (i, f, this));

          if (!this->ManufacturingMethodEnum_)
          {
            this->ManufacturingMethodEnum_.set (r);
            continue;
          }
        }

        // OtherManufacturingMethod
        //
        if (n.name () == "OtherManufacturingMethod" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherManufacturingMethod_type > r (
            OtherManufacturingMethod_traits::create (i, f, this));

          if (!this->OtherManufacturingMethod_)
          {
            this->OtherManufacturingMethod_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ManufacturingMethodType* ManufacturingMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManufacturingMethodType (*this, f, c);
    }

    ManufacturingMethodType& ManufacturingMethodType::
    operator= (const ManufacturingMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ManufacturingMethodEnum_ = x.ManufacturingMethodEnum_;
        this->OtherManufacturingMethod_ = x.OtherManufacturingMethod_;
      }

      return *this;
    }

    ManufacturingMethodType::
    ~ManufacturingMethodType ()
    {
    }

    // InternalExternalEnumType
    //

    InternalExternalEnumType::
    InternalExternalEnumType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_InternalExternalEnumType_convert ();
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_InternalExternalEnumType_convert ();
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_InternalExternalEnumType_convert ();
    }

    InternalExternalEnumType* InternalExternalEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InternalExternalEnumType (*this, f, c);
    }

    InternalExternalEnumType::value InternalExternalEnumType::
    _xsd_InternalExternalEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InternalExternalEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_InternalExternalEnumType_indexes_,
                        _xsd_InternalExternalEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_InternalExternalEnumType_indexes_ + 3 || _xsd_InternalExternalEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const InternalExternalEnumType::
    _xsd_InternalExternalEnumType_literals_[3] =
    {
      "INTERNAL",
      "EXTERNAL",
      "NOT_APPLICABLE"
    };

    const InternalExternalEnumType::value InternalExternalEnumType::
    _xsd_InternalExternalEnumType_indexes_[3] =
    {
      ::xsd::qif2::InternalExternalEnumType::EXTERNAL,
      ::xsd::qif2::InternalExternalEnumType::INTERNAL,
      ::xsd::qif2::InternalExternalEnumType::NOT_APPLICABLE
    };

    // DimensionCountEnumType
    //

    DimensionCountEnumType::
    DimensionCountEnumType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DimensionCountEnumType_convert ();
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DimensionCountEnumType_convert ();
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DimensionCountEnumType_convert ();
    }

    DimensionCountEnumType* DimensionCountEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DimensionCountEnumType (*this, f, c);
    }

    DimensionCountEnumType::value DimensionCountEnumType::
    _xsd_DimensionCountEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DimensionCountEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DimensionCountEnumType_indexes_,
                        _xsd_DimensionCountEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_DimensionCountEnumType_indexes_ + 2 || _xsd_DimensionCountEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const DimensionCountEnumType::
    _xsd_DimensionCountEnumType_literals_[2] =
    {
      "TWODIMENSIONAL",
      "THREEDIMENSIONAL"
    };

    const DimensionCountEnumType::value DimensionCountEnumType::
    _xsd_DimensionCountEnumType_indexes_[2] =
    {
      ::xsd::qif2::DimensionCountEnumType::THREEDIMENSIONAL,
      ::xsd::qif2::DimensionCountEnumType::TWODIMENSIONAL
    };

    // CoordinateEnumType
    //

    CoordinateEnumType::
    CoordinateEnumType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CoordinateEnumType_convert ();
    }

    CoordinateEnumType::
    CoordinateEnumType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CoordinateEnumType_convert ();
    }

    CoordinateEnumType::
    CoordinateEnumType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CoordinateEnumType_convert ();
    }

    CoordinateEnumType* CoordinateEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateEnumType (*this, f, c);
    }

    CoordinateEnumType::value CoordinateEnumType::
    _xsd_CoordinateEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CoordinateEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CoordinateEnumType_indexes_,
                        _xsd_CoordinateEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_CoordinateEnumType_indexes_ + 6 || _xsd_CoordinateEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CoordinateEnumType::
    _xsd_CoordinateEnumType_literals_[6] =
    {
      "CARTESIAN_2D",
      "POLAR_2D",
      "CARTESIAN_3D",
      "CYLINDRICAL_3D",
      "SPHERICAL_3D",
      "UNDEFINED"
    };

    const CoordinateEnumType::value CoordinateEnumType::
    _xsd_CoordinateEnumType_indexes_[6] =
    {
      ::xsd::qif2::CoordinateEnumType::CARTESIAN_2D,
      ::xsd::qif2::CoordinateEnumType::CARTESIAN_3D,
      ::xsd::qif2::CoordinateEnumType::CYLINDRICAL_3D,
      ::xsd::qif2::CoordinateEnumType::POLAR_2D,
      ::xsd::qif2::CoordinateEnumType::SPHERICAL_3D,
      ::xsd::qif2::CoordinateEnumType::UNDEFINED
    };

    // TypeOfCoordinatesType
    //

    TypeOfCoordinatesType::
    TypeOfCoordinatesType ()
    : ::xml_schema::type (),
      CoordinateEnum_ (this),
      OtherCoordinate_ (this)
    {
    }

    TypeOfCoordinatesType::
    TypeOfCoordinatesType (const TypeOfCoordinatesType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoordinateEnum_ (x.CoordinateEnum_, f, this),
      OtherCoordinate_ (x.OtherCoordinate_, f, this)
    {
    }

    TypeOfCoordinatesType::
    TypeOfCoordinatesType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoordinateEnum_ (this),
      OtherCoordinate_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TypeOfCoordinatesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoordinateEnum
        //
        if (n.name () == "CoordinateEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateEnum_type > r (
            CoordinateEnum_traits::create (i, f, this));

          if (!this->CoordinateEnum_)
          {
            this->CoordinateEnum_.set (r);
            continue;
          }
        }

        // OtherCoordinate
        //
        if (n.name () == "OtherCoordinate" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherCoordinate_type > r (
            OtherCoordinate_traits::create (i, f, this));

          if (!this->OtherCoordinate_)
          {
            this->OtherCoordinate_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TypeOfCoordinatesType* TypeOfCoordinatesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TypeOfCoordinatesType (*this, f, c);
    }

    TypeOfCoordinatesType& TypeOfCoordinatesType::
    operator= (const TypeOfCoordinatesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoordinateEnum_ = x.CoordinateEnum_;
        this->OtherCoordinate_ = x.OtherCoordinate_;
      }

      return *this;
    }

    TypeOfCoordinatesType::
    ~TypeOfCoordinatesType ()
    {
    }

    // RectangleType
    //

    RectangleType::
    RectangleType (const Length_type& Length,
                   const CornerPoint_type& CornerPoint,
                   const Width_type& Width,
                   const WidthDirection_type& WidthDirection,
                   const LengthDirection_type& LengthDirection)
    : ::xml_schema::type (),
      Length_ (Length, this),
      CornerPoint_ (CornerPoint, this),
      Width_ (Width, this),
      WidthDirection_ (WidthDirection, this),
      LengthDirection_ (LengthDirection, this)
    {
    }

    RectangleType::
    RectangleType (::std::auto_ptr< Length_type > Length,
                   ::std::auto_ptr< CornerPoint_type > CornerPoint,
                   ::std::auto_ptr< Width_type > Width,
                   ::std::auto_ptr< WidthDirection_type > WidthDirection,
                   ::std::auto_ptr< LengthDirection_type > LengthDirection)
    : ::xml_schema::type (),
      Length_ (Length, this),
      CornerPoint_ (CornerPoint, this),
      Width_ (Width, this),
      WidthDirection_ (WidthDirection, this),
      LengthDirection_ (LengthDirection, this)
    {
    }

    RectangleType::
    RectangleType (const RectangleType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Length_ (x.Length_, f, this),
      CornerPoint_ (x.CornerPoint_, f, this),
      Width_ (x.Width_, f, this),
      WidthDirection_ (x.WidthDirection_, f, this),
      LengthDirection_ (x.LengthDirection_, f, this)
    {
    }

    RectangleType::
    RectangleType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Length_ (this),
      CornerPoint_ (this),
      Width_ (this),
      WidthDirection_ (this),
      LengthDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RectangleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        // CornerPoint
        //
        if (n.name () == "CornerPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CornerPoint_type > r (
            CornerPoint_traits::create (i, f, this));

          if (!CornerPoint_.present ())
          {
            this->CornerPoint_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthDirection
        //
        if (n.name () == "WidthDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthDirection_type > r (
            WidthDirection_traits::create (i, f, this));

          if (!WidthDirection_.present ())
          {
            this->WidthDirection_.set (r);
            continue;
          }
        }

        // LengthDirection
        //
        if (n.name () == "LengthDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthDirection_type > r (
            LengthDirection_traits::create (i, f, this));

          if (!LengthDirection_.present ())
          {
            this->LengthDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CornerPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CornerPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!WidthDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "WidthDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LengthDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LengthDirection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    RectangleType* RectangleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RectangleType (*this, f, c);
    }

    RectangleType& RectangleType::
    operator= (const RectangleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Length_ = x.Length_;
        this->CornerPoint_ = x.CornerPoint_;
        this->Width_ = x.Width_;
        this->WidthDirection_ = x.WidthDirection_;
        this->LengthDirection_ = x.LengthDirection_;
      }

      return *this;
    }

    RectangleType::
    ~RectangleType ()
    {
    }

    // CircleType
    //

    CircleType::
    CircleType (const CenterPoint_type& CenterPoint,
                const Diameter_type& Diameter,
                const Normal_type& Normal)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this),
      Normal_ (Normal, this)
    {
    }

    CircleType::
    CircleType (::std::auto_ptr< CenterPoint_type > CenterPoint,
                ::std::auto_ptr< Diameter_type > Diameter,
                ::std::auto_ptr< Normal_type > Normal)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this),
      Normal_ (Normal, this)
    {
    }

    CircleType::
    CircleType (const CircleType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CenterPoint_ (x.CenterPoint_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    CircleType::
    CircleType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CenterPoint_ (this),
      Diameter_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPoint
        //
        if (n.name () == "CenterPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPoint_type > r (
            CenterPoint_traits::create (i, f, this));

          if (!CenterPoint_.present ())
          {
            this->CenterPoint_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleType* CircleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleType (*this, f, c);
    }

    CircleType& CircleType::
    operator= (const CircleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CenterPoint_ = x.CenterPoint_;
        this->Diameter_ = x.Diameter_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    CircleType::
    ~CircleType ()
    {
    }

    // CylinderType
    //

    CylinderType::
    CylinderType (const CenterPoint_type& CenterPoint,
                  const Diameter_type& Diameter,
                  const Axis_type& Axis,
                  const Length_type& Length)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this),
      Axis_ (Axis, this),
      Length_ (Length, this)
    {
    }

    CylinderType::
    CylinderType (::std::auto_ptr< CenterPoint_type > CenterPoint,
                  ::std::auto_ptr< Diameter_type > Diameter,
                  ::std::auto_ptr< Axis_type > Axis,
                  ::std::auto_ptr< Length_type > Length)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this),
      Axis_ (Axis, this),
      Length_ (Length, this)
    {
    }

    CylinderType::
    CylinderType (const CylinderType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CenterPoint_ (x.CenterPoint_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Axis_ (x.Axis_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    CylinderType::
    CylinderType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CenterPoint_ (this),
      Diameter_ (this),
      Axis_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPoint
        //
        if (n.name () == "CenterPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPoint_type > r (
            CenterPoint_traits::create (i, f, this));

          if (!CenterPoint_.present ())
          {
            this->CenterPoint_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderType* CylinderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderType (*this, f, c);
    }

    CylinderType& CylinderType::
    operator= (const CylinderType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CenterPoint_ = x.CenterPoint_;
        this->Diameter_ = x.Diameter_;
        this->Axis_ = x.Axis_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    CylinderType::
    ~CylinderType ()
    {
    }

    // SphereType
    //

    SphereType::
    SphereType (const CenterPoint_type& CenterPoint,
                const Diameter_type& Diameter)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this)
    {
    }

    SphereType::
    SphereType (::std::auto_ptr< CenterPoint_type > CenterPoint,
                ::std::auto_ptr< Diameter_type > Diameter)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this)
    {
    }

    SphereType::
    SphereType (const SphereType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CenterPoint_ (x.CenterPoint_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphereType::
    SphereType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CenterPoint_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPoint
        //
        if (n.name () == "CenterPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPoint_type > r (
            CenterPoint_traits::create (i, f, this));

          if (!CenterPoint_.present ())
          {
            this->CenterPoint_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereType* SphereType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereType (*this, f, c);
    }

    SphereType& SphereType::
    operator= (const SphereType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CenterPoint_ = x.CenterPoint_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    SphereType::
    ~SphereType ()
    {
    }

    // PointAndVectorType
    //

    PointAndVectorType::
    PointAndVectorType (const StartPoint_type& StartPoint,
                        const Vector_type& Vector)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      Vector_ (Vector, this)
    {
    }

    PointAndVectorType::
    PointAndVectorType (::std::auto_ptr< StartPoint_type > StartPoint,
                        ::std::auto_ptr< Vector_type > Vector)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      Vector_ (Vector, this)
    {
    }

    PointAndVectorType::
    PointAndVectorType (const PointAndVectorType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    PointAndVectorType::
    PointAndVectorType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointAndVectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // StartPoint
        //
        if (n.name () == "StartPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!Vector_.present ())
          {
            this->Vector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "StartPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Vector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Vector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointAndVectorType* PointAndVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointAndVectorType (*this, f, c);
    }

    PointAndVectorType& PointAndVectorType::
    operator= (const PointAndVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    PointAndVectorType::
    ~PointAndVectorType ()
    {
    }

    // ActualPointAndVectorType
    //

    ActualPointAndVectorType::
    ActualPointAndVectorType (const StartPoint_type& StartPoint,
                              const Vector_type& Vector)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      Vector_ (Vector, this)
    {
    }

    ActualPointAndVectorType::
    ActualPointAndVectorType (::std::auto_ptr< StartPoint_type > StartPoint,
                              ::std::auto_ptr< Vector_type > Vector)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      Vector_ (Vector, this)
    {
    }

    ActualPointAndVectorType::
    ActualPointAndVectorType (const ActualPointAndVectorType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    ActualPointAndVectorType::
    ActualPointAndVectorType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActualPointAndVectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // StartPoint
        //
        if (n.name () == "StartPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!Vector_.present ())
          {
            this->Vector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "StartPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Vector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Vector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ActualPointAndVectorType* ActualPointAndVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualPointAndVectorType (*this, f, c);
    }

    ActualPointAndVectorType& ActualPointAndVectorType::
    operator= (const ActualPointAndVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    ActualPointAndVectorType::
    ~ActualPointAndVectorType ()
    {
    }

    // SlotEndEnumType
    //

    SlotEndEnumType::
    SlotEndEnumType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SlotEndEnumType_convert ();
    }

    SlotEndEnumType::
    SlotEndEnumType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SlotEndEnumType_convert ();
    }

    SlotEndEnumType::
    SlotEndEnumType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SlotEndEnumType_convert ();
    }

    SlotEndEnumType* SlotEndEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SlotEndEnumType (*this, f, c);
    }

    SlotEndEnumType::value SlotEndEnumType::
    _xsd_SlotEndEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SlotEndEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SlotEndEnumType_indexes_,
                        _xsd_SlotEndEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_SlotEndEnumType_indexes_ + 4 || _xsd_SlotEndEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const SlotEndEnumType::
    _xsd_SlotEndEnumType_literals_[4] =
    {
      "ROUND",
      "FLAT",
      "OPEN",
      "UNDEFINED"
    };

    const SlotEndEnumType::value SlotEndEnumType::
    _xsd_SlotEndEnumType_indexes_[4] =
    {
      ::xsd::qif2::SlotEndEnumType::FLAT,
      ::xsd::qif2::SlotEndEnumType::OPEN,
      ::xsd::qif2::SlotEndEnumType::ROUND,
      ::xsd::qif2::SlotEndEnumType::UNDEFINED
    };

    // EndRadiusType
    //

    EndRadiusType::
    EndRadiusType (const EndRadius_type& EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (EndRadius, this),
      Expanded_ (this)
    {
    }

    EndRadiusType::
    EndRadiusType (::std::auto_ptr< EndRadius_type > EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (EndRadius, this),
      Expanded_ (this)
    {
    }

    EndRadiusType::
    EndRadiusType (const EndRadiusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EndRadius_ (x.EndRadius_, f, this),
      Expanded_ (x.Expanded_, f, this)
    {
    }

    EndRadiusType::
    EndRadiusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EndRadius_ (this),
      Expanded_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EndRadiusType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndRadius
        //
        if (n.name () == "EndRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius_type > r (
            EndRadius_traits::create (i, f, this));

          if (!EndRadius_.present ())
          {
            this->EndRadius_.set (r);
            continue;
          }
        }

        // Expanded
        //
        if (n.name () == "Expanded" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->Expanded_)
          {
            this->Expanded_.set (Expanded_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EndRadiusType* EndRadiusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EndRadiusType (*this, f, c);
    }

    EndRadiusType& EndRadiusType::
    operator= (const EndRadiusType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EndRadius_ = x.EndRadius_;
        this->Expanded_ = x.Expanded_;
      }

      return *this;
    }

    EndRadiusType::
    ~EndRadiusType ()
    {
    }

    // ActualEndRadiusType
    //

    ActualEndRadiusType::
    ActualEndRadiusType (const EndRadius_type& EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (EndRadius, this),
      Expanded_ (this)
    {
    }

    ActualEndRadiusType::
    ActualEndRadiusType (::std::auto_ptr< EndRadius_type > EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (EndRadius, this),
      Expanded_ (this)
    {
    }

    ActualEndRadiusType::
    ActualEndRadiusType (const ActualEndRadiusType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EndRadius_ (x.EndRadius_, f, this),
      Expanded_ (x.Expanded_, f, this)
    {
    }

    ActualEndRadiusType::
    ActualEndRadiusType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EndRadius_ (this),
      Expanded_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActualEndRadiusType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndRadius
        //
        if (n.name () == "EndRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius_type > r (
            EndRadius_traits::create (i, f, this));

          if (!EndRadius_.present ())
          {
            this->EndRadius_.set (r);
            continue;
          }
        }

        // Expanded
        //
        if (n.name () == "Expanded" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->Expanded_)
          {
            this->Expanded_.set (Expanded_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ActualEndRadiusType* ActualEndRadiusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualEndRadiusType (*this, f, c);
    }

    ActualEndRadiusType& ActualEndRadiusType::
    operator= (const ActualEndRadiusType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EndRadius_ = x.EndRadius_;
        this->Expanded_ = x.Expanded_;
      }

      return *this;
    }

    ActualEndRadiusType::
    ~ActualEndRadiusType ()
    {
    }

    // SlotEndType
    //

    SlotEndType::
    SlotEndType ()
    : ::xml_schema::type (),
      SlotEndEnum_ (this),
      OtherSlotEnd_ (this)
    {
    }

    SlotEndType::
    SlotEndType (const SlotEndType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SlotEndEnum_ (x.SlotEndEnum_, f, this),
      OtherSlotEnd_ (x.OtherSlotEnd_, f, this)
    {
    }

    SlotEndType::
    SlotEndType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SlotEndEnum_ (this),
      OtherSlotEnd_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SlotEndType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SlotEndEnum
        //
        if (n.name () == "SlotEndEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SlotEndEnum_type > r (
            SlotEndEnum_traits::create (i, f, this));

          if (!this->SlotEndEnum_)
          {
            this->SlotEndEnum_.set (r);
            continue;
          }
        }

        // OtherSlotEnd
        //
        if (n.name () == "OtherSlotEnd" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherSlotEnd_type > r (
            OtherSlotEnd_traits::create (i, f, this));

          if (!this->OtherSlotEnd_)
          {
            this->OtherSlotEnd_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SlotEndType* SlotEndType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SlotEndType (*this, f, c);
    }

    SlotEndType& SlotEndType::
    operator= (const SlotEndType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SlotEndEnum_ = x.SlotEndEnum_;
        this->OtherSlotEnd_ = x.OtherSlotEnd_;
      }

      return *this;
    }

    SlotEndType::
    ~SlotEndType ()
    {
    }

    // ThreadSeriesEnumType
    //

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ThreadSeriesEnumType_convert ();
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ThreadSeriesEnumType_convert ();
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ThreadSeriesEnumType_convert ();
    }

    ThreadSeriesEnumType* ThreadSeriesEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSeriesEnumType (*this, f, c);
    }

    ThreadSeriesEnumType::value ThreadSeriesEnumType::
    _xsd_ThreadSeriesEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ThreadSeriesEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ThreadSeriesEnumType_indexes_,
                        _xsd_ThreadSeriesEnumType_indexes_ + 56,
                        *this,
                        c));

      if (i == _xsd_ThreadSeriesEnumType_indexes_ + 56 || _xsd_ThreadSeriesEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ThreadSeriesEnumType::
    _xsd_ThreadSeriesEnumType_literals_[56] =
    {
      "ACME",
      "ACME_C",
      "ACME_G",
      "AMO",
      "ANPT",
      "BUTT",
      "PUSH_BUTT",
      "F_PTF",
      "M",
      "MJ",
      "MJS",
      "NC5_HF",
      "NC5_CSF",
      "NC5_ONF",
      "NC5_IF",
      "NC5_INF",
      "NGO",
      "NGS",
      "NGT",
      "NH",
      "NHR",
      "NPSC",
      "NPSF",
      "NPSH",
      "NPSI",
      "NPSL",
      "NPSM",
      "NPT",
      "NPTF",
      "PTF_SAE_SHORT",
      "PTF_SPL_SHORT",
      "PTF_SPL_EXTRA_SHORT",
      "SGT",
      "SPL_PTF",
      "STUB_ACME",
      "UN",
      "UNC",
      "UNF",
      "UNEF",
      "UNJ",
      "UNJC",
      "UNJF",
      "UNJEF",
      "UNR",
      "UNRC",
      "UNRF",
      "UNREF",
      "UNM",
      "UNS",
      "G",
      "R",
      "RC",
      "RP",
      "S",
      "TR",
      "UNDEFINED"
    };

    const ThreadSeriesEnumType::value ThreadSeriesEnumType::
    _xsd_ThreadSeriesEnumType_indexes_[56] =
    {
      ::xsd::qif2::ThreadSeriesEnumType::ACME,
      ::xsd::qif2::ThreadSeriesEnumType::ACME_C,
      ::xsd::qif2::ThreadSeriesEnumType::ACME_G,
      ::xsd::qif2::ThreadSeriesEnumType::AMO,
      ::xsd::qif2::ThreadSeriesEnumType::ANPT,
      ::xsd::qif2::ThreadSeriesEnumType::BUTT,
      ::xsd::qif2::ThreadSeriesEnumType::F_PTF,
      ::xsd::qif2::ThreadSeriesEnumType::G,
      ::xsd::qif2::ThreadSeriesEnumType::M,
      ::xsd::qif2::ThreadSeriesEnumType::MJ,
      ::xsd::qif2::ThreadSeriesEnumType::MJS,
      ::xsd::qif2::ThreadSeriesEnumType::NC5_CSF,
      ::xsd::qif2::ThreadSeriesEnumType::NC5_HF,
      ::xsd::qif2::ThreadSeriesEnumType::NC5_IF,
      ::xsd::qif2::ThreadSeriesEnumType::NC5_INF,
      ::xsd::qif2::ThreadSeriesEnumType::NC5_ONF,
      ::xsd::qif2::ThreadSeriesEnumType::NGO,
      ::xsd::qif2::ThreadSeriesEnumType::NGS,
      ::xsd::qif2::ThreadSeriesEnumType::NGT,
      ::xsd::qif2::ThreadSeriesEnumType::NH,
      ::xsd::qif2::ThreadSeriesEnumType::NHR,
      ::xsd::qif2::ThreadSeriesEnumType::NPSC,
      ::xsd::qif2::ThreadSeriesEnumType::NPSF,
      ::xsd::qif2::ThreadSeriesEnumType::NPSH,
      ::xsd::qif2::ThreadSeriesEnumType::NPSI,
      ::xsd::qif2::ThreadSeriesEnumType::NPSL,
      ::xsd::qif2::ThreadSeriesEnumType::NPSM,
      ::xsd::qif2::ThreadSeriesEnumType::NPT,
      ::xsd::qif2::ThreadSeriesEnumType::NPTF,
      ::xsd::qif2::ThreadSeriesEnumType::PTF_SAE_SHORT,
      ::xsd::qif2::ThreadSeriesEnumType::PTF_SPL_EXTRA_SHORT,
      ::xsd::qif2::ThreadSeriesEnumType::PTF_SPL_SHORT,
      ::xsd::qif2::ThreadSeriesEnumType::PUSH_BUTT,
      ::xsd::qif2::ThreadSeriesEnumType::R,
      ::xsd::qif2::ThreadSeriesEnumType::RC,
      ::xsd::qif2::ThreadSeriesEnumType::RP,
      ::xsd::qif2::ThreadSeriesEnumType::S,
      ::xsd::qif2::ThreadSeriesEnumType::SGT,
      ::xsd::qif2::ThreadSeriesEnumType::SPL_PTF,
      ::xsd::qif2::ThreadSeriesEnumType::STUB_ACME,
      ::xsd::qif2::ThreadSeriesEnumType::TR,
      ::xsd::qif2::ThreadSeriesEnumType::UN,
      ::xsd::qif2::ThreadSeriesEnumType::UNC,
      ::xsd::qif2::ThreadSeriesEnumType::UNDEFINED,
      ::xsd::qif2::ThreadSeriesEnumType::UNEF,
      ::xsd::qif2::ThreadSeriesEnumType::UNF,
      ::xsd::qif2::ThreadSeriesEnumType::UNJ,
      ::xsd::qif2::ThreadSeriesEnumType::UNJC,
      ::xsd::qif2::ThreadSeriesEnumType::UNJEF,
      ::xsd::qif2::ThreadSeriesEnumType::UNJF,
      ::xsd::qif2::ThreadSeriesEnumType::UNM,
      ::xsd::qif2::ThreadSeriesEnumType::UNR,
      ::xsd::qif2::ThreadSeriesEnumType::UNRC,
      ::xsd::qif2::ThreadSeriesEnumType::UNREF,
      ::xsd::qif2::ThreadSeriesEnumType::UNRF,
      ::xsd::qif2::ThreadSeriesEnumType::UNS
    };

    // ThreadSeriesType
    //

    ThreadSeriesType::
    ThreadSeriesType ()
    : ::xml_schema::type (),
      ThreadSeriesEnum_ (this),
      OtherThreadSeries_ (this)
    {
    }

    ThreadSeriesType::
    ThreadSeriesType (const ThreadSeriesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ThreadSeriesEnum_ (x.ThreadSeriesEnum_, f, this),
      OtherThreadSeries_ (x.OtherThreadSeries_, f, this)
    {
    }

    ThreadSeriesType::
    ThreadSeriesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ThreadSeriesEnum_ (this),
      OtherThreadSeries_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadSeriesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThreadSeriesEnum
        //
        if (n.name () == "ThreadSeriesEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadSeriesEnum_type > r (
            ThreadSeriesEnum_traits::create (i, f, this));

          if (!this->ThreadSeriesEnum_)
          {
            this->ThreadSeriesEnum_.set (r);
            continue;
          }
        }

        // OtherThreadSeries
        //
        if (n.name () == "OtherThreadSeries" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherThreadSeries_type > r (
            OtherThreadSeries_traits::create (i, f, this));

          if (!this->OtherThreadSeries_)
          {
            this->OtherThreadSeries_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadSeriesType* ThreadSeriesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSeriesType (*this, f, c);
    }

    ThreadSeriesType& ThreadSeriesType::
    operator= (const ThreadSeriesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ThreadSeriesEnum_ = x.ThreadSeriesEnum_;
        this->OtherThreadSeries_ = x.OtherThreadSeries_;
      }

      return *this;
    }

    ThreadSeriesType::
    ~ThreadSeriesType ()
    {
    }

    // ThreadClassType
    //

    ThreadClassType::
    ThreadClassType ()
    : ::xml_schema::type (),
      ThreadClassEnum_ (this),
      OtherThreadClass_ (this)
    {
    }

    ThreadClassType::
    ThreadClassType (const ThreadClassType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ThreadClassEnum_ (x.ThreadClassEnum_, f, this),
      OtherThreadClass_ (x.OtherThreadClass_, f, this)
    {
    }

    ThreadClassType::
    ThreadClassType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ThreadClassEnum_ (this),
      OtherThreadClass_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadClassType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThreadClassEnum
        //
        if (n.name () == "ThreadClassEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadClassEnum_type > r (
            ThreadClassEnum_traits::create (i, f, this));

          if (!this->ThreadClassEnum_)
          {
            this->ThreadClassEnum_.set (r);
            continue;
          }
        }

        // OtherThreadClass
        //
        if (n.name () == "OtherThreadClass" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherThreadClass_type > r (
            OtherThreadClass_traits::create (i, f, this));

          if (!this->OtherThreadClass_)
          {
            this->OtherThreadClass_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadClassType* ThreadClassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadClassType (*this, f, c);
    }

    ThreadClassType& ThreadClassType::
    operator= (const ThreadClassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ThreadClassEnum_ = x.ThreadClassEnum_;
        this->OtherThreadClass_ = x.OtherThreadClass_;
      }

      return *this;
    }

    ThreadClassType::
    ~ThreadClassType ()
    {
    }

    // ThreadClassEnumType
    //

    ThreadClassEnumType::
    ThreadClassEnumType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ThreadClassEnumType_convert ();
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ThreadClassEnumType_convert ();
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ThreadClassEnumType_convert ();
    }

    ThreadClassEnumType* ThreadClassEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadClassEnumType (*this, f, c);
    }

    ThreadClassEnumType::value ThreadClassEnumType::
    _xsd_ThreadClassEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ThreadClassEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ThreadClassEnumType_indexes_,
                        _xsd_ThreadClassEnumType_indexes_ + 50,
                        *this,
                        c));

      if (i == _xsd_ThreadClassEnumType_indexes_ + 50 || _xsd_ThreadClassEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ThreadClassEnumType::
    _xsd_ThreadClassEnumType_literals_[50] =
    {
      "1A",
      "1B",
      "2A",
      "2AG",
      "2B",
      "3A",
      "3B",
      "EXT_3E",
      "EXT_3F",
      "EXT_3G",
      "EXT_3H",
      "EXT_4E",
      "EXT_4F",
      "EXT_4G",
      "EXT_4H",
      "4G",
      "4H",
      "EXT_5E",
      "EXT_5F",
      "EXT_5G",
      "EXT_5H",
      "5G",
      "5H",
      "EXT_6E",
      "EXT_6F",
      "EXT_6G",
      "EXT_6H",
      "6G",
      "6H",
      "EXT_7E",
      "EXT_7F",
      "EXT_7G",
      "EXT_7H",
      "7G",
      "7H",
      "EXT_8E",
      "EXT_8F",
      "EXT_8G",
      "EXT_8H",
      "8G",
      "8H",
      "EXT_9E",
      "EXT_9F",
      "EXT_9G",
      "EXT_9H",
      "INT",
      "EXT",
      "SE",
      "G",
      "UNDEFINED"
    };

    const ThreadClassEnumType::value ThreadClassEnumType::
    _xsd_ThreadClassEnumType_indexes_[50] =
    {
      ::xsd::qif2::ThreadClassEnumType::cxx_1A,
      ::xsd::qif2::ThreadClassEnumType::cxx_1B,
      ::xsd::qif2::ThreadClassEnumType::cxx_2A,
      ::xsd::qif2::ThreadClassEnumType::cxx_2AG,
      ::xsd::qif2::ThreadClassEnumType::cxx_2B,
      ::xsd::qif2::ThreadClassEnumType::cxx_3A,
      ::xsd::qif2::ThreadClassEnumType::cxx_3B,
      ::xsd::qif2::ThreadClassEnumType::cxx_4G,
      ::xsd::qif2::ThreadClassEnumType::cxx_4H,
      ::xsd::qif2::ThreadClassEnumType::cxx_5G,
      ::xsd::qif2::ThreadClassEnumType::cxx_5H,
      ::xsd::qif2::ThreadClassEnumType::cxx_6G,
      ::xsd::qif2::ThreadClassEnumType::cxx_6H,
      ::xsd::qif2::ThreadClassEnumType::cxx_7G,
      ::xsd::qif2::ThreadClassEnumType::cxx_7H,
      ::xsd::qif2::ThreadClassEnumType::cxx_8G,
      ::xsd::qif2::ThreadClassEnumType::cxx_8H,
      ::xsd::qif2::ThreadClassEnumType::EXT,
      ::xsd::qif2::ThreadClassEnumType::EXT_3E,
      ::xsd::qif2::ThreadClassEnumType::EXT_3F,
      ::xsd::qif2::ThreadClassEnumType::EXT_3G,
      ::xsd::qif2::ThreadClassEnumType::EXT_3H,
      ::xsd::qif2::ThreadClassEnumType::EXT_4E,
      ::xsd::qif2::ThreadClassEnumType::EXT_4F,
      ::xsd::qif2::ThreadClassEnumType::EXT_4G,
      ::xsd::qif2::ThreadClassEnumType::EXT_4H,
      ::xsd::qif2::ThreadClassEnumType::EXT_5E,
      ::xsd::qif2::ThreadClassEnumType::EXT_5F,
      ::xsd::qif2::ThreadClassEnumType::EXT_5G,
      ::xsd::qif2::ThreadClassEnumType::EXT_5H,
      ::xsd::qif2::ThreadClassEnumType::EXT_6E,
      ::xsd::qif2::ThreadClassEnumType::EXT_6F,
      ::xsd::qif2::ThreadClassEnumType::EXT_6G,
      ::xsd::qif2::ThreadClassEnumType::EXT_6H,
      ::xsd::qif2::ThreadClassEnumType::EXT_7E,
      ::xsd::qif2::ThreadClassEnumType::EXT_7F,
      ::xsd::qif2::ThreadClassEnumType::EXT_7G,
      ::xsd::qif2::ThreadClassEnumType::EXT_7H,
      ::xsd::qif2::ThreadClassEnumType::EXT_8E,
      ::xsd::qif2::ThreadClassEnumType::EXT_8F,
      ::xsd::qif2::ThreadClassEnumType::EXT_8G,
      ::xsd::qif2::ThreadClassEnumType::EXT_8H,
      ::xsd::qif2::ThreadClassEnumType::EXT_9E,
      ::xsd::qif2::ThreadClassEnumType::EXT_9F,
      ::xsd::qif2::ThreadClassEnumType::EXT_9G,
      ::xsd::qif2::ThreadClassEnumType::EXT_9H,
      ::xsd::qif2::ThreadClassEnumType::G,
      ::xsd::qif2::ThreadClassEnumType::INT,
      ::xsd::qif2::ThreadClassEnumType::SE,
      ::xsd::qif2::ThreadClassEnumType::UNDEFINED
    };

    // SecurityClassificationEnumType
    //

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SecurityClassificationEnumType_convert ();
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SecurityClassificationEnumType_convert ();
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SecurityClassificationEnumType_convert ();
    }

    SecurityClassificationEnumType* SecurityClassificationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecurityClassificationEnumType (*this, f, c);
    }

    SecurityClassificationEnumType::value SecurityClassificationEnumType::
    _xsd_SecurityClassificationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SecurityClassificationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SecurityClassificationEnumType_indexes_,
                        _xsd_SecurityClassificationEnumType_indexes_ + 32,
                        *this,
                        c));

      if (i == _xsd_SecurityClassificationEnumType_indexes_ + 32 || _xsd_SecurityClassificationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const SecurityClassificationEnumType::
    _xsd_SecurityClassificationEnumType_literals_[32] =
    {
      "NONE",
      "UNCLASSIFIED",
      "RESTRICTED",
      "EU_RESTRICTED",
      "WEU_RESTRICTED",
      "FOR_OFFICIAL_USE_ONLY",
      "PROTECTED",
      "PROTECTED_A",
      "PROTECTED_B",
      "PROTECTED_C",
      "CONFIDENTIAL",
      "EU_CONFIDENTIAL",
      "WEU_CONFIDENTIAL",
      "SECRET",
      "SECRET_NATIONAL_SECURITY_INFORMATION",
      "SECRET_FORMERLY_RESTRICTED_DATA",
      "SECRET_RESTRICTED_DATA",
      "SECRET",
      "EU_SECRET",
      "WEU_SECRET",
      "TOP_SECRET_NATIONAL_SECURITY_INFORMATION",
      "TOP_SECRET_FORMERLY_RESTRICTED_DATA",
      "TOP_SECRET_RESTRICTED_DATA",
      "EU_TOP_SECRET",
      "FOCAL_TOP_SECRET",
      "COMPANY_CONFIDENTIAL",
      "OFFICAL_USE_ONLY",
      "TRADE_SECRET",
      "TRADEMARK",
      "REGISTERED_TRADEMARK",
      "PATENT",
      "UNDEFINED"
    };

    const SecurityClassificationEnumType::value SecurityClassificationEnumType::
    _xsd_SecurityClassificationEnumType_indexes_[32] =
    {
      ::xsd::qif2::SecurityClassificationEnumType::COMPANY_CONFIDENTIAL,
      ::xsd::qif2::SecurityClassificationEnumType::CONFIDENTIAL,
      ::xsd::qif2::SecurityClassificationEnumType::EU_CONFIDENTIAL,
      ::xsd::qif2::SecurityClassificationEnumType::EU_RESTRICTED,
      ::xsd::qif2::SecurityClassificationEnumType::EU_SECRET,
      ::xsd::qif2::SecurityClassificationEnumType::EU_TOP_SECRET,
      ::xsd::qif2::SecurityClassificationEnumType::FOCAL_TOP_SECRET,
      ::xsd::qif2::SecurityClassificationEnumType::FOR_OFFICIAL_USE_ONLY,
      ::xsd::qif2::SecurityClassificationEnumType::NONE,
      ::xsd::qif2::SecurityClassificationEnumType::OFFICAL_USE_ONLY,
      ::xsd::qif2::SecurityClassificationEnumType::PATENT,
      ::xsd::qif2::SecurityClassificationEnumType::PROTECTED,
      ::xsd::qif2::SecurityClassificationEnumType::PROTECTED_A,
      ::xsd::qif2::SecurityClassificationEnumType::PROTECTED_B,
      ::xsd::qif2::SecurityClassificationEnumType::PROTECTED_C,
      ::xsd::qif2::SecurityClassificationEnumType::REGISTERED_TRADEMARK,
      ::xsd::qif2::SecurityClassificationEnumType::RESTRICTED,
      ::xsd::qif2::SecurityClassificationEnumType::SECRET,
      ::xsd::qif2::SecurityClassificationEnumType::SECRET1,
      ::xsd::qif2::SecurityClassificationEnumType::SECRET_FORMERLY_RESTRICTED_DATA,
      ::xsd::qif2::SecurityClassificationEnumType::SECRET_NATIONAL_SECURITY_INFORMATION,
      ::xsd::qif2::SecurityClassificationEnumType::SECRET_RESTRICTED_DATA,
      ::xsd::qif2::SecurityClassificationEnumType::TOP_SECRET_FORMERLY_RESTRICTED_DATA,
      ::xsd::qif2::SecurityClassificationEnumType::TOP_SECRET_NATIONAL_SECURITY_INFORMATION,
      ::xsd::qif2::SecurityClassificationEnumType::TOP_SECRET_RESTRICTED_DATA,
      ::xsd::qif2::SecurityClassificationEnumType::TRADEMARK,
      ::xsd::qif2::SecurityClassificationEnumType::TRADE_SECRET,
      ::xsd::qif2::SecurityClassificationEnumType::UNCLASSIFIED,
      ::xsd::qif2::SecurityClassificationEnumType::UNDEFINED,
      ::xsd::qif2::SecurityClassificationEnumType::WEU_CONFIDENTIAL,
      ::xsd::qif2::SecurityClassificationEnumType::WEU_RESTRICTED,
      ::xsd::qif2::SecurityClassificationEnumType::WEU_SECRET
    };

    // SecurityClassificationType
    //

    SecurityClassificationType::
    SecurityClassificationType ()
    : ::xml_schema::type (),
      SecurityClassificationEnum_ (this),
      OtherSecurityClassification_ (this)
    {
    }

    SecurityClassificationType::
    SecurityClassificationType (const SecurityClassificationType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SecurityClassificationEnum_ (x.SecurityClassificationEnum_, f, this),
      OtherSecurityClassification_ (x.OtherSecurityClassification_, f, this)
    {
    }

    SecurityClassificationType::
    SecurityClassificationType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SecurityClassificationEnum_ (this),
      OtherSecurityClassification_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SecurityClassificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SecurityClassificationEnum
        //
        if (n.name () == "SecurityClassificationEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SecurityClassificationEnum_type > r (
            SecurityClassificationEnum_traits::create (i, f, this));

          if (!this->SecurityClassificationEnum_)
          {
            this->SecurityClassificationEnum_.set (r);
            continue;
          }
        }

        // OtherSecurityClassification
        //
        if (n.name () == "OtherSecurityClassification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherSecurityClassification_type > r (
            OtherSecurityClassification_traits::create (i, f, this));

          if (!this->OtherSecurityClassification_)
          {
            this->OtherSecurityClassification_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SecurityClassificationType* SecurityClassificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecurityClassificationType (*this, f, c);
    }

    SecurityClassificationType& SecurityClassificationType::
    operator= (const SecurityClassificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SecurityClassificationEnum_ = x.SecurityClassificationEnum_;
        this->OtherSecurityClassification_ = x.OtherSecurityClassification_;
      }

      return *this;
    }

    SecurityClassificationType::
    ~SecurityClassificationType ()
    {
    }

    // DigitalModelFormatEnumType
    //

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DigitalModelFormatEnumType_convert ();
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DigitalModelFormatEnumType_convert ();
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DigitalModelFormatEnumType_convert ();
    }

    DigitalModelFormatEnumType* DigitalModelFormatEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalModelFormatEnumType (*this, f, c);
    }

    DigitalModelFormatEnumType::value DigitalModelFormatEnumType::
    _xsd_DigitalModelFormatEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DigitalModelFormatEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DigitalModelFormatEnumType_indexes_,
                        _xsd_DigitalModelFormatEnumType_indexes_ + 15,
                        *this,
                        c));

      if (i == _xsd_DigitalModelFormatEnumType_indexes_ + 15 || _xsd_DigitalModelFormatEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const DigitalModelFormatEnumType::
    _xsd_DigitalModelFormatEnumType_literals_[15] =
    {
      "STEPAP203",
      "STEPAP203E2",
      "STEPAP214",
      "STEPAP242",
      "JTOPEN",
      "RPC",
      "PDPMI",
      "ACIS",
      "PARASOLID",
      "AUTODESK",
      "PTC",
      "NX",
      "SOLIDWORKS",
      "CATIA",
      "NOTDEFINED"
    };

    const DigitalModelFormatEnumType::value DigitalModelFormatEnumType::
    _xsd_DigitalModelFormatEnumType_indexes_[15] =
    {
      ::xsd::qif2::DigitalModelFormatEnumType::ACIS,
      ::xsd::qif2::DigitalModelFormatEnumType::AUTODESK,
      ::xsd::qif2::DigitalModelFormatEnumType::CATIA,
      ::xsd::qif2::DigitalModelFormatEnumType::JTOPEN,
      ::xsd::qif2::DigitalModelFormatEnumType::NOTDEFINED,
      ::xsd::qif2::DigitalModelFormatEnumType::NX,
      ::xsd::qif2::DigitalModelFormatEnumType::PARASOLID,
      ::xsd::qif2::DigitalModelFormatEnumType::PDPMI,
      ::xsd::qif2::DigitalModelFormatEnumType::PTC,
      ::xsd::qif2::DigitalModelFormatEnumType::RPC,
      ::xsd::qif2::DigitalModelFormatEnumType::SOLIDWORKS,
      ::xsd::qif2::DigitalModelFormatEnumType::STEPAP203,
      ::xsd::qif2::DigitalModelFormatEnumType::STEPAP203E2,
      ::xsd::qif2::DigitalModelFormatEnumType::STEPAP214,
      ::xsd::qif2::DigitalModelFormatEnumType::STEPAP242
    };

    // DigitalModelFormatType
    //

    DigitalModelFormatType::
    DigitalModelFormatType ()
    : ::xml_schema::type (),
      DigitalModelFormatEnum_ (this),
      OtherDigitalModelFormat_ (this)
    {
    }

    DigitalModelFormatType::
    DigitalModelFormatType (const DigitalModelFormatType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DigitalModelFormatEnum_ (x.DigitalModelFormatEnum_, f, this),
      OtherDigitalModelFormat_ (x.OtherDigitalModelFormat_, f, this)
    {
    }

    DigitalModelFormatType::
    DigitalModelFormatType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DigitalModelFormatEnum_ (this),
      OtherDigitalModelFormat_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DigitalModelFormatType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DigitalModelFormatEnum
        //
        if (n.name () == "DigitalModelFormatEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DigitalModelFormatEnum_type > r (
            DigitalModelFormatEnum_traits::create (i, f, this));

          if (!this->DigitalModelFormatEnum_)
          {
            this->DigitalModelFormatEnum_.set (r);
            continue;
          }
        }

        // OtherDigitalModelFormat
        //
        if (n.name () == "OtherDigitalModelFormat" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherDigitalModelFormat_type > r (
            OtherDigitalModelFormat_traits::create (i, f, this));

          if (!this->OtherDigitalModelFormat_)
          {
            this->OtherDigitalModelFormat_.set (r);
            continue;
          }
        }

        break;
      }
    }

    DigitalModelFormatType* DigitalModelFormatType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalModelFormatType (*this, f, c);
    }

    DigitalModelFormatType& DigitalModelFormatType::
    operator= (const DigitalModelFormatType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DigitalModelFormatEnum_ = x.DigitalModelFormatEnum_;
        this->OtherDigitalModelFormat_ = x.OtherDigitalModelFormat_;
      }

      return *this;
    }

    DigitalModelFormatType::
    ~DigitalModelFormatType ()
    {
    }

    // UniformScaleType
    //

    UniformScaleType::
    UniformScaleType (const ScaleFactor_type& ScaleFactor)
    : ::xml_schema::type (),
      ScaleFactor_ (ScaleFactor, this)
    {
    }

    UniformScaleType::
    UniformScaleType (const UniformScaleType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ScaleFactor_ (x.ScaleFactor_, f, this)
    {
    }

    UniformScaleType::
    UniformScaleType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ScaleFactor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UniformScaleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ScaleFactor
        //
        if (n.name () == "ScaleFactor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ScaleFactor_.present ())
          {
            this->ScaleFactor_.set (ScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!ScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleFactor",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    UniformScaleType* UniformScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UniformScaleType (*this, f, c);
    }

    UniformScaleType& UniformScaleType::
    operator= (const UniformScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ScaleFactor_ = x.ScaleFactor_;
      }

      return *this;
    }

    UniformScaleType::
    ~UniformScaleType ()
    {
    }

    // RadialDifferentialScaleType
    //

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const PerpendicularScaleFactor_type& PerpendicularScaleFactor,
                                 const ParallelScaleFactor_type& ParallelScaleFactor,
                                 const Direction_type& Direction)
    : ::xml_schema::type (),
      PerpendicularScaleFactor_ (PerpendicularScaleFactor, this),
      ParallelScaleFactor_ (ParallelScaleFactor, this),
      Direction_ (Direction, this)
    {
    }

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const PerpendicularScaleFactor_type& PerpendicularScaleFactor,
                                 const ParallelScaleFactor_type& ParallelScaleFactor,
                                 ::std::auto_ptr< Direction_type > Direction)
    : ::xml_schema::type (),
      PerpendicularScaleFactor_ (PerpendicularScaleFactor, this),
      ParallelScaleFactor_ (ParallelScaleFactor, this),
      Direction_ (Direction, this)
    {
    }

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const RadialDifferentialScaleType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PerpendicularScaleFactor_ (x.PerpendicularScaleFactor_, f, this),
      ParallelScaleFactor_ (x.ParallelScaleFactor_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PerpendicularScaleFactor_ (this),
      ParallelScaleFactor_ (this),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RadialDifferentialScaleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PerpendicularScaleFactor
        //
        if (n.name () == "PerpendicularScaleFactor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!PerpendicularScaleFactor_.present ())
          {
            this->PerpendicularScaleFactor_.set (PerpendicularScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // ParallelScaleFactor
        //
        if (n.name () == "ParallelScaleFactor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ParallelScaleFactor_.present ())
          {
            this->ParallelScaleFactor_.set (ParallelScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PerpendicularScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PerpendicularScaleFactor",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ParallelScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ParallelScaleFactor",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    RadialDifferentialScaleType* RadialDifferentialScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RadialDifferentialScaleType (*this, f, c);
    }

    RadialDifferentialScaleType& RadialDifferentialScaleType::
    operator= (const RadialDifferentialScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PerpendicularScaleFactor_ = x.PerpendicularScaleFactor_;
        this->ParallelScaleFactor_ = x.ParallelScaleFactor_;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    RadialDifferentialScaleType::
    ~RadialDifferentialScaleType ()
    {
    }

    // AxialDifferentialScaleType
    //

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const XScaleFactor_type& XScaleFactor,
                                const XaxisDirection_type& XaxisDirection,
                                const YScaleFactor_type& YScaleFactor,
                                const YaxisDirection_type& YaxisDirection,
                                const ZScaleFactor_type& ZScaleFactor,
                                const ZaxisDirection_type& ZaxisDirection)
    : ::xml_schema::type (),
      XScaleFactor_ (XScaleFactor, this),
      XaxisDirection_ (XaxisDirection, this),
      YScaleFactor_ (YScaleFactor, this),
      YaxisDirection_ (YaxisDirection, this),
      ZScaleFactor_ (ZScaleFactor, this),
      ZaxisDirection_ (ZaxisDirection, this)
    {
    }

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const XScaleFactor_type& XScaleFactor,
                                ::std::auto_ptr< XaxisDirection_type > XaxisDirection,
                                const YScaleFactor_type& YScaleFactor,
                                ::std::auto_ptr< YaxisDirection_type > YaxisDirection,
                                const ZScaleFactor_type& ZScaleFactor,
                                ::std::auto_ptr< ZaxisDirection_type > ZaxisDirection)
    : ::xml_schema::type (),
      XScaleFactor_ (XScaleFactor, this),
      XaxisDirection_ (XaxisDirection, this),
      YScaleFactor_ (YScaleFactor, this),
      YaxisDirection_ (YaxisDirection, this),
      ZScaleFactor_ (ZScaleFactor, this),
      ZaxisDirection_ (ZaxisDirection, this)
    {
    }

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const AxialDifferentialScaleType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XScaleFactor_ (x.XScaleFactor_, f, this),
      XaxisDirection_ (x.XaxisDirection_, f, this),
      YScaleFactor_ (x.YScaleFactor_, f, this),
      YaxisDirection_ (x.YaxisDirection_, f, this),
      ZScaleFactor_ (x.ZScaleFactor_, f, this),
      ZaxisDirection_ (x.ZaxisDirection_, f, this)
    {
    }

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XScaleFactor_ (this),
      XaxisDirection_ (this),
      YScaleFactor_ (this),
      YaxisDirection_ (this),
      ZScaleFactor_ (this),
      ZaxisDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AxialDifferentialScaleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XScaleFactor
        //
        if (n.name () == "XScaleFactor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!XScaleFactor_.present ())
          {
            this->XScaleFactor_.set (XScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // XaxisDirection
        //
        if (n.name () == "XaxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XaxisDirection_type > r (
            XaxisDirection_traits::create (i, f, this));

          if (!XaxisDirection_.present ())
          {
            this->XaxisDirection_.set (r);
            continue;
          }
        }

        // YScaleFactor
        //
        if (n.name () == "YScaleFactor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!YScaleFactor_.present ())
          {
            this->YScaleFactor_.set (YScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // YaxisDirection
        //
        if (n.name () == "YaxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YaxisDirection_type > r (
            YaxisDirection_traits::create (i, f, this));

          if (!YaxisDirection_.present ())
          {
            this->YaxisDirection_.set (r);
            continue;
          }
        }

        // ZScaleFactor
        //
        if (n.name () == "ZScaleFactor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ZScaleFactor_.present ())
          {
            this->ZScaleFactor_.set (ZScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // ZaxisDirection
        //
        if (n.name () == "ZaxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZaxisDirection_type > r (
            ZaxisDirection_traits::create (i, f, this));

          if (!ZaxisDirection_.present ())
          {
            this->ZaxisDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XScaleFactor",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XaxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XaxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YScaleFactor",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YaxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YaxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZScaleFactor",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZaxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZaxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AxialDifferentialScaleType* AxialDifferentialScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AxialDifferentialScaleType (*this, f, c);
    }

    AxialDifferentialScaleType& AxialDifferentialScaleType::
    operator= (const AxialDifferentialScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XScaleFactor_ = x.XScaleFactor_;
        this->XaxisDirection_ = x.XaxisDirection_;
        this->YScaleFactor_ = x.YScaleFactor_;
        this->YaxisDirection_ = x.YaxisDirection_;
        this->ZScaleFactor_ = x.ZScaleFactor_;
        this->ZaxisDirection_ = x.ZaxisDirection_;
      }

      return *this;
    }

    AxialDifferentialScaleType::
    ~AxialDifferentialScaleType ()
    {
    }

    // ScaleType
    //

    ScaleType::
    ScaleType (const Origin_type& Origin)
    : ::xml_schema::type (),
      Origin_ (Origin, this),
      UniformScale_ (this),
      RadialDifferentialScale_ (this),
      AxialDifferentialScale_ (this)
    {
    }

    ScaleType::
    ScaleType (::std::auto_ptr< Origin_type > Origin)
    : ::xml_schema::type (),
      Origin_ (Origin, this),
      UniformScale_ (this),
      RadialDifferentialScale_ (this),
      AxialDifferentialScale_ (this)
    {
    }

    ScaleType::
    ScaleType (const ScaleType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Origin_ (x.Origin_, f, this),
      UniformScale_ (x.UniformScale_, f, this),
      RadialDifferentialScale_ (x.RadialDifferentialScale_, f, this),
      AxialDifferentialScale_ (x.AxialDifferentialScale_, f, this)
    {
    }

    ScaleType::
    ScaleType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Origin_ (this),
      UniformScale_ (this),
      RadialDifferentialScale_ (this),
      AxialDifferentialScale_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ScaleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Origin
        //
        if (n.name () == "Origin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          if (!Origin_.present ())
          {
            this->Origin_.set (r);
            continue;
          }
        }

        // UniformScale
        //
        if (n.name () == "UniformScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UniformScale_type > r (
            UniformScale_traits::create (i, f, this));

          if (!this->UniformScale_)
          {
            this->UniformScale_.set (r);
            continue;
          }
        }

        // RadialDifferentialScale
        //
        if (n.name () == "RadialDifferentialScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RadialDifferentialScale_type > r (
            RadialDifferentialScale_traits::create (i, f, this));

          if (!this->RadialDifferentialScale_)
          {
            this->RadialDifferentialScale_.set (r);
            continue;
          }
        }

        // AxialDifferentialScale
        //
        if (n.name () == "AxialDifferentialScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxialDifferentialScale_type > r (
            AxialDifferentialScale_traits::create (i, f, this));

          if (!this->AxialDifferentialScale_)
          {
            this->AxialDifferentialScale_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Origin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Origin",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ScaleType* ScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScaleType (*this, f, c);
    }

    ScaleType& ScaleType::
    operator= (const ScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Origin_ = x.Origin_;
        this->UniformScale_ = x.UniformScale_;
        this->RadialDifferentialScale_ = x.RadialDifferentialScale_;
        this->AxialDifferentialScale_ = x.AxialDifferentialScale_;
      }

      return *this;
    }

    ScaleType::
    ~ScaleType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const RectangularUnitAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // RectangularUnitAreaLength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RectangularUnitAreaLength",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RectangularUnitAreaLength ();
      }

      // RectangularUnitAreaWidth
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RectangularUnitAreaWidth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RectangularUnitAreaWidth ();
      }

      // RectangularUnitAreaOrientation
      //
      if (i.RectangularUnitAreaOrientation ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RectangularUnitAreaOrientation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RectangularUnitAreaOrientation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircularUnitAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CircularUnitAreaDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CircularUnitAreaDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CircularUnitAreaDiameter ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualZoneAxisType& i)
    {
      e << static_cast< const ::xsd::qif2::AxisType& > (i);

      // Length
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Length ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BottomEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const BottomEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const BottomEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const BottomType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BottomEnum
      //
      if (i.BottomEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BottomEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BottomEnum ();
      }

      // OtherBottom
      //
      if (i.OtherBottom ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherBottom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherBottom ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BoundingBoxType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Length
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Length ();
      }

      // Width
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Width ();
      }

      // Height
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Height",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Height ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShapeClassEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ShapeClassEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ShapeClassEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ShapeClassType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ShapeClassEnum
      //
      if (i.ShapeClassEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ShapeClassEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ShapeClassEnum ();
      }

      // OtherShapeClass
      //
      if (i.OtherShapeClass ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherShapeClass",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherShapeClass ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ManufacturingMethodEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ManufacturingMethodEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ManufacturingMethodEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ManufacturingMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ManufacturingMethodEnum
      //
      if (i.ManufacturingMethodEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ManufacturingMethodEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ManufacturingMethodEnum ();
      }

      // OtherManufacturingMethod
      //
      if (i.OtherManufacturingMethod ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherManufacturingMethod",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherManufacturingMethod ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const InternalExternalEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const InternalExternalEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const InternalExternalEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DimensionCountEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DimensionCountEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DimensionCountEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoordinateEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const CoordinateEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CoordinateEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const TypeOfCoordinatesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoordinateEnum
      //
      if (i.CoordinateEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CoordinateEnum ();
      }

      // OtherCoordinate
      //
      if (i.OtherCoordinate ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherCoordinate",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherCoordinate ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RectangleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Length
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Length ();
      }

      // CornerPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CornerPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CornerPoint ();
      }

      // Width
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Width ();
      }

      // WidthDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.WidthDirection ();
      }

      // LengthDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.LengthDirection ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CenterPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CenterPoint ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // Normal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Normal ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CenterPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CenterPoint ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }

      // Length
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Length ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CenterPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CenterPoint ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointAndVectorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StartPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StartPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.StartPoint ();
      }

      // Vector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Vector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Vector ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualPointAndVectorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StartPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StartPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.StartPoint ();
      }

      // Vector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Vector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Vector ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SlotEndEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const SlotEndEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SlotEndEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const EndRadiusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EndRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.EndRadius ();
      }

      // Expanded
      //
      if (i.Expanded ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Expanded",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Expanded ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualEndRadiusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EndRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.EndRadius ();
      }

      // Expanded
      //
      if (i.Expanded ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Expanded",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Expanded ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SlotEndType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SlotEndEnum
      //
      if (i.SlotEndEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SlotEndEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SlotEndEnum ();
      }

      // OtherSlotEnd
      //
      if (i.OtherSlotEnd ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherSlotEnd",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherSlotEnd ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadSeriesEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ThreadSeriesEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ThreadSeriesEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadSeriesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ThreadSeriesEnum
      //
      if (i.ThreadSeriesEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadSeriesEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThreadSeriesEnum ();
      }

      // OtherThreadSeries
      //
      if (i.OtherThreadSeries ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherThreadSeries",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherThreadSeries ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadClassType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ThreadClassEnum
      //
      if (i.ThreadClassEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadClassEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThreadClassEnum ();
      }

      // OtherThreadClass
      //
      if (i.OtherThreadClass ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherThreadClass",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherThreadClass ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadClassEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ThreadClassEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ThreadClassEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const SecurityClassificationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const SecurityClassificationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SecurityClassificationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const SecurityClassificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SecurityClassificationEnum
      //
      if (i.SecurityClassificationEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SecurityClassificationEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SecurityClassificationEnum ();
      }

      // OtherSecurityClassification
      //
      if (i.OtherSecurityClassification ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherSecurityClassification",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherSecurityClassification ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DigitalModelFormatEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DigitalModelFormatEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DigitalModelFormatEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DigitalModelFormatType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DigitalModelFormatEnum
      //
      if (i.DigitalModelFormatEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigitalModelFormatEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DigitalModelFormatEnum ();
      }

      // OtherDigitalModelFormat
      //
      if (i.OtherDigitalModelFormat ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherDigitalModelFormat",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherDigitalModelFormat ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const UniformScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ScaleFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleFactor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.ScaleFactor ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RadialDifferentialScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PerpendicularScaleFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PerpendicularScaleFactor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.PerpendicularScaleFactor ());
      }

      // ParallelScaleFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParallelScaleFactor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.ParallelScaleFactor ());
      }

      // Direction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Direction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Direction ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AxialDifferentialScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XScaleFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XScaleFactor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.XScaleFactor ());
      }

      // XaxisDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XaxisDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XaxisDirection ();
      }

      // YScaleFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YScaleFactor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.YScaleFactor ());
      }

      // YaxisDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YaxisDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YaxisDirection ();
      }

      // ZScaleFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZScaleFactor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.ZScaleFactor ());
      }

      // ZaxisDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZaxisDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZaxisDirection ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Origin
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Origin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Origin ();
      }

      // UniformScale
      //
      if (i.UniformScale ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UniformScale",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UniformScale ();
      }

      // RadialDifferentialScale
      //
      if (i.RadialDifferentialScale ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RadialDifferentialScale",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RadialDifferentialScale ();
      }

      // AxialDifferentialScale
      //
      if (i.AxialDifferentialScale ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxialDifferentialScale",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AxialDifferentialScale ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

