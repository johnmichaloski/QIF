// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Units.hxx"

namespace xsd
{
  namespace qif2
  {
    // PositiveDecimalType
    // 


    // NonNegativeDecimalType
    // 


    // UnitConversionType
    // 

    const UnitConversionType::Factor_type& UnitConversionType::
    Factor () const
    {
      return this->Factor_.get ();
    }

    UnitConversionType::Factor_type& UnitConversionType::
    Factor ()
    {
      return this->Factor_.get ();
    }

    void UnitConversionType::
    Factor (const Factor_type& x)
    {
      this->Factor_.set (x);
    }

    void UnitConversionType::
    Factor (::std::auto_ptr< Factor_type > x)
    {
      this->Factor_.set (x);
    }

    const UnitConversionType::Offset_optional& UnitConversionType::
    Offset () const
    {
      return this->Offset_;
    }

    UnitConversionType::Offset_optional& UnitConversionType::
    Offset ()
    {
      return this->Offset_;
    }

    void UnitConversionType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void UnitConversionType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    UnitConversionType::Offset_type UnitConversionType::
    Offset_default_value ()
    {
      return Offset_type (0.0);
    }


    // SpecifiedDecimalType
    // 

    const SpecifiedDecimalType::decimalPlaces_optional& SpecifiedDecimalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    SpecifiedDecimalType::decimalPlaces_optional& SpecifiedDecimalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void SpecifiedDecimalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void SpecifiedDecimalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const SpecifiedDecimalType::significantFigures_optional& SpecifiedDecimalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    SpecifiedDecimalType::significantFigures_optional& SpecifiedDecimalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void SpecifiedDecimalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void SpecifiedDecimalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }


    // ActualDecimalType
    // 

    const ActualDecimalType::combinedUncertainty_optional& ActualDecimalType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    ActualDecimalType::combinedUncertainty_optional& ActualDecimalType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void ActualDecimalType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void ActualDecimalType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    void ActualDecimalType::
    combinedUncertainty (::std::auto_ptr< combinedUncertainty_type > x)
    {
      this->combinedUncertainty_.set (x);
    }

    const ActualDecimalType::meanError_optional& ActualDecimalType::
    meanError () const
    {
      return this->meanError_;
    }

    ActualDecimalType::meanError_optional& ActualDecimalType::
    meanError ()
    {
      return this->meanError_;
    }

    void ActualDecimalType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void ActualDecimalType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    void ActualDecimalType::
    meanError (::std::auto_ptr< meanError_type > x)
    {
      this->meanError_.set (x);
    }


    // AngularUnitType
    // 

    const AngularUnitType::SIUnitName_optional& AngularUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    AngularUnitType::SIUnitName_optional& AngularUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void AngularUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void AngularUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void AngularUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const AngularUnitType::SIUnitName_type& AngularUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const AngularUnitType::UnitName_type& AngularUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    AngularUnitType::UnitName_type& AngularUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void AngularUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void AngularUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const AngularUnitType::UnitConversion_optional& AngularUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    AngularUnitType::UnitConversion_optional& AngularUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void AngularUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void AngularUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void AngularUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // AngularValueType
    // 

    const AngularValueType::angularUnit_optional& AngularValueType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    AngularValueType::angularUnit_optional& AngularValueType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void AngularValueType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void AngularValueType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void AngularValueType::
    angularUnit (::std::auto_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (x);
    }


    // ActualAngularValueType
    // 

    const ActualAngularValueType::angularUnit_optional& ActualAngularValueType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    ActualAngularValueType::angularUnit_optional& ActualAngularValueType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void ActualAngularValueType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void ActualAngularValueType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void ActualAngularValueType::
    angularUnit (::std::auto_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (x);
    }


    // AreaUnitType
    // 

    const AreaUnitType::SIUnitName_optional& AreaUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    AreaUnitType::SIUnitName_optional& AreaUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void AreaUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void AreaUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void AreaUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const AreaUnitType::SIUnitName_type& AreaUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const AreaUnitType::UnitName_type& AreaUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    AreaUnitType::UnitName_type& AreaUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void AreaUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void AreaUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const AreaUnitType::UnitConversion_optional& AreaUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    AreaUnitType::UnitConversion_optional& AreaUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void AreaUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void AreaUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void AreaUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // AreaValueType
    // 

    const AreaValueType::areaUnit_optional& AreaValueType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    AreaValueType::areaUnit_optional& AreaValueType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void AreaValueType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void AreaValueType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void AreaValueType::
    areaUnit (::std::auto_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (x);
    }


    // ActualAreaValueType
    // 

    const ActualAreaValueType::areaUnit_optional& ActualAreaValueType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    ActualAreaValueType::areaUnit_optional& ActualAreaValueType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void ActualAreaValueType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void ActualAreaValueType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void ActualAreaValueType::
    areaUnit (::std::auto_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (x);
    }


    // ForceUnitType
    // 

    const ForceUnitType::SIUnitName_optional& ForceUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    ForceUnitType::SIUnitName_optional& ForceUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void ForceUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void ForceUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void ForceUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const ForceUnitType::SIUnitName_type& ForceUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const ForceUnitType::UnitName_type& ForceUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    ForceUnitType::UnitName_type& ForceUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void ForceUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void ForceUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const ForceUnitType::UnitConversion_optional& ForceUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    ForceUnitType::UnitConversion_optional& ForceUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void ForceUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void ForceUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void ForceUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // ForceValueType
    // 

    const ForceValueType::forceUnit_optional& ForceValueType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    ForceValueType::forceUnit_optional& ForceValueType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void ForceValueType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void ForceValueType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void ForceValueType::
    forceUnit (::std::auto_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (x);
    }


    // ActualForceValueType
    // 

    const ActualForceValueType::forceUnit_optional& ActualForceValueType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    ActualForceValueType::forceUnit_optional& ActualForceValueType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void ActualForceValueType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void ActualForceValueType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void ActualForceValueType::
    forceUnit (::std::auto_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (x);
    }


    // LinearUnitType
    // 

    const LinearUnitType::SIUnitName_optional& LinearUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    LinearUnitType::SIUnitName_optional& LinearUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void LinearUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void LinearUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void LinearUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const LinearUnitType::SIUnitName_type& LinearUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const LinearUnitType::UnitName_type& LinearUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    LinearUnitType::UnitName_type& LinearUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void LinearUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void LinearUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const LinearUnitType::UnitConversion_optional& LinearUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    LinearUnitType::UnitConversion_optional& LinearUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void LinearUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void LinearUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void LinearUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // LinearValueType
    // 

    const LinearValueType::linearUnit_optional& LinearValueType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    LinearValueType::linearUnit_optional& LinearValueType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void LinearValueType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void LinearValueType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void LinearValueType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }


    // ActualLinearValueType
    // 

    const ActualLinearValueType::linearUnit_optional& ActualLinearValueType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    ActualLinearValueType::linearUnit_optional& ActualLinearValueType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void ActualLinearValueType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void ActualLinearValueType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void ActualLinearValueType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }


    // MassUnitType
    // 

    const MassUnitType::SIUnitName_optional& MassUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    MassUnitType::SIUnitName_optional& MassUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void MassUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void MassUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void MassUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const MassUnitType::SIUnitName_type& MassUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const MassUnitType::UnitName_type& MassUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    MassUnitType::UnitName_type& MassUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void MassUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void MassUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const MassUnitType::UnitConversion_optional& MassUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    MassUnitType::UnitConversion_optional& MassUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void MassUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void MassUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void MassUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // MassValueType
    // 

    const MassValueType::massUnit_optional& MassValueType::
    massUnit () const
    {
      return this->massUnit_;
    }

    MassValueType::massUnit_optional& MassValueType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void MassValueType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void MassValueType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void MassValueType::
    massUnit (::std::auto_ptr< massUnit_type > x)
    {
      this->massUnit_.set (x);
    }


    // ActualMassValueType
    // 

    const ActualMassValueType::massUnit_optional& ActualMassValueType::
    massUnit () const
    {
      return this->massUnit_;
    }

    ActualMassValueType::massUnit_optional& ActualMassValueType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void ActualMassValueType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void ActualMassValueType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void ActualMassValueType::
    massUnit (::std::auto_ptr< massUnit_type > x)
    {
      this->massUnit_.set (x);
    }


    // PressureUnitType
    // 

    const PressureUnitType::SIUnitName_optional& PressureUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    PressureUnitType::SIUnitName_optional& PressureUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void PressureUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void PressureUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void PressureUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const PressureUnitType::SIUnitName_type& PressureUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const PressureUnitType::UnitName_type& PressureUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    PressureUnitType::UnitName_type& PressureUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void PressureUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void PressureUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const PressureUnitType::UnitConversion_optional& PressureUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    PressureUnitType::UnitConversion_optional& PressureUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void PressureUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void PressureUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void PressureUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // PressureValueType
    // 

    const PressureValueType::pressureUnit_optional& PressureValueType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    PressureValueType::pressureUnit_optional& PressureValueType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void PressureValueType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void PressureValueType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void PressureValueType::
    pressureUnit (::std::auto_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (x);
    }


    // ActualPressureValueType
    // 

    const ActualPressureValueType::pressureUnit_optional& ActualPressureValueType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    ActualPressureValueType::pressureUnit_optional& ActualPressureValueType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void ActualPressureValueType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void ActualPressureValueType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void ActualPressureValueType::
    pressureUnit (::std::auto_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (x);
    }


    // SpeedUnitType
    // 

    const SpeedUnitType::SIUnitName_optional& SpeedUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    SpeedUnitType::SIUnitName_optional& SpeedUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void SpeedUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void SpeedUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void SpeedUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const SpeedUnitType::SIUnitName_type& SpeedUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const SpeedUnitType::UnitName_type& SpeedUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    SpeedUnitType::UnitName_type& SpeedUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void SpeedUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void SpeedUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const SpeedUnitType::UnitConversion_optional& SpeedUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    SpeedUnitType::UnitConversion_optional& SpeedUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void SpeedUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void SpeedUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void SpeedUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // SpeedValueType
    // 

    const SpeedValueType::speedUnit_optional& SpeedValueType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    SpeedValueType::speedUnit_optional& SpeedValueType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void SpeedValueType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void SpeedValueType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void SpeedValueType::
    speedUnit (::std::auto_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (x);
    }


    // ActualSpeedValueType
    // 

    const ActualSpeedValueType::speedUnit_optional& ActualSpeedValueType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    ActualSpeedValueType::speedUnit_optional& ActualSpeedValueType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void ActualSpeedValueType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void ActualSpeedValueType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void ActualSpeedValueType::
    speedUnit (::std::auto_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (x);
    }


    // TemperatureUnitType
    // 

    const TemperatureUnitType::SIUnitName_optional& TemperatureUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    TemperatureUnitType::SIUnitName_optional& TemperatureUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void TemperatureUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void TemperatureUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void TemperatureUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const TemperatureUnitType::SIUnitName_type& TemperatureUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const TemperatureUnitType::UnitName_type& TemperatureUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    TemperatureUnitType::UnitName_type& TemperatureUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void TemperatureUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void TemperatureUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const TemperatureUnitType::UnitConversion_optional& TemperatureUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    TemperatureUnitType::UnitConversion_optional& TemperatureUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void TemperatureUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void TemperatureUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void TemperatureUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // TemperatureValueType
    // 

    const TemperatureValueType::temperatureUnit_optional& TemperatureValueType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    TemperatureValueType::temperatureUnit_optional& TemperatureValueType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void TemperatureValueType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void TemperatureValueType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void TemperatureValueType::
    temperatureUnit (::std::auto_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (x);
    }


    // ActualTemperatureValueType
    // 

    const ActualTemperatureValueType::temperatureUnit_optional& ActualTemperatureValueType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    ActualTemperatureValueType::temperatureUnit_optional& ActualTemperatureValueType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void ActualTemperatureValueType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void ActualTemperatureValueType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void ActualTemperatureValueType::
    temperatureUnit (::std::auto_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (x);
    }


    // TimeUnitType
    // 

    const TimeUnitType::SIUnitName_optional& TimeUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    TimeUnitType::SIUnitName_optional& TimeUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void TimeUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void TimeUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void TimeUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const TimeUnitType::SIUnitName_type& TimeUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const TimeUnitType::UnitName_type& TimeUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    TimeUnitType::UnitName_type& TimeUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void TimeUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void TimeUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const TimeUnitType::UnitConversion_optional& TimeUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    TimeUnitType::UnitConversion_optional& TimeUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void TimeUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void TimeUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void TimeUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // TimeValueType
    // 

    const TimeValueType::timeUnit_optional& TimeValueType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    TimeValueType::timeUnit_optional& TimeValueType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void TimeValueType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void TimeValueType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void TimeValueType::
    timeUnit (::std::auto_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (x);
    }


    // ActualTimeValueType
    // 

    const ActualTimeValueType::timeUnit_optional& ActualTimeValueType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    ActualTimeValueType::timeUnit_optional& ActualTimeValueType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void ActualTimeValueType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void ActualTimeValueType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void ActualTimeValueType::
    timeUnit (::std::auto_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (x);
    }


    // PrimaryUnitsType
    // 

    const PrimaryUnitsType::AreaUnit_optional& PrimaryUnitsType::
    AreaUnit () const
    {
      return this->AreaUnit_;
    }

    PrimaryUnitsType::AreaUnit_optional& PrimaryUnitsType::
    AreaUnit ()
    {
      return this->AreaUnit_;
    }

    void PrimaryUnitsType::
    AreaUnit (const AreaUnit_type& x)
    {
      this->AreaUnit_.set (x);
    }

    void PrimaryUnitsType::
    AreaUnit (const AreaUnit_optional& x)
    {
      this->AreaUnit_ = x;
    }

    void PrimaryUnitsType::
    AreaUnit (::std::auto_ptr< AreaUnit_type > x)
    {
      this->AreaUnit_.set (x);
    }

    const PrimaryUnitsType::AngularUnit_optional& PrimaryUnitsType::
    AngularUnit () const
    {
      return this->AngularUnit_;
    }

    PrimaryUnitsType::AngularUnit_optional& PrimaryUnitsType::
    AngularUnit ()
    {
      return this->AngularUnit_;
    }

    void PrimaryUnitsType::
    AngularUnit (const AngularUnit_type& x)
    {
      this->AngularUnit_.set (x);
    }

    void PrimaryUnitsType::
    AngularUnit (const AngularUnit_optional& x)
    {
      this->AngularUnit_ = x;
    }

    void PrimaryUnitsType::
    AngularUnit (::std::auto_ptr< AngularUnit_type > x)
    {
      this->AngularUnit_.set (x);
    }

    const PrimaryUnitsType::ForceUnit_optional& PrimaryUnitsType::
    ForceUnit () const
    {
      return this->ForceUnit_;
    }

    PrimaryUnitsType::ForceUnit_optional& PrimaryUnitsType::
    ForceUnit ()
    {
      return this->ForceUnit_;
    }

    void PrimaryUnitsType::
    ForceUnit (const ForceUnit_type& x)
    {
      this->ForceUnit_.set (x);
    }

    void PrimaryUnitsType::
    ForceUnit (const ForceUnit_optional& x)
    {
      this->ForceUnit_ = x;
    }

    void PrimaryUnitsType::
    ForceUnit (::std::auto_ptr< ForceUnit_type > x)
    {
      this->ForceUnit_.set (x);
    }

    const PrimaryUnitsType::LinearUnit_optional& PrimaryUnitsType::
    LinearUnit () const
    {
      return this->LinearUnit_;
    }

    PrimaryUnitsType::LinearUnit_optional& PrimaryUnitsType::
    LinearUnit ()
    {
      return this->LinearUnit_;
    }

    void PrimaryUnitsType::
    LinearUnit (const LinearUnit_type& x)
    {
      this->LinearUnit_.set (x);
    }

    void PrimaryUnitsType::
    LinearUnit (const LinearUnit_optional& x)
    {
      this->LinearUnit_ = x;
    }

    void PrimaryUnitsType::
    LinearUnit (::std::auto_ptr< LinearUnit_type > x)
    {
      this->LinearUnit_.set (x);
    }

    const PrimaryUnitsType::MassUnit_optional& PrimaryUnitsType::
    MassUnit () const
    {
      return this->MassUnit_;
    }

    PrimaryUnitsType::MassUnit_optional& PrimaryUnitsType::
    MassUnit ()
    {
      return this->MassUnit_;
    }

    void PrimaryUnitsType::
    MassUnit (const MassUnit_type& x)
    {
      this->MassUnit_.set (x);
    }

    void PrimaryUnitsType::
    MassUnit (const MassUnit_optional& x)
    {
      this->MassUnit_ = x;
    }

    void PrimaryUnitsType::
    MassUnit (::std::auto_ptr< MassUnit_type > x)
    {
      this->MassUnit_.set (x);
    }

    const PrimaryUnitsType::PressureUnit_optional& PrimaryUnitsType::
    PressureUnit () const
    {
      return this->PressureUnit_;
    }

    PrimaryUnitsType::PressureUnit_optional& PrimaryUnitsType::
    PressureUnit ()
    {
      return this->PressureUnit_;
    }

    void PrimaryUnitsType::
    PressureUnit (const PressureUnit_type& x)
    {
      this->PressureUnit_.set (x);
    }

    void PrimaryUnitsType::
    PressureUnit (const PressureUnit_optional& x)
    {
      this->PressureUnit_ = x;
    }

    void PrimaryUnitsType::
    PressureUnit (::std::auto_ptr< PressureUnit_type > x)
    {
      this->PressureUnit_.set (x);
    }

    const PrimaryUnitsType::SpeedUnit_optional& PrimaryUnitsType::
    SpeedUnit () const
    {
      return this->SpeedUnit_;
    }

    PrimaryUnitsType::SpeedUnit_optional& PrimaryUnitsType::
    SpeedUnit ()
    {
      return this->SpeedUnit_;
    }

    void PrimaryUnitsType::
    SpeedUnit (const SpeedUnit_type& x)
    {
      this->SpeedUnit_.set (x);
    }

    void PrimaryUnitsType::
    SpeedUnit (const SpeedUnit_optional& x)
    {
      this->SpeedUnit_ = x;
    }

    void PrimaryUnitsType::
    SpeedUnit (::std::auto_ptr< SpeedUnit_type > x)
    {
      this->SpeedUnit_.set (x);
    }

    const PrimaryUnitsType::TemperatureUnit_optional& PrimaryUnitsType::
    TemperatureUnit () const
    {
      return this->TemperatureUnit_;
    }

    PrimaryUnitsType::TemperatureUnit_optional& PrimaryUnitsType::
    TemperatureUnit ()
    {
      return this->TemperatureUnit_;
    }

    void PrimaryUnitsType::
    TemperatureUnit (const TemperatureUnit_type& x)
    {
      this->TemperatureUnit_.set (x);
    }

    void PrimaryUnitsType::
    TemperatureUnit (const TemperatureUnit_optional& x)
    {
      this->TemperatureUnit_ = x;
    }

    void PrimaryUnitsType::
    TemperatureUnit (::std::auto_ptr< TemperatureUnit_type > x)
    {
      this->TemperatureUnit_.set (x);
    }

    const PrimaryUnitsType::TimeUnit_optional& PrimaryUnitsType::
    TimeUnit () const
    {
      return this->TimeUnit_;
    }

    PrimaryUnitsType::TimeUnit_optional& PrimaryUnitsType::
    TimeUnit ()
    {
      return this->TimeUnit_;
    }

    void PrimaryUnitsType::
    TimeUnit (const TimeUnit_type& x)
    {
      this->TimeUnit_.set (x);
    }

    void PrimaryUnitsType::
    TimeUnit (const TimeUnit_optional& x)
    {
      this->TimeUnit_ = x;
    }

    void PrimaryUnitsType::
    TimeUnit (::std::auto_ptr< TimeUnit_type > x)
    {
      this->TimeUnit_.set (x);
    }


    // OtherUnitsType
    // 

    const OtherUnitsType::AreaUnit_sequence& OtherUnitsType::
    AreaUnit () const
    {
      return this->AreaUnit_;
    }

    OtherUnitsType::AreaUnit_sequence& OtherUnitsType::
    AreaUnit ()
    {
      return this->AreaUnit_;
    }

    void OtherUnitsType::
    AreaUnit (const AreaUnit_sequence& s)
    {
      this->AreaUnit_ = s;
    }

    const OtherUnitsType::AngularUnit_sequence& OtherUnitsType::
    AngularUnit () const
    {
      return this->AngularUnit_;
    }

    OtherUnitsType::AngularUnit_sequence& OtherUnitsType::
    AngularUnit ()
    {
      return this->AngularUnit_;
    }

    void OtherUnitsType::
    AngularUnit (const AngularUnit_sequence& s)
    {
      this->AngularUnit_ = s;
    }

    const OtherUnitsType::ForceUnit_sequence& OtherUnitsType::
    ForceUnit () const
    {
      return this->ForceUnit_;
    }

    OtherUnitsType::ForceUnit_sequence& OtherUnitsType::
    ForceUnit ()
    {
      return this->ForceUnit_;
    }

    void OtherUnitsType::
    ForceUnit (const ForceUnit_sequence& s)
    {
      this->ForceUnit_ = s;
    }

    const OtherUnitsType::LinearUnit_sequence& OtherUnitsType::
    LinearUnit () const
    {
      return this->LinearUnit_;
    }

    OtherUnitsType::LinearUnit_sequence& OtherUnitsType::
    LinearUnit ()
    {
      return this->LinearUnit_;
    }

    void OtherUnitsType::
    LinearUnit (const LinearUnit_sequence& s)
    {
      this->LinearUnit_ = s;
    }

    const OtherUnitsType::MassUnit_sequence& OtherUnitsType::
    MassUnit () const
    {
      return this->MassUnit_;
    }

    OtherUnitsType::MassUnit_sequence& OtherUnitsType::
    MassUnit ()
    {
      return this->MassUnit_;
    }

    void OtherUnitsType::
    MassUnit (const MassUnit_sequence& s)
    {
      this->MassUnit_ = s;
    }

    const OtherUnitsType::PressureUnit_sequence& OtherUnitsType::
    PressureUnit () const
    {
      return this->PressureUnit_;
    }

    OtherUnitsType::PressureUnit_sequence& OtherUnitsType::
    PressureUnit ()
    {
      return this->PressureUnit_;
    }

    void OtherUnitsType::
    PressureUnit (const PressureUnit_sequence& s)
    {
      this->PressureUnit_ = s;
    }

    const OtherUnitsType::SpeedUnit_sequence& OtherUnitsType::
    SpeedUnit () const
    {
      return this->SpeedUnit_;
    }

    OtherUnitsType::SpeedUnit_sequence& OtherUnitsType::
    SpeedUnit ()
    {
      return this->SpeedUnit_;
    }

    void OtherUnitsType::
    SpeedUnit (const SpeedUnit_sequence& s)
    {
      this->SpeedUnit_ = s;
    }

    const OtherUnitsType::TemperatureUnit_sequence& OtherUnitsType::
    TemperatureUnit () const
    {
      return this->TemperatureUnit_;
    }

    OtherUnitsType::TemperatureUnit_sequence& OtherUnitsType::
    TemperatureUnit ()
    {
      return this->TemperatureUnit_;
    }

    void OtherUnitsType::
    TemperatureUnit (const TemperatureUnit_sequence& s)
    {
      this->TemperatureUnit_ = s;
    }

    const OtherUnitsType::TimeUnit_sequence& OtherUnitsType::
    TimeUnit () const
    {
      return this->TimeUnit_;
    }

    OtherUnitsType::TimeUnit_sequence& OtherUnitsType::
    TimeUnit ()
    {
      return this->TimeUnit_;
    }

    void OtherUnitsType::
    TimeUnit (const TimeUnit_sequence& s)
    {
      this->TimeUnit_ = s;
    }


    // UserDefinedUnitType
    // 

    const UserDefinedUnitType::WhatIsMeasured_type& UserDefinedUnitType::
    WhatIsMeasured () const
    {
      return this->WhatIsMeasured_.get ();
    }

    UserDefinedUnitType::WhatIsMeasured_type& UserDefinedUnitType::
    WhatIsMeasured ()
    {
      return this->WhatIsMeasured_.get ();
    }

    void UserDefinedUnitType::
    WhatIsMeasured (const WhatIsMeasured_type& x)
    {
      this->WhatIsMeasured_.set (x);
    }

    void UserDefinedUnitType::
    WhatIsMeasured (::std::auto_ptr< WhatIsMeasured_type > x)
    {
      this->WhatIsMeasured_.set (x);
    }

    const UserDefinedUnitType::UnitName_type& UserDefinedUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    UserDefinedUnitType::UnitName_type& UserDefinedUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void UserDefinedUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void UserDefinedUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const UserDefinedUnitType::StandardName_optional& UserDefinedUnitType::
    StandardName () const
    {
      return this->StandardName_;
    }

    UserDefinedUnitType::StandardName_optional& UserDefinedUnitType::
    StandardName ()
    {
      return this->StandardName_;
    }

    void UserDefinedUnitType::
    StandardName (const StandardName_type& x)
    {
      this->StandardName_.set (x);
    }

    void UserDefinedUnitType::
    StandardName (const StandardName_optional& x)
    {
      this->StandardName_ = x;
    }

    void UserDefinedUnitType::
    StandardName (::std::auto_ptr< StandardName_type > x)
    {
      this->StandardName_.set (x);
    }


    // UserDefinedUnitValueType
    // 

    const UserDefinedUnitValueType::unitName_type& UserDefinedUnitValueType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    UserDefinedUnitValueType::unitName_type& UserDefinedUnitValueType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void UserDefinedUnitValueType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void UserDefinedUnitValueType::
    unitName (::std::auto_ptr< unitName_type > x)
    {
      this->unitName_.set (x);
    }


    // ActualUserDefinedUnitValueType
    // 

    const ActualUserDefinedUnitValueType::unitName_type& ActualUserDefinedUnitValueType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    ActualUserDefinedUnitValueType::unitName_type& ActualUserDefinedUnitValueType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void ActualUserDefinedUnitValueType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void ActualUserDefinedUnitValueType::
    unitName (::std::auto_ptr< unitName_type > x)
    {
      this->unitName_.set (x);
    }


    // UserDefinedUnitsType
    // 

    const UserDefinedUnitsType::UserDefinedUnit_sequence& UserDefinedUnitsType::
    UserDefinedUnit () const
    {
      return this->UserDefinedUnit_;
    }

    UserDefinedUnitsType::UserDefinedUnit_sequence& UserDefinedUnitsType::
    UserDefinedUnit ()
    {
      return this->UserDefinedUnit_;
    }

    void UserDefinedUnitsType::
    UserDefinedUnit (const UserDefinedUnit_sequence& s)
    {
      this->UserDefinedUnit_ = s;
    }


    // FileUnitsType
    // 

    const FileUnitsType::PrimaryUnits_type& FileUnitsType::
    PrimaryUnits () const
    {
      return this->PrimaryUnits_.get ();
    }

    FileUnitsType::PrimaryUnits_type& FileUnitsType::
    PrimaryUnits ()
    {
      return this->PrimaryUnits_.get ();
    }

    void FileUnitsType::
    PrimaryUnits (const PrimaryUnits_type& x)
    {
      this->PrimaryUnits_.set (x);
    }

    void FileUnitsType::
    PrimaryUnits (::std::auto_ptr< PrimaryUnits_type > x)
    {
      this->PrimaryUnits_.set (x);
    }

    const FileUnitsType::OtherUnits_optional& FileUnitsType::
    OtherUnits () const
    {
      return this->OtherUnits_;
    }

    FileUnitsType::OtherUnits_optional& FileUnitsType::
    OtherUnits ()
    {
      return this->OtherUnits_;
    }

    void FileUnitsType::
    OtherUnits (const OtherUnits_type& x)
    {
      this->OtherUnits_.set (x);
    }

    void FileUnitsType::
    OtherUnits (const OtherUnits_optional& x)
    {
      this->OtherUnits_ = x;
    }

    void FileUnitsType::
    OtherUnits (::std::auto_ptr< OtherUnits_type > x)
    {
      this->OtherUnits_.set (x);
    }

    const FileUnitsType::UserDefinedUnits_optional& FileUnitsType::
    UserDefinedUnits () const
    {
      return this->UserDefinedUnits_;
    }

    FileUnitsType::UserDefinedUnits_optional& FileUnitsType::
    UserDefinedUnits ()
    {
      return this->UserDefinedUnits_;
    }

    void FileUnitsType::
    UserDefinedUnits (const UserDefinedUnits_type& x)
    {
      this->UserDefinedUnits_.set (x);
    }

    void FileUnitsType::
    UserDefinedUnits (const UserDefinedUnits_optional& x)
    {
      this->UserDefinedUnits_ = x;
    }

    void FileUnitsType::
    UserDefinedUnits (::std::auto_ptr< UserDefinedUnits_type > x)
    {
      this->UserDefinedUnits_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // PositiveDecimalType
    //

    PositiveDecimalType::
    PositiveDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const PositiveDecimalType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    PositiveDecimalType* PositiveDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PositiveDecimalType (*this, f, c);
    }

    PositiveDecimalType::
    ~PositiveDecimalType ()
    {
    }

    // NonNegativeDecimalType
    //

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const NonNegativeDecimalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    NonNegativeDecimalType* NonNegativeDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonNegativeDecimalType (*this, f, c);
    }

    NonNegativeDecimalType::
    ~NonNegativeDecimalType ()
    {
    }

    // UnitConversionType
    //

    UnitConversionType::
    UnitConversionType (const Factor_type& Factor)
    : ::xml_schema::type (),
      Factor_ (Factor, this),
      Offset_ (this)
    {
    }

    UnitConversionType::
    UnitConversionType (const UnitConversionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Factor_ (x.Factor_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    UnitConversionType::
    UnitConversionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Factor_ (this),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UnitConversionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Factor
        //
        if (n.name () == "Factor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Factor_type > r (
            Factor_traits::create (i, f, this));

          if (!Factor_.present ())
          {
            this->Factor_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->Offset_)
          {
            this->Offset_.set (Offset_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Factor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Factor",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    UnitConversionType* UnitConversionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitConversionType (*this, f, c);
    }

    UnitConversionType& UnitConversionType::
    operator= (const UnitConversionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Factor_ = x.Factor_;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    UnitConversionType::
    ~UnitConversionType ()
    {
    }

    // SpecifiedDecimalType
    //

    SpecifiedDecimalType::
    SpecifiedDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      decimalPlaces_ (this),
      significantFigures_ (this)
    {
    }

    SpecifiedDecimalType::
    SpecifiedDecimalType (const SpecifiedDecimalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this)
    {
    }

    SpecifiedDecimalType::
    SpecifiedDecimalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      decimalPlaces_ (this),
      significantFigures_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SpecifiedDecimalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }
      }
    }

    SpecifiedDecimalType* SpecifiedDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpecifiedDecimalType (*this, f, c);
    }

    SpecifiedDecimalType& SpecifiedDecimalType::
    operator= (const SpecifiedDecimalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
      }

      return *this;
    }

    SpecifiedDecimalType::
    ~SpecifiedDecimalType ()
    {
    }

    // ActualDecimalType
    //

    ActualDecimalType::
    ActualDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      combinedUncertainty_ (this),
      meanError_ (this)
    {
    }

    ActualDecimalType::
    ActualDecimalType (const ActualDecimalType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this)
    {
    }

    ActualDecimalType::
    ActualDecimalType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      combinedUncertainty_ (this),
      meanError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualDecimalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualDecimalType* ActualDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualDecimalType (*this, f, c);
    }

    ActualDecimalType& ActualDecimalType::
    operator= (const ActualDecimalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
      }

      return *this;
    }

    ActualDecimalType::
    ~ActualDecimalType ()
    {
    }

    // AngularUnitType
    //

    const AngularUnitType::SIUnitName_type AngularUnitType::SIUnitName_default_value_ (
      "radian");

    AngularUnitType::
    AngularUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    AngularUnitType::
    AngularUnitType (const AngularUnitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    AngularUnitType::
    AngularUnitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AngularUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AngularUnitType* AngularUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularUnitType (*this, f, c);
    }

    AngularUnitType& AngularUnitType::
    operator= (const AngularUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    AngularUnitType::
    ~AngularUnitType ()
    {
    }

    // AngularValueType
    //

    AngularValueType::
    AngularValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      angularUnit_ (this)
    {
    }

    AngularValueType::
    AngularValueType (const AngularValueType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    AngularValueType::
    AngularValueType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AngularValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    AngularValueType* AngularValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularValueType (*this, f, c);
    }

    AngularValueType& AngularValueType::
    operator= (const AngularValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    AngularValueType::
    ~AngularValueType ()
    {
    }

    // ActualAngularValueType
    //

    ActualAngularValueType::
    ActualAngularValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      angularUnit_ (this)
    {
    }

    ActualAngularValueType::
    ActualAngularValueType (const ActualAngularValueType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    ActualAngularValueType::
    ActualAngularValueType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualAngularValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualAngularValueType* ActualAngularValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualAngularValueType (*this, f, c);
    }

    ActualAngularValueType& ActualAngularValueType::
    operator= (const ActualAngularValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    ActualAngularValueType::
    ~ActualAngularValueType ()
    {
    }

    // AreaUnitType
    //

    const AreaUnitType::SIUnitName_type AreaUnitType::SIUnitName_default_value_ (
      "square meter");

    AreaUnitType::
    AreaUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    AreaUnitType::
    AreaUnitType (const AreaUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    AreaUnitType::
    AreaUnitType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AreaUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AreaUnitType* AreaUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaUnitType (*this, f, c);
    }

    AreaUnitType& AreaUnitType::
    operator= (const AreaUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    AreaUnitType::
    ~AreaUnitType ()
    {
    }

    // AreaValueType
    //

    AreaValueType::
    AreaValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      areaUnit_ (this)
    {
    }

    AreaValueType::
    AreaValueType (const AreaValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    AreaValueType::
    AreaValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AreaValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    AreaValueType* AreaValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaValueType (*this, f, c);
    }

    AreaValueType& AreaValueType::
    operator= (const AreaValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    AreaValueType::
    ~AreaValueType ()
    {
    }

    // ActualAreaValueType
    //

    ActualAreaValueType::
    ActualAreaValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      areaUnit_ (this)
    {
    }

    ActualAreaValueType::
    ActualAreaValueType (const ActualAreaValueType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    ActualAreaValueType::
    ActualAreaValueType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualAreaValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualAreaValueType* ActualAreaValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualAreaValueType (*this, f, c);
    }

    ActualAreaValueType& ActualAreaValueType::
    operator= (const ActualAreaValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    ActualAreaValueType::
    ~ActualAreaValueType ()
    {
    }

    // ForceUnitType
    //

    const ForceUnitType::SIUnitName_type ForceUnitType::SIUnitName_default_value_ (
      "newton");

    ForceUnitType::
    ForceUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    ForceUnitType::
    ForceUnitType (const ForceUnitType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    ForceUnitType::
    ForceUnitType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ForceUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ForceUnitType* ForceUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceUnitType (*this, f, c);
    }

    ForceUnitType& ForceUnitType::
    operator= (const ForceUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    ForceUnitType::
    ~ForceUnitType ()
    {
    }

    // ForceValueType
    //

    ForceValueType::
    ForceValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      forceUnit_ (this)
    {
    }

    ForceValueType::
    ForceValueType (const ForceValueType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    ForceValueType::
    ForceValueType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ForceValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ForceValueType* ForceValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceValueType (*this, f, c);
    }

    ForceValueType& ForceValueType::
    operator= (const ForceValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    ForceValueType::
    ~ForceValueType ()
    {
    }

    // ActualForceValueType
    //

    ActualForceValueType::
    ActualForceValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      forceUnit_ (this)
    {
    }

    ActualForceValueType::
    ActualForceValueType (const ActualForceValueType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    ActualForceValueType::
    ActualForceValueType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualForceValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualForceValueType* ActualForceValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualForceValueType (*this, f, c);
    }

    ActualForceValueType& ActualForceValueType::
    operator= (const ActualForceValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    ActualForceValueType::
    ~ActualForceValueType ()
    {
    }

    // LinearUnitType
    //

    const LinearUnitType::SIUnitName_type LinearUnitType::SIUnitName_default_value_ (
      "meter");

    LinearUnitType::
    LinearUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    LinearUnitType::
    LinearUnitType (const LinearUnitType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    LinearUnitType::
    LinearUnitType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LinearUnitType* LinearUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearUnitType (*this, f, c);
    }

    LinearUnitType& LinearUnitType::
    operator= (const LinearUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    LinearUnitType::
    ~LinearUnitType ()
    {
    }

    // LinearValueType
    //

    LinearValueType::
    LinearValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      linearUnit_ (this)
    {
    }

    LinearValueType::
    LinearValueType (const LinearValueType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    LinearValueType::
    LinearValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LinearValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    LinearValueType* LinearValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearValueType (*this, f, c);
    }

    LinearValueType& LinearValueType::
    operator= (const LinearValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    LinearValueType::
    ~LinearValueType ()
    {
    }

    // ActualLinearValueType
    //

    ActualLinearValueType::
    ActualLinearValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      linearUnit_ (this)
    {
    }

    ActualLinearValueType::
    ActualLinearValueType (const ActualLinearValueType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    ActualLinearValueType::
    ActualLinearValueType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualLinearValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualLinearValueType* ActualLinearValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualLinearValueType (*this, f, c);
    }

    ActualLinearValueType& ActualLinearValueType::
    operator= (const ActualLinearValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    ActualLinearValueType::
    ~ActualLinearValueType ()
    {
    }

    // MassUnitType
    //

    const MassUnitType::SIUnitName_type MassUnitType::SIUnitName_default_value_ (
      "kilogram");

    MassUnitType::
    MassUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    MassUnitType::
    MassUnitType (const MassUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    MassUnitType::
    MassUnitType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MassUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MassUnitType* MassUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassUnitType (*this, f, c);
    }

    MassUnitType& MassUnitType::
    operator= (const MassUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    MassUnitType::
    ~MassUnitType ()
    {
    }

    // MassValueType
    //

    MassValueType::
    MassValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      massUnit_ (this)
    {
    }

    MassValueType::
    MassValueType (const MassValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    MassValueType::
    MassValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MassValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MassValueType* MassValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassValueType (*this, f, c);
    }

    MassValueType& MassValueType::
    operator= (const MassValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    MassValueType::
    ~MassValueType ()
    {
    }

    // ActualMassValueType
    //

    ActualMassValueType::
    ActualMassValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      massUnit_ (this)
    {
    }

    ActualMassValueType::
    ActualMassValueType (const ActualMassValueType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    ActualMassValueType::
    ActualMassValueType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualMassValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualMassValueType* ActualMassValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualMassValueType (*this, f, c);
    }

    ActualMassValueType& ActualMassValueType::
    operator= (const ActualMassValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    ActualMassValueType::
    ~ActualMassValueType ()
    {
    }

    // PressureUnitType
    //

    const PressureUnitType::SIUnitName_type PressureUnitType::SIUnitName_default_value_ (
      "pascal");

    PressureUnitType::
    PressureUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    PressureUnitType::
    PressureUnitType (const PressureUnitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    PressureUnitType::
    PressureUnitType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PressureUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PressureUnitType* PressureUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureUnitType (*this, f, c);
    }

    PressureUnitType& PressureUnitType::
    operator= (const PressureUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    PressureUnitType::
    ~PressureUnitType ()
    {
    }

    // PressureValueType
    //

    PressureValueType::
    PressureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      pressureUnit_ (this)
    {
    }

    PressureValueType::
    PressureValueType (const PressureValueType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    PressureValueType::
    PressureValueType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void PressureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    PressureValueType* PressureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureValueType (*this, f, c);
    }

    PressureValueType& PressureValueType::
    operator= (const PressureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    PressureValueType::
    ~PressureValueType ()
    {
    }

    // ActualPressureValueType
    //

    ActualPressureValueType::
    ActualPressureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      pressureUnit_ (this)
    {
    }

    ActualPressureValueType::
    ActualPressureValueType (const ActualPressureValueType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    ActualPressureValueType::
    ActualPressureValueType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualPressureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualPressureValueType* ActualPressureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualPressureValueType (*this, f, c);
    }

    ActualPressureValueType& ActualPressureValueType::
    operator= (const ActualPressureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    ActualPressureValueType::
    ~ActualPressureValueType ()
    {
    }

    // SpeedUnitType
    //

    const SpeedUnitType::SIUnitName_type SpeedUnitType::SIUnitName_default_value_ (
      "meter per second");

    SpeedUnitType::
    SpeedUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    SpeedUnitType::
    SpeedUnitType (const SpeedUnitType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    SpeedUnitType::
    SpeedUnitType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SpeedUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SpeedUnitType* SpeedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedUnitType (*this, f, c);
    }

    SpeedUnitType& SpeedUnitType::
    operator= (const SpeedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    SpeedUnitType::
    ~SpeedUnitType ()
    {
    }

    // SpeedValueType
    //

    SpeedValueType::
    SpeedValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      speedUnit_ (this)
    {
    }

    SpeedValueType::
    SpeedValueType (const SpeedValueType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    SpeedValueType::
    SpeedValueType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SpeedValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SpeedValueType* SpeedValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedValueType (*this, f, c);
    }

    SpeedValueType& SpeedValueType::
    operator= (const SpeedValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    SpeedValueType::
    ~SpeedValueType ()
    {
    }

    // ActualSpeedValueType
    //

    ActualSpeedValueType::
    ActualSpeedValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      speedUnit_ (this)
    {
    }

    ActualSpeedValueType::
    ActualSpeedValueType (const ActualSpeedValueType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    ActualSpeedValueType::
    ActualSpeedValueType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualSpeedValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualSpeedValueType* ActualSpeedValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualSpeedValueType (*this, f, c);
    }

    ActualSpeedValueType& ActualSpeedValueType::
    operator= (const ActualSpeedValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    ActualSpeedValueType::
    ~ActualSpeedValueType ()
    {
    }

    // TemperatureUnitType
    //

    const TemperatureUnitType::SIUnitName_type TemperatureUnitType::SIUnitName_default_value_ (
      "kelvin");

    TemperatureUnitType::
    TemperatureUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    TemperatureUnitType::
    TemperatureUnitType (const TemperatureUnitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    TemperatureUnitType::
    TemperatureUnitType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperatureUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TemperatureUnitType* TemperatureUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureUnitType (*this, f, c);
    }

    TemperatureUnitType& TemperatureUnitType::
    operator= (const TemperatureUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    TemperatureUnitType::
    ~TemperatureUnitType ()
    {
    }

    // TemperatureValueType
    //

    TemperatureValueType::
    TemperatureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      temperatureUnit_ (this)
    {
    }

    TemperatureValueType::
    TemperatureValueType (const TemperatureValueType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    TemperatureValueType::
    TemperatureValueType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TemperatureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    TemperatureValueType* TemperatureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureValueType (*this, f, c);
    }

    TemperatureValueType& TemperatureValueType::
    operator= (const TemperatureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    TemperatureValueType::
    ~TemperatureValueType ()
    {
    }

    // ActualTemperatureValueType
    //

    ActualTemperatureValueType::
    ActualTemperatureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      temperatureUnit_ (this)
    {
    }

    ActualTemperatureValueType::
    ActualTemperatureValueType (const ActualTemperatureValueType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    ActualTemperatureValueType::
    ActualTemperatureValueType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualTemperatureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualTemperatureValueType* ActualTemperatureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualTemperatureValueType (*this, f, c);
    }

    ActualTemperatureValueType& ActualTemperatureValueType::
    operator= (const ActualTemperatureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    ActualTemperatureValueType::
    ~ActualTemperatureValueType ()
    {
    }

    // TimeUnitType
    //

    const TimeUnitType::SIUnitName_type TimeUnitType::SIUnitName_default_value_ (
      "second");

    TimeUnitType::
    TimeUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    TimeUnitType::
    TimeUnitType (const TimeUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    TimeUnitType::
    TimeUnitType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TimeUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TimeUnitType* TimeUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeUnitType (*this, f, c);
    }

    TimeUnitType& TimeUnitType::
    operator= (const TimeUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    TimeUnitType::
    ~TimeUnitType ()
    {
    }

    // TimeValueType
    //

    TimeValueType::
    TimeValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      timeUnit_ (this)
    {
    }

    TimeValueType::
    TimeValueType (const TimeValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    TimeValueType::
    TimeValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TimeValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    TimeValueType* TimeValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeValueType (*this, f, c);
    }

    TimeValueType& TimeValueType::
    operator= (const TimeValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    TimeValueType::
    ~TimeValueType ()
    {
    }

    // ActualTimeValueType
    //

    ActualTimeValueType::
    ActualTimeValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      timeUnit_ (this)
    {
    }

    ActualTimeValueType::
    ActualTimeValueType (const ActualTimeValueType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    ActualTimeValueType::
    ActualTimeValueType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualTimeValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualTimeValueType* ActualTimeValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualTimeValueType (*this, f, c);
    }

    ActualTimeValueType& ActualTimeValueType::
    operator= (const ActualTimeValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    ActualTimeValueType::
    ~ActualTimeValueType ()
    {
    }

    // PrimaryUnitsType
    //

    PrimaryUnitsType::
    PrimaryUnitsType ()
    : ::xml_schema::type (),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this)
    {
    }

    PrimaryUnitsType::
    PrimaryUnitsType (const PrimaryUnitsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaUnit_ (x.AreaUnit_, f, this),
      AngularUnit_ (x.AngularUnit_, f, this),
      ForceUnit_ (x.ForceUnit_, f, this),
      LinearUnit_ (x.LinearUnit_, f, this),
      MassUnit_ (x.MassUnit_, f, this),
      PressureUnit_ (x.PressureUnit_, f, this),
      SpeedUnit_ (x.SpeedUnit_, f, this),
      TemperatureUnit_ (x.TemperatureUnit_, f, this),
      TimeUnit_ (x.TimeUnit_, f, this)
    {
    }

    PrimaryUnitsType::
    PrimaryUnitsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PrimaryUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AreaUnit
        //
        if (n.name () == "AreaUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AreaUnit_type > r (
            AreaUnit_traits::create (i, f, this));

          if (!this->AreaUnit_)
          {
            this->AreaUnit_.set (r);
            continue;
          }
        }

        // AngularUnit
        //
        if (n.name () == "AngularUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AngularUnit_type > r (
            AngularUnit_traits::create (i, f, this));

          if (!this->AngularUnit_)
          {
            this->AngularUnit_.set (r);
            continue;
          }
        }

        // ForceUnit
        //
        if (n.name () == "ForceUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ForceUnit_type > r (
            ForceUnit_traits::create (i, f, this));

          if (!this->ForceUnit_)
          {
            this->ForceUnit_.set (r);
            continue;
          }
        }

        // LinearUnit
        //
        if (n.name () == "LinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearUnit_type > r (
            LinearUnit_traits::create (i, f, this));

          if (!this->LinearUnit_)
          {
            this->LinearUnit_.set (r);
            continue;
          }
        }

        // MassUnit
        //
        if (n.name () == "MassUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MassUnit_type > r (
            MassUnit_traits::create (i, f, this));

          if (!this->MassUnit_)
          {
            this->MassUnit_.set (r);
            continue;
          }
        }

        // PressureUnit
        //
        if (n.name () == "PressureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PressureUnit_type > r (
            PressureUnit_traits::create (i, f, this));

          if (!this->PressureUnit_)
          {
            this->PressureUnit_.set (r);
            continue;
          }
        }

        // SpeedUnit
        //
        if (n.name () == "SpeedUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SpeedUnit_type > r (
            SpeedUnit_traits::create (i, f, this));

          if (!this->SpeedUnit_)
          {
            this->SpeedUnit_.set (r);
            continue;
          }
        }

        // TemperatureUnit
        //
        if (n.name () == "TemperatureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TemperatureUnit_type > r (
            TemperatureUnit_traits::create (i, f, this));

          if (!this->TemperatureUnit_)
          {
            this->TemperatureUnit_.set (r);
            continue;
          }
        }

        // TimeUnit
        //
        if (n.name () == "TimeUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeUnit_type > r (
            TimeUnit_traits::create (i, f, this));

          if (!this->TimeUnit_)
          {
            this->TimeUnit_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PrimaryUnitsType* PrimaryUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrimaryUnitsType (*this, f, c);
    }

    PrimaryUnitsType& PrimaryUnitsType::
    operator= (const PrimaryUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AreaUnit_ = x.AreaUnit_;
        this->AngularUnit_ = x.AngularUnit_;
        this->ForceUnit_ = x.ForceUnit_;
        this->LinearUnit_ = x.LinearUnit_;
        this->MassUnit_ = x.MassUnit_;
        this->PressureUnit_ = x.PressureUnit_;
        this->SpeedUnit_ = x.SpeedUnit_;
        this->TemperatureUnit_ = x.TemperatureUnit_;
        this->TimeUnit_ = x.TimeUnit_;
      }

      return *this;
    }

    PrimaryUnitsType::
    ~PrimaryUnitsType ()
    {
    }

    // OtherUnitsType
    //

    OtherUnitsType::
    OtherUnitsType ()
    : ::xml_schema::type (),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this)
    {
    }

    OtherUnitsType::
    OtherUnitsType (const OtherUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaUnit_ (x.AreaUnit_, f, this),
      AngularUnit_ (x.AngularUnit_, f, this),
      ForceUnit_ (x.ForceUnit_, f, this),
      LinearUnit_ (x.LinearUnit_, f, this),
      MassUnit_ (x.MassUnit_, f, this),
      PressureUnit_ (x.PressureUnit_, f, this),
      SpeedUnit_ (x.SpeedUnit_, f, this),
      TemperatureUnit_ (x.TemperatureUnit_, f, this),
      TimeUnit_ (x.TimeUnit_, f, this)
    {
    }

    OtherUnitsType::
    OtherUnitsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AreaUnit
        //
        if (n.name () == "AreaUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AreaUnit_type > r (
            AreaUnit_traits::create (i, f, this));

          this->AreaUnit_.push_back (r);
          continue;
        }

        // AngularUnit
        //
        if (n.name () == "AngularUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AngularUnit_type > r (
            AngularUnit_traits::create (i, f, this));

          this->AngularUnit_.push_back (r);
          continue;
        }

        // ForceUnit
        //
        if (n.name () == "ForceUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ForceUnit_type > r (
            ForceUnit_traits::create (i, f, this));

          this->ForceUnit_.push_back (r);
          continue;
        }

        // LinearUnit
        //
        if (n.name () == "LinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearUnit_type > r (
            LinearUnit_traits::create (i, f, this));

          this->LinearUnit_.push_back (r);
          continue;
        }

        // MassUnit
        //
        if (n.name () == "MassUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MassUnit_type > r (
            MassUnit_traits::create (i, f, this));

          this->MassUnit_.push_back (r);
          continue;
        }

        // PressureUnit
        //
        if (n.name () == "PressureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PressureUnit_type > r (
            PressureUnit_traits::create (i, f, this));

          this->PressureUnit_.push_back (r);
          continue;
        }

        // SpeedUnit
        //
        if (n.name () == "SpeedUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SpeedUnit_type > r (
            SpeedUnit_traits::create (i, f, this));

          this->SpeedUnit_.push_back (r);
          continue;
        }

        // TemperatureUnit
        //
        if (n.name () == "TemperatureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TemperatureUnit_type > r (
            TemperatureUnit_traits::create (i, f, this));

          this->TemperatureUnit_.push_back (r);
          continue;
        }

        // TimeUnit
        //
        if (n.name () == "TimeUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeUnit_type > r (
            TimeUnit_traits::create (i, f, this));

          this->TimeUnit_.push_back (r);
          continue;
        }

        break;
      }
    }

    OtherUnitsType* OtherUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherUnitsType (*this, f, c);
    }

    OtherUnitsType& OtherUnitsType::
    operator= (const OtherUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AreaUnit_ = x.AreaUnit_;
        this->AngularUnit_ = x.AngularUnit_;
        this->ForceUnit_ = x.ForceUnit_;
        this->LinearUnit_ = x.LinearUnit_;
        this->MassUnit_ = x.MassUnit_;
        this->PressureUnit_ = x.PressureUnit_;
        this->SpeedUnit_ = x.SpeedUnit_;
        this->TemperatureUnit_ = x.TemperatureUnit_;
        this->TimeUnit_ = x.TimeUnit_;
      }

      return *this;
    }

    OtherUnitsType::
    ~OtherUnitsType ()
    {
    }

    // UserDefinedUnitType
    //

    UserDefinedUnitType::
    UserDefinedUnitType (const WhatIsMeasured_type& WhatIsMeasured,
                         const UnitName_type& UnitName)
    : ::xml_schema::type (),
      WhatIsMeasured_ (WhatIsMeasured, this),
      UnitName_ (UnitName, this),
      StandardName_ (this)
    {
    }

    UserDefinedUnitType::
    UserDefinedUnitType (const UserDefinedUnitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      WhatIsMeasured_ (x.WhatIsMeasured_, f, this),
      UnitName_ (x.UnitName_, f, this),
      StandardName_ (x.StandardName_, f, this)
    {
    }

    UserDefinedUnitType::
    UserDefinedUnitType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      WhatIsMeasured_ (this),
      UnitName_ (this),
      StandardName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // WhatIsMeasured
        //
        if (n.name () == "WhatIsMeasured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WhatIsMeasured_type > r (
            WhatIsMeasured_traits::create (i, f, this));

          if (!WhatIsMeasured_.present ())
          {
            this->WhatIsMeasured_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // StandardName
        //
        if (n.name () == "StandardName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StandardName_type > r (
            StandardName_traits::create (i, f, this));

          if (!this->StandardName_)
          {
            this->StandardName_.set (r);
            continue;
          }
        }

        break;
      }

      if (!WhatIsMeasured_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "WhatIsMeasured",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    UserDefinedUnitType* UserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitType (*this, f, c);
    }

    UserDefinedUnitType& UserDefinedUnitType::
    operator= (const UserDefinedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->WhatIsMeasured_ = x.WhatIsMeasured_;
        this->UnitName_ = x.UnitName_;
        this->StandardName_ = x.StandardName_;
      }

      return *this;
    }

    UserDefinedUnitType::
    ~UserDefinedUnitType ()
    {
    }

    // UserDefinedUnitValueType
    //

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const ::xml_schema::decimal& _xsd_decimal_base,
                              const unitName_type& unitName)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      unitName_ (unitName, this)
    {
    }

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const UserDefinedUnitValueType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "unitName",
          "");
      }
    }

    UserDefinedUnitValueType* UserDefinedUnitValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitValueType (*this, f, c);
    }

    UserDefinedUnitValueType& UserDefinedUnitValueType::
    operator= (const UserDefinedUnitValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SpecifiedDecimalType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    UserDefinedUnitValueType::
    ~UserDefinedUnitValueType ()
    {
    }

    // ActualUserDefinedUnitValueType
    //

    ActualUserDefinedUnitValueType::
    ActualUserDefinedUnitValueType (const ::xml_schema::decimal& _xsd_decimal_base,
                                    const unitName_type& unitName)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      unitName_ (unitName, this)
    {
    }

    ActualUserDefinedUnitValueType::
    ActualUserDefinedUnitValueType (const ActualUserDefinedUnitValueType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    ActualUserDefinedUnitValueType::
    ActualUserDefinedUnitValueType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ActualUserDefinedUnitValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "unitName",
          "");
      }
    }

    ActualUserDefinedUnitValueType* ActualUserDefinedUnitValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualUserDefinedUnitValueType (*this, f, c);
    }

    ActualUserDefinedUnitValueType& ActualUserDefinedUnitValueType::
    operator= (const ActualUserDefinedUnitValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualDecimalType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    ActualUserDefinedUnitValueType::
    ~ActualUserDefinedUnitValueType ()
    {
    }

    // UserDefinedUnitsType
    //

    UserDefinedUnitsType::
    UserDefinedUnitsType ()
    : ::xml_schema::type (),
      UserDefinedUnit_ (this)
    {
    }

    UserDefinedUnitsType::
    UserDefinedUnitsType (const UserDefinedUnitsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      UserDefinedUnit_ (x.UserDefinedUnit_, f, this)
    {
    }

    UserDefinedUnitsType::
    UserDefinedUnitsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      UserDefinedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // UserDefinedUnit
        //
        if (n.name () == "UserDefinedUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedUnit_type > r (
            UserDefinedUnit_traits::create (i, f, this));

          this->UserDefinedUnit_.push_back (r);
          continue;
        }

        break;
      }
    }

    UserDefinedUnitsType* UserDefinedUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitsType (*this, f, c);
    }

    UserDefinedUnitsType& UserDefinedUnitsType::
    operator= (const UserDefinedUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->UserDefinedUnit_ = x.UserDefinedUnit_;
      }

      return *this;
    }

    UserDefinedUnitsType::
    ~UserDefinedUnitsType ()
    {
    }

    // FileUnitsType
    //

    FileUnitsType::
    FileUnitsType (const PrimaryUnits_type& PrimaryUnits)
    : ::xml_schema::type (),
      PrimaryUnits_ (PrimaryUnits, this),
      OtherUnits_ (this),
      UserDefinedUnits_ (this)
    {
    }

    FileUnitsType::
    FileUnitsType (::std::auto_ptr< PrimaryUnits_type > PrimaryUnits)
    : ::xml_schema::type (),
      PrimaryUnits_ (PrimaryUnits, this),
      OtherUnits_ (this),
      UserDefinedUnits_ (this)
    {
    }

    FileUnitsType::
    FileUnitsType (const FileUnitsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrimaryUnits_ (x.PrimaryUnits_, f, this),
      OtherUnits_ (x.OtherUnits_, f, this),
      UserDefinedUnits_ (x.UserDefinedUnits_, f, this)
    {
    }

    FileUnitsType::
    FileUnitsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrimaryUnits_ (this),
      OtherUnits_ (this),
      UserDefinedUnits_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PrimaryUnits
        //
        if (n.name () == "PrimaryUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrimaryUnits_type > r (
            PrimaryUnits_traits::create (i, f, this));

          if (!PrimaryUnits_.present ())
          {
            this->PrimaryUnits_.set (r);
            continue;
          }
        }

        // OtherUnits
        //
        if (n.name () == "OtherUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherUnits_type > r (
            OtherUnits_traits::create (i, f, this));

          if (!this->OtherUnits_)
          {
            this->OtherUnits_.set (r);
            continue;
          }
        }

        // UserDefinedUnits
        //
        if (n.name () == "UserDefinedUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedUnits_type > r (
            UserDefinedUnits_traits::create (i, f, this));

          if (!this->UserDefinedUnits_)
          {
            this->UserDefinedUnits_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PrimaryUnits_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PrimaryUnits",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FileUnitsType* FileUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileUnitsType (*this, f, c);
    }

    FileUnitsType& FileUnitsType::
    operator= (const FileUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PrimaryUnits_ = x.PrimaryUnits_;
        this->OtherUnits_ = x.OtherUnits_;
        this->UserDefinedUnits_ = x.UserDefinedUnits_;
      }

      return *this;
    }

    FileUnitsType::
    ~FileUnitsType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FileUnitsType > (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FileUnitsType > (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FileUnitsType > (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FileUnits (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FileUnits (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FileUnitsType > (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FileUnitsType > (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FileUnitsType > (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::FileUnitsType > (
          ::xsd::qif2::FileUnits (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FileUnits" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FileUnitsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FileUnits",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FileUnits" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FileUnitsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FileUnits",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const PositiveDecimalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const PositiveDecimalType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PositiveDecimalType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const NonNegativeDecimalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const NonNegativeDecimalType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const NonNegativeDecimalType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const UnitConversionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Factor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Factor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Factor ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Offset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(*i.Offset ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SpecifiedDecimalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "significantFigures",
            e));

        a << *i.significantFigures ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualDecimalType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "combinedUncertainty",
            e));

        a << *i.combinedUncertainty ();
      }

      // meanError
      //
      if (i.meanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "meanError",
            e));

        a << *i.meanError ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AngularUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AngularValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualAngularValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AreaUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AreaValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualAreaValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ForceUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ForceValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualForceValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LinearUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LinearValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualLinearValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MassUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MassValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualMassValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PressureUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PressureValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualPressureValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SpeedUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SpeedValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualSpeedValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TemperatureUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TemperatureValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualTemperatureValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TimeUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SIUnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitConversion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TimeValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualTimeValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PrimaryUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AreaUnit
      //
      if (i.AreaUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AreaUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AreaUnit ();
      }

      // AngularUnit
      //
      if (i.AngularUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AngularUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AngularUnit ();
      }

      // ForceUnit
      //
      if (i.ForceUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ForceUnit ();
      }

      // LinearUnit
      //
      if (i.LinearUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LinearUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LinearUnit ();
      }

      // MassUnit
      //
      if (i.MassUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MassUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MassUnit ();
      }

      // PressureUnit
      //
      if (i.PressureUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PressureUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PressureUnit ();
      }

      // SpeedUnit
      //
      if (i.SpeedUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SpeedUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SpeedUnit ();
      }

      // TemperatureUnit
      //
      if (i.TemperatureUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TemperatureUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TemperatureUnit ();
      }

      // TimeUnit
      //
      if (i.TimeUnit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimeUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TimeUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OtherUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AreaUnit
      //
      for (OtherUnitsType::AreaUnit_const_iterator
           b (i.AreaUnit ().begin ()), n (i.AreaUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AreaUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // AngularUnit
      //
      for (OtherUnitsType::AngularUnit_const_iterator
           b (i.AngularUnit ().begin ()), n (i.AngularUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AngularUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // ForceUnit
      //
      for (OtherUnitsType::ForceUnit_const_iterator
           b (i.ForceUnit ().begin ()), n (i.ForceUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // LinearUnit
      //
      for (OtherUnitsType::LinearUnit_const_iterator
           b (i.LinearUnit ().begin ()), n (i.LinearUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LinearUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // MassUnit
      //
      for (OtherUnitsType::MassUnit_const_iterator
           b (i.MassUnit ().begin ()), n (i.MassUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MassUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // PressureUnit
      //
      for (OtherUnitsType::PressureUnit_const_iterator
           b (i.PressureUnit ().begin ()), n (i.PressureUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PressureUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // SpeedUnit
      //
      for (OtherUnitsType::SpeedUnit_const_iterator
           b (i.SpeedUnit ().begin ()), n (i.SpeedUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SpeedUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // TemperatureUnit
      //
      for (OtherUnitsType::TemperatureUnit_const_iterator
           b (i.TemperatureUnit ().begin ()), n (i.TemperatureUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TemperatureUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // TimeUnit
      //
      for (OtherUnitsType::TimeUnit_const_iterator
           b (i.TimeUnit ().begin ()), n (i.TimeUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimeUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const UserDefinedUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // WhatIsMeasured
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WhatIsMeasured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.WhatIsMeasured ();
      }

      // UnitName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitName ();
      }

      // StandardName
      //
      if (i.StandardName ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StandardName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.StandardName ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const UserDefinedUnitValueType& i)
    {
      e << static_cast< const ::xsd::qif2::SpecifiedDecimalType& > (i);

      // unitName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitName",
            e));

        a << i.unitName ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualUserDefinedUnitValueType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualDecimalType& > (i);

      // unitName
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "unitName",
            e));

        a << i.unitName ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const UserDefinedUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // UserDefinedUnit
      //
      for (UserDefinedUnitsType::UserDefinedUnit_const_iterator
           b (i.UserDefinedUnit ().begin ()), n (i.UserDefinedUnit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FileUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PrimaryUnits
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PrimaryUnits",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PrimaryUnits ();
      }

      // OtherUnits
      //
      if (i.OtherUnits ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherUnits",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherUnits ();
      }

      // UserDefinedUnits
      //
      if (i.UserDefinedUnits ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedUnits",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedUnits ();
      }
    }

    void
    FileUnits (::std::ostream& o,
               const ::xsd::qif2::FileUnitsType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FileUnits (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FileUnits (::std::ostream& o,
               const ::xsd::qif2::FileUnitsType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FileUnits (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FileUnits (::std::ostream& o,
               const ::xsd::qif2::FileUnitsType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FileUnits (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FileUnits (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::FileUnitsType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FileUnits (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FileUnits (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::FileUnitsType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FileUnits (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FileUnits (::xercesc::XMLFormatTarget& t,
               const ::xsd::qif2::FileUnitsType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FileUnits (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FileUnits (::xercesc::DOMDocument& d,
               const ::xsd::qif2::FileUnitsType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FileUnits" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "FileUnits",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    FileUnits (const ::xsd::qif2::FileUnitsType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "FileUnits",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::FileUnits (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

