// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFRules.hxx"

namespace xsd
{
  namespace qif2
  {
    // QIFRulesType
    // 

    const QIFRulesType::Version_optional& QIFRulesType::
    Version () const
    {
      return this->Version_;
    }

    QIFRulesType::Version_optional& QIFRulesType::
    Version ()
    {
      return this->Version_;
    }

    void QIFRulesType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void QIFRulesType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void QIFRulesType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const QIFRulesType::RulesUnits_optional& QIFRulesType::
    RulesUnits () const
    {
      return this->RulesUnits_;
    }

    QIFRulesType::RulesUnits_optional& QIFRulesType::
    RulesUnits ()
    {
      return this->RulesUnits_;
    }

    void QIFRulesType::
    RulesUnits (const RulesUnits_type& x)
    {
      this->RulesUnits_.set (x);
    }

    void QIFRulesType::
    RulesUnits (const RulesUnits_optional& x)
    {
      this->RulesUnits_ = x;
    }

    void QIFRulesType::
    RulesUnits (::std::auto_ptr< RulesUnits_type > x)
    {
      this->RulesUnits_.set (x);
    }

    const QIFRulesType::FeatureRules_optional& QIFRulesType::
    FeatureRules () const
    {
      return this->FeatureRules_;
    }

    QIFRulesType::FeatureRules_optional& QIFRulesType::
    FeatureRules ()
    {
      return this->FeatureRules_;
    }

    void QIFRulesType::
    FeatureRules (const FeatureRules_type& x)
    {
      this->FeatureRules_.set (x);
    }

    void QIFRulesType::
    FeatureRules (const FeatureRules_optional& x)
    {
      this->FeatureRules_ = x;
    }

    void QIFRulesType::
    FeatureRules (::std::auto_ptr< FeatureRules_type > x)
    {
      this->FeatureRules_.set (x);
    }

    const QIFRulesType::DMESelectionRules_optional& QIFRulesType::
    DMESelectionRules () const
    {
      return this->DMESelectionRules_;
    }

    QIFRulesType::DMESelectionRules_optional& QIFRulesType::
    DMESelectionRules ()
    {
      return this->DMESelectionRules_;
    }

    void QIFRulesType::
    DMESelectionRules (const DMESelectionRules_type& x)
    {
      this->DMESelectionRules_.set (x);
    }

    void QIFRulesType::
    DMESelectionRules (const DMESelectionRules_optional& x)
    {
      this->DMESelectionRules_ = x;
    }

    void QIFRulesType::
    DMESelectionRules (::std::auto_ptr< DMESelectionRules_type > x)
    {
      this->DMESelectionRules_.set (x);
    }


    // FeatureRulesType
    // 

    const FeatureRulesType::SamplingRigorMax_type& FeatureRulesType::
    SamplingRigorMax () const
    {
      return this->SamplingRigorMax_.get ();
    }

    FeatureRulesType::SamplingRigorMax_type& FeatureRulesType::
    SamplingRigorMax ()
    {
      return this->SamplingRigorMax_.get ();
    }

    void FeatureRulesType::
    SamplingRigorMax (const SamplingRigorMax_type& x)
    {
      this->SamplingRigorMax_.set (x);
    }

    const FeatureRulesType::IfThenElseFeatureRules_optional& FeatureRulesType::
    IfThenElseFeatureRules () const
    {
      return this->IfThenElseFeatureRules_;
    }

    FeatureRulesType::IfThenElseFeatureRules_optional& FeatureRulesType::
    IfThenElseFeatureRules ()
    {
      return this->IfThenElseFeatureRules_;
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (const IfThenElseFeatureRules_type& x)
    {
      this->IfThenElseFeatureRules_.set (x);
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (const IfThenElseFeatureRules_optional& x)
    {
      this->IfThenElseFeatureRules_ = x;
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (::std::auto_ptr< IfThenElseFeatureRules_type > x)
    {
      this->IfThenElseFeatureRules_.set (x);
    }

    const FeatureRulesType::MaxFeatureRules_optional& FeatureRulesType::
    MaxFeatureRules () const
    {
      return this->MaxFeatureRules_;
    }

    FeatureRulesType::MaxFeatureRules_optional& FeatureRulesType::
    MaxFeatureRules ()
    {
      return this->MaxFeatureRules_;
    }

    void FeatureRulesType::
    MaxFeatureRules (const MaxFeatureRules_type& x)
    {
      this->MaxFeatureRules_.set (x);
    }

    void FeatureRulesType::
    MaxFeatureRules (const MaxFeatureRules_optional& x)
    {
      this->MaxFeatureRules_ = x;
    }

    void FeatureRulesType::
    MaxFeatureRules (::std::auto_ptr< MaxFeatureRules_type > x)
    {
      this->MaxFeatureRules_.set (x);
    }


    // QIFRuleBaseType
    // 

    const QIFRuleBaseType::name_optional& QIFRuleBaseType::
    name () const
    {
      return this->name_;
    }

    QIFRuleBaseType::name_optional& QIFRuleBaseType::
    name ()
    {
      return this->name_;
    }

    void QIFRuleBaseType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void QIFRuleBaseType::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void QIFRuleBaseType::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }


    // IfThenElseFeatureRulesType
    // 

    const IfThenElseFeatureRulesType::IfThenFeatureRule_sequence& IfThenElseFeatureRulesType::
    IfThenFeatureRule () const
    {
      return this->IfThenFeatureRule_;
    }

    IfThenElseFeatureRulesType::IfThenFeatureRule_sequence& IfThenElseFeatureRulesType::
    IfThenFeatureRule ()
    {
      return this->IfThenFeatureRule_;
    }

    void IfThenElseFeatureRulesType::
    IfThenFeatureRule (const IfThenFeatureRule_sequence& s)
    {
      this->IfThenFeatureRule_ = s;
    }

    const IfThenElseFeatureRulesType::Else_optional& IfThenElseFeatureRulesType::
    Else () const
    {
      return this->Else_;
    }

    IfThenElseFeatureRulesType::Else_optional& IfThenElseFeatureRulesType::
    Else ()
    {
      return this->Else_;
    }

    void IfThenElseFeatureRulesType::
    Else (const Else_type& x)
    {
      this->Else_.set (x);
    }

    void IfThenElseFeatureRulesType::
    Else (const Else_optional& x)
    {
      this->Else_ = x;
    }

    void IfThenElseFeatureRulesType::
    Else (::std::auto_ptr< Else_type > x)
    {
      this->Else_.set (x);
    }


    // MaxFeatureRulesType
    // 

    const MaxFeatureRulesType::IfThenFeatureRule_sequence& MaxFeatureRulesType::
    IfThenFeatureRule () const
    {
      return this->IfThenFeatureRule_;
    }

    MaxFeatureRulesType::IfThenFeatureRule_sequence& MaxFeatureRulesType::
    IfThenFeatureRule ()
    {
      return this->IfThenFeatureRule_;
    }

    void MaxFeatureRulesType::
    IfThenFeatureRule (const IfThenFeatureRule_sequence& s)
    {
      this->IfThenFeatureRule_ = s;
    }

    const MaxFeatureRulesType::Else_optional& MaxFeatureRulesType::
    Else () const
    {
      return this->Else_;
    }

    MaxFeatureRulesType::Else_optional& MaxFeatureRulesType::
    Else ()
    {
      return this->Else_;
    }

    void MaxFeatureRulesType::
    Else (const Else_type& x)
    {
      this->Else_.set (x);
    }

    void MaxFeatureRulesType::
    Else (const Else_optional& x)
    {
      this->Else_ = x;
    }

    void MaxFeatureRulesType::
    Else (::std::auto_ptr< Else_type > x)
    {
      this->Else_.set (x);
    }


    // DMESelectionRulesType
    // 

    const DMESelectionRulesType::DMESelectionRule_sequence& DMESelectionRulesType::
    DMESelectionRule () const
    {
      return this->DMESelectionRule_;
    }

    DMESelectionRulesType::DMESelectionRule_sequence& DMESelectionRulesType::
    DMESelectionRule ()
    {
      return this->DMESelectionRule_;
    }

    void DMESelectionRulesType::
    DMESelectionRule (const DMESelectionRule_sequence& s)
    {
      this->DMESelectionRule_ = s;
    }


    // PointRuleBaseType
    // 


    // IfThenFeatureRuleType
    // 

    const IfThenFeatureRuleType::BooleanExpression_optional& IfThenFeatureRuleType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    IfThenFeatureRuleType::BooleanExpression_optional& IfThenFeatureRuleType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void IfThenFeatureRuleType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void IfThenFeatureRuleType::
    BooleanExpression (const BooleanExpression_optional& x)
    {
      this->BooleanExpression_ = x;
    }

    void IfThenFeatureRuleType::
    BooleanExpression (::std::auto_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (x);
    }

    const IfThenFeatureRuleType::ThenPoints_optional& IfThenFeatureRuleType::
    ThenPoints () const
    {
      return this->ThenPoints_;
    }

    IfThenFeatureRuleType::ThenPoints_optional& IfThenFeatureRuleType::
    ThenPoints ()
    {
      return this->ThenPoints_;
    }

    void IfThenFeatureRuleType::
    ThenPoints (const ThenPoints_type& x)
    {
      this->ThenPoints_.set (x);
    }

    void IfThenFeatureRuleType::
    ThenPoints (const ThenPoints_optional& x)
    {
      this->ThenPoints_ = x;
    }

    void IfThenFeatureRuleType::
    ThenPoints (::std::auto_ptr< ThenPoints_type > x)
    {
      this->ThenPoints_.set (x);
    }


    // ElseRuleType
    // 

    const ElseRuleType::ThenPoints_type& ElseRuleType::
    ThenPoints () const
    {
      return this->ThenPoints_.get ();
    }

    ElseRuleType::ThenPoints_type& ElseRuleType::
    ThenPoints ()
    {
      return this->ThenPoints_.get ();
    }

    void ElseRuleType::
    ThenPoints (const ThenPoints_type& x)
    {
      this->ThenPoints_.set (x);
    }

    void ElseRuleType::
    ThenPoints (::std::auto_ptr< ThenPoints_type > x)
    {
      this->ThenPoints_.set (x);
    }


    // ThenPointsType
    // 

    const ThenPointsType::NumberOfPoints_optional& ThenPointsType::
    NumberOfPoints () const
    {
      return this->NumberOfPoints_;
    }

    ThenPointsType::NumberOfPoints_optional& ThenPointsType::
    NumberOfPoints ()
    {
      return this->NumberOfPoints_;
    }

    void ThenPointsType::
    NumberOfPoints (const NumberOfPoints_type& x)
    {
      this->NumberOfPoints_.set (x);
    }

    void ThenPointsType::
    NumberOfPoints (const NumberOfPoints_optional& x)
    {
      this->NumberOfPoints_ = x;
    }

    const ThenPointsType::MinPoints_optional& ThenPointsType::
    MinPoints () const
    {
      return this->MinPoints_;
    }

    ThenPointsType::MinPoints_optional& ThenPointsType::
    MinPoints ()
    {
      return this->MinPoints_;
    }

    void ThenPointsType::
    MinPoints (const MinPoints_type& x)
    {
      this->MinPoints_.set (x);
    }

    void ThenPointsType::
    MinPoints (const MinPoints_optional& x)
    {
      this->MinPoints_ = x;
    }

    const ThenPointsType::PointDensity_optional& ThenPointsType::
    PointDensity () const
    {
      return this->PointDensity_;
    }

    ThenPointsType::PointDensity_optional& ThenPointsType::
    PointDensity ()
    {
      return this->PointDensity_;
    }

    void ThenPointsType::
    PointDensity (const PointDensity_type& x)
    {
      this->PointDensity_.set (x);
    }

    void ThenPointsType::
    PointDensity (const PointDensity_optional& x)
    {
      this->PointDensity_ = x;
    }

    void ThenPointsType::
    PointDensity (::std::auto_ptr< PointDensity_type > x)
    {
      this->PointDensity_.set (x);
    }

    const ThenPointsType::MinPointDensity_optional& ThenPointsType::
    MinPointDensity () const
    {
      return this->MinPointDensity_;
    }

    ThenPointsType::MinPointDensity_optional& ThenPointsType::
    MinPointDensity ()
    {
      return this->MinPointDensity_;
    }

    void ThenPointsType::
    MinPointDensity (const MinPointDensity_type& x)
    {
      this->MinPointDensity_.set (x);
    }

    void ThenPointsType::
    MinPointDensity (const MinPointDensity_optional& x)
    {
      this->MinPointDensity_ = x;
    }

    void ThenPointsType::
    MinPointDensity (::std::auto_ptr< MinPointDensity_type > x)
    {
      this->MinPointDensity_.set (x);
    }


    // IfThenArcRuleType
    // 

    const IfThenArcRuleType::ThenPointStrategy_optional& IfThenArcRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenArcRuleType::ThenPointStrategy_optional& IfThenArcRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenArcRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenArcRuleType::ThenFittingAlgorithm_optional& IfThenArcRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenArcRuleType::ThenFittingAlgorithm_optional& IfThenArcRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenArcRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ArcPointSamplingStrategyType
    // 

    const ArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ArcPointSamplingStrategyType::UserDefinedStrategy_optional& ArcPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ArcPointSamplingStrategyType::UserDefinedStrategy_optional& ArcPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ArcPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCircleRuleType
    // 

    const IfThenCircleRuleType::ThenPointStrategy_optional& IfThenCircleRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCircleRuleType::ThenPointStrategy_optional& IfThenCircleRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCircleRuleType::ThenFittingAlgorithm_optional& IfThenCircleRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCircleRuleType::ThenFittingAlgorithm_optional& IfThenCircleRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CirclePointSamplingStrategyType
    // 

    const CirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CirclePointSamplingStrategyType::UserDefinedStrategy_optional& CirclePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CirclePointSamplingStrategyType::UserDefinedStrategy_optional& CirclePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenConeRuleType
    // 

    const IfThenConeRuleType::ThenPointStrategy_optional& IfThenConeRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenConeRuleType::ThenPointStrategy_optional& IfThenConeRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenConeRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenConeRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenConeRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenConeRuleType::ThenFittingAlgorithm_optional& IfThenConeRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenConeRuleType::ThenFittingAlgorithm_optional& IfThenConeRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ConePointSamplingStrategyType
    // 

    const ConePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ConePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ConePointSamplingStrategyType::UserDefinedStrategy_optional& ConePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ConePointSamplingStrategyType::UserDefinedStrategy_optional& ConePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenConicalSegmentRuleType
    // 

    const IfThenConicalSegmentRuleType::ThenPointStrategy_optional& IfThenConicalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenConicalSegmentRuleType::ThenPointStrategy_optional& IfThenConicalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenConicalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenConicalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ConicalSegmentPointSamplingStrategyType
    // 

    const ConicalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ConicalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ConicalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ConicalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCuboidRuleType
    // 

    const IfThenCuboidRuleType::ThenPointStrategy_optional& IfThenCuboidRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCuboidRuleType::ThenPointStrategy_optional& IfThenCuboidRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCuboidRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCuboidRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCuboidRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCuboidRuleType::ThenFittingAlgorithm_optional& IfThenCuboidRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCuboidRuleType::ThenFittingAlgorithm_optional& IfThenCuboidRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCuboidRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCuboidRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCuboidRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CuboidPointSamplingStrategyType
    // 

    const CuboidPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CuboidPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CuboidPointSamplingStrategyType::UserDefinedStrategy_optional& CuboidPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CuboidPointSamplingStrategyType::UserDefinedStrategy_optional& CuboidPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CuboidPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CuboidPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CuboidPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCylinderRuleType
    // 

    const IfThenCylinderRuleType::ThenPointStrategy_optional& IfThenCylinderRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCylinderRuleType::ThenPointStrategy_optional& IfThenCylinderRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCylinderRuleType::ThenFittingAlgorithm_optional& IfThenCylinderRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCylinderRuleType::ThenFittingAlgorithm_optional& IfThenCylinderRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CylinderPointSamplingStrategyType
    // 

    const CylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CylinderPointSamplingStrategyType::UserDefinedStrategy_optional& CylinderPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CylinderPointSamplingStrategyType::UserDefinedStrategy_optional& CylinderPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCylindricalSegmentRuleType
    // 

    const IfThenCylindricalSegmentRuleType::ThenPointStrategy_optional& IfThenCylindricalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCylindricalSegmentRuleType::ThenPointStrategy_optional& IfThenCylindricalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCylindricalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCylindricalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CylindricalSegmentPointSamplingStrategyType
    // 

    const CylindricalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CylindricalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CylindricalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CylindricalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenEllipseRuleType
    // 

    const IfThenEllipseRuleType::ThenPointStrategy_optional& IfThenEllipseRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenEllipseRuleType::ThenPointStrategy_optional& IfThenEllipseRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenEllipseRuleType::ThenFittingAlgorithm_optional& IfThenEllipseRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenEllipseRuleType::ThenFittingAlgorithm_optional& IfThenEllipseRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // EllipsePointSamplingStrategyType
    // 

    const EllipsePointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    EllipsePointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const EllipsePointSamplingStrategyType::UserDefinedStrategy_optional& EllipsePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    EllipsePointSamplingStrategyType::UserDefinedStrategy_optional& EllipsePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenElongatedCylinderRuleType
    // 

    const IfThenElongatedCylinderRuleType::ThenPointStrategy_optional& IfThenElongatedCylinderRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenElongatedCylinderRuleType::ThenPointStrategy_optional& IfThenElongatedCylinderRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenElongatedCylinderRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenElongatedCylinderRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ElongatedCylinderPointSamplingStrategyType
    // 

    const ElongatedCylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ElongatedCylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ElongatedCylinderPointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ElongatedCylinderPointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenExtrudedCrossSectionRuleType
    // 

    const IfThenExtrudedCrossSectionRuleType::ThenPointStrategy_optional& IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenExtrudedCrossSectionRuleType::ThenPointStrategy_optional& IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenExtrudedCrossSectionRuleType::ThenFittingAlgorithm_optional& IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenExtrudedCrossSectionRuleType::ThenFittingAlgorithm_optional& IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ExtrudedCrossSectionPointSamplingStrategyType
    // 

    const ExtrudedCrossSectionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ExtrudedCrossSectionPointSamplingStrategyType::UserDefinedStrategy_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::UserDefinedStrategy_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenLineRuleType
    // 

    const IfThenLineRuleType::ThenPointStrategy_optional& IfThenLineRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenLineRuleType::ThenPointStrategy_optional& IfThenLineRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenLineRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenLineRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenLineRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenLineRuleType::ThenFittingAlgorithm_optional& IfThenLineRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenLineRuleType::ThenFittingAlgorithm_optional& IfThenLineRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // LinePointSamplingStrategyType
    // 

    const LinePointSamplingStrategyType::PointSamplingStrategyEnum_optional& LinePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    LinePointSamplingStrategyType::PointSamplingStrategyEnum_optional& LinePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const LinePointSamplingStrategyType::UserDefinedStrategy_optional& LinePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    LinePointSamplingStrategyType::UserDefinedStrategy_optional& LinePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenOppositeLinesRuleType
    // 

    const IfThenOppositeLinesRuleType::ThenPointStrategy_optional& IfThenOppositeLinesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositeLinesRuleType::ThenPointStrategy_optional& IfThenOppositeLinesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositeLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositeLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositeLinesRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenOppositeLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositeLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // OppositeLinesPointSamplingStrategyType
    // 

    const OppositeLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositeLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const OppositeLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositeLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenOppositePlanesRuleType
    // 

    const IfThenOppositePlanesRuleType::ThenPointStrategy_optional& IfThenOppositePlanesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositePlanesRuleType::ThenPointStrategy_optional& IfThenOppositePlanesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositePlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositePlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositePlanesRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenOppositePlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositePlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // OppositePlanesPointSamplingStrategyType
    // 

    const OppositePlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositePlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const OppositePlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositePlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPlaneRuleType
    // 

    const IfThenPlaneRuleType::ThenPointStrategy_optional& IfThenPlaneRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPlaneRuleType::ThenPointStrategy_optional& IfThenPlaneRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenPlaneRuleType::ThenFittingAlgorithm_optional& IfThenPlaneRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPlaneRuleType::ThenFittingAlgorithm_optional& IfThenPlaneRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // PlanePointSamplingStrategyType
    // 

    const PlanePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PlanePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PlanePointSamplingStrategyType::UserDefinedStrategy_optional& PlanePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PlanePointSamplingStrategyType::UserDefinedStrategy_optional& PlanePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPointDefinedCurveRuleType
    // 

    const IfThenPointDefinedCurveRuleType::ThenPointStrategy_optional& IfThenPointDefinedCurveRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointDefinedCurveRuleType::ThenPointStrategy_optional& IfThenPointDefinedCurveRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenPointDefinedCurveRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPointDefinedCurveRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // PointDefinedCurvePointSamplingStrategyType
    // 

    const PointDefinedCurvePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointDefinedCurvePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PointDefinedCurvePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointDefinedCurvePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPointDefinedSurfaceRuleType
    // 

    const IfThenPointDefinedSurfaceRuleType::ThenPointStrategy_optional& IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointDefinedSurfaceRuleType::ThenPointStrategy_optional& IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenPointDefinedSurfaceRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPointDefinedSurfaceRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // PointDefinedSurfacePointSamplingStrategyType
    // 

    const PointDefinedSurfacePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointDefinedSurfacePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PointDefinedSurfacePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointDefinedSurfacePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPointRuleType
    // 

    const IfThenPointRuleType::ThenPointStrategy_optional& IfThenPointRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointRuleType::ThenPointStrategy_optional& IfThenPointRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }


    // PointPointSamplingStrategyType
    // 

    const PointPointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointPointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PointPointSamplingStrategyType::UserDefinedStrategy_optional& PointPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointPointSamplingStrategyType::UserDefinedStrategy_optional& PointPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSphereRuleType
    // 

    const IfThenSphereRuleType::ThenPointStrategy_optional& IfThenSphereRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSphereRuleType::ThenPointStrategy_optional& IfThenSphereRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenSphereRuleType::ThenFittingAlgorithm_optional& IfThenSphereRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSphereRuleType::ThenFittingAlgorithm_optional& IfThenSphereRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // SpherePointSamplingStrategyType
    // 

    const SpherePointSamplingStrategyType::PointSamplingStrategyEnum_optional& SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SpherePointSamplingStrategyType::PointSamplingStrategyEnum_optional& SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const SpherePointSamplingStrategyType::UserDefinedStrategy_optional& SpherePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SpherePointSamplingStrategyType::UserDefinedStrategy_optional& SpherePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSphericalSegmentRuleType
    // 

    const IfThenSphericalSegmentRuleType::ThenPointStrategy_optional& IfThenSphericalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSphericalSegmentRuleType::ThenPointStrategy_optional& IfThenSphericalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenSphericalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSphericalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // SphericalSegmentPointSamplingStrategyType
    // 

    const SphericalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SphericalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const SphericalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SphericalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSurfaceOfRevolutionRuleType
    // 

    const IfThenSurfaceOfRevolutionRuleType::ThenPointStrategy_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSurfaceOfRevolutionRuleType::ThenPointStrategy_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenSurfaceOfRevolutionRuleType::ThenFittingAlgorithm_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSurfaceOfRevolutionRuleType::ThenFittingAlgorithm_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // SurfaceOfRevolutionPointSamplingStrategyType
    // 

    const SurfaceOfRevolutionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const SurfaceOfRevolutionPointSamplingStrategyType::UserDefinedStrategy_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::UserDefinedStrategy_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenToroidalSegmentRuleType
    // 

    const IfThenToroidalSegmentRuleType::ThenPointStrategy_optional& IfThenToroidalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenToroidalSegmentRuleType::ThenPointStrategy_optional& IfThenToroidalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenToroidalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenToroidalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ToroidalSegmentPointSamplingStrategyType
    // 

    const ToroidalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ToroidalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ToroidalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ToroidalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenTorusRuleType
    // 

    const IfThenTorusRuleType::ThenPointStrategy_optional& IfThenTorusRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenTorusRuleType::ThenPointStrategy_optional& IfThenTorusRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenTorusRuleType::ThenFittingAlgorithm_optional& IfThenTorusRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenTorusRuleType::ThenFittingAlgorithm_optional& IfThenTorusRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // TorusPointSamplingStrategyType
    // 

    const TorusPointSamplingStrategyType::PointSamplingStrategyEnum_optional& TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    TorusPointSamplingStrategyType::PointSamplingStrategyEnum_optional& TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const TorusPointSamplingStrategyType::UserDefinedStrategy_optional& TorusPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    TorusPointSamplingStrategyType::UserDefinedStrategy_optional& TorusPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSurfaceRuleType
    // 


    // IfThenCurveRuleType
    // 


    // DMESelectionRuleType
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // QIFRulesType
    //

    QIFRulesType::
    QIFRulesType ()
    : ::xml_schema::type (),
      Version_ (this),
      RulesUnits_ (this),
      FeatureRules_ (this),
      DMESelectionRules_ (this)
    {
    }

    QIFRulesType::
    QIFRulesType (const QIFRulesType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      RulesUnits_ (x.RulesUnits_, f, this),
      FeatureRules_ (x.FeatureRules_, f, this),
      DMESelectionRules_ (x.DMESelectionRules_, f, this)
    {
    }

    QIFRulesType::
    QIFRulesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      RulesUnits_ (this),
      FeatureRules_ (this),
      DMESelectionRules_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QIFRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // RulesUnits
        //
        if (n.name () == "RulesUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RulesUnits_type > r (
            RulesUnits_traits::create (i, f, this));

          if (!this->RulesUnits_)
          {
            this->RulesUnits_.set (r);
            continue;
          }
        }

        // FeatureRules
        //
        if (n.name () == "FeatureRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureRules_type > r (
            FeatureRules_traits::create (i, f, this));

          if (!this->FeatureRules_)
          {
            this->FeatureRules_.set (r);
            continue;
          }
        }

        // DMESelectionRules
        //
        if (n.name () == "DMESelectionRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DMESelectionRules_type > r (
            DMESelectionRules_traits::create (i, f, this));

          if (!this->DMESelectionRules_)
          {
            this->DMESelectionRules_.set (r);
            continue;
          }
        }

        break;
      }
    }

    QIFRulesType* QIFRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFRulesType (*this, f, c);
    }

    QIFRulesType& QIFRulesType::
    operator= (const QIFRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->RulesUnits_ = x.RulesUnits_;
        this->FeatureRules_ = x.FeatureRules_;
        this->DMESelectionRules_ = x.DMESelectionRules_;
      }

      return *this;
    }

    QIFRulesType::
    ~QIFRulesType ()
    {
    }

    // FeatureRulesType
    //

    FeatureRulesType::
    FeatureRulesType (const SamplingRigorMax_type& SamplingRigorMax)
    : ::xml_schema::type (),
      SamplingRigorMax_ (SamplingRigorMax, this),
      IfThenElseFeatureRules_ (this),
      MaxFeatureRules_ (this)
    {
    }

    FeatureRulesType::
    FeatureRulesType (const FeatureRulesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SamplingRigorMax_ (x.SamplingRigorMax_, f, this),
      IfThenElseFeatureRules_ (x.IfThenElseFeatureRules_, f, this),
      MaxFeatureRules_ (x.MaxFeatureRules_, f, this)
    {
    }

    FeatureRulesType::
    FeatureRulesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SamplingRigorMax_ (this),
      IfThenElseFeatureRules_ (this),
      MaxFeatureRules_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SamplingRigorMax
        //
        if (n.name () == "SamplingRigorMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SamplingRigorMax_.present ())
          {
            this->SamplingRigorMax_.set (SamplingRigorMax_traits::create (i, f, this));
            continue;
          }
        }

        // IfThenElseFeatureRules
        //
        if (n.name () == "IfThenElseFeatureRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IfThenElseFeatureRules_type > r (
            IfThenElseFeatureRules_traits::create (i, f, this));

          if (!this->IfThenElseFeatureRules_)
          {
            this->IfThenElseFeatureRules_.set (r);
            continue;
          }
        }

        // MaxFeatureRules
        //
        if (n.name () == "MaxFeatureRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxFeatureRules_type > r (
            MaxFeatureRules_traits::create (i, f, this));

          if (!this->MaxFeatureRules_)
          {
            this->MaxFeatureRules_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SamplingRigorMax_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SamplingRigorMax",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureRulesType* FeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureRulesType (*this, f, c);
    }

    FeatureRulesType& FeatureRulesType::
    operator= (const FeatureRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SamplingRigorMax_ = x.SamplingRigorMax_;
        this->IfThenElseFeatureRules_ = x.IfThenElseFeatureRules_;
        this->MaxFeatureRules_ = x.MaxFeatureRules_;
      }

      return *this;
    }

    FeatureRulesType::
    ~FeatureRulesType ()
    {
    }

    // QIFRuleBaseType
    //

    QIFRuleBaseType::
    QIFRuleBaseType ()
    : ::xml_schema::type (),
      name_ (this)
    {
    }

    QIFRuleBaseType::
    QIFRuleBaseType (const QIFRuleBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this)
    {
    }

    QIFRuleBaseType::
    QIFRuleBaseType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void QIFRuleBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }
    }

    QIFRuleBaseType* QIFRuleBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFRuleBaseType (*this, f, c);
    }

    QIFRuleBaseType& QIFRuleBaseType::
    operator= (const QIFRuleBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
      }

      return *this;
    }

    QIFRuleBaseType::
    ~QIFRuleBaseType ()
    {
    }

    // IfThenElseFeatureRulesType
    //

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType ()
    : ::xml_schema::type (),
      IfThenFeatureRule_ (this),
      Else_ (this)
    {
    }

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType (const IfThenElseFeatureRulesType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IfThenFeatureRule_ (x.IfThenFeatureRule_, f, this),
      Else_ (x.Else_, f, this)
    {
    }

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IfThenFeatureRule_ (this),
      Else_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IfThenElseFeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IfThenFeatureRule
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "IfThenFeatureRule",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< IfThenFeatureRule_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< IfThenFeatureRule_type > r (
              dynamic_cast< IfThenFeatureRule_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->IfThenFeatureRule_.push_back (r);
            continue;
          }
        }

        // Else
        //
        if (n.name () == "Else" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Else_type > r (
            Else_traits::create (i, f, this));

          if (!this->Else_)
          {
            this->Else_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenElseFeatureRulesType* IfThenElseFeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenElseFeatureRulesType (*this, f, c);
    }

    IfThenElseFeatureRulesType& IfThenElseFeatureRulesType::
    operator= (const IfThenElseFeatureRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IfThenFeatureRule_ = x.IfThenFeatureRule_;
        this->Else_ = x.Else_;
      }

      return *this;
    }

    IfThenElseFeatureRulesType::
    ~IfThenElseFeatureRulesType ()
    {
    }

    // MaxFeatureRulesType
    //

    MaxFeatureRulesType::
    MaxFeatureRulesType ()
    : ::xml_schema::type (),
      IfThenFeatureRule_ (this),
      Else_ (this)
    {
    }

    MaxFeatureRulesType::
    MaxFeatureRulesType (const MaxFeatureRulesType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IfThenFeatureRule_ (x.IfThenFeatureRule_, f, this),
      Else_ (x.Else_, f, this)
    {
    }

    MaxFeatureRulesType::
    MaxFeatureRulesType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IfThenFeatureRule_ (this),
      Else_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MaxFeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IfThenFeatureRule
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "IfThenFeatureRule",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< IfThenFeatureRule_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< IfThenFeatureRule_type > r (
              dynamic_cast< IfThenFeatureRule_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->IfThenFeatureRule_.push_back (r);
            continue;
          }
        }

        // Else
        //
        if (n.name () == "Else" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Else_type > r (
            Else_traits::create (i, f, this));

          if (!this->Else_)
          {
            this->Else_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MaxFeatureRulesType* MaxFeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaxFeatureRulesType (*this, f, c);
    }

    MaxFeatureRulesType& MaxFeatureRulesType::
    operator= (const MaxFeatureRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IfThenFeatureRule_ = x.IfThenFeatureRule_;
        this->Else_ = x.Else_;
      }

      return *this;
    }

    MaxFeatureRulesType::
    ~MaxFeatureRulesType ()
    {
    }

    // DMESelectionRulesType
    //

    DMESelectionRulesType::
    DMESelectionRulesType ()
    : ::xml_schema::type (),
      DMESelectionRule_ (this)
    {
    }

    DMESelectionRulesType::
    DMESelectionRulesType (const DMESelectionRulesType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DMESelectionRule_ (x.DMESelectionRule_, f, this)
    {
    }

    DMESelectionRulesType::
    DMESelectionRulesType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DMESelectionRule_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DMESelectionRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DMESelectionRule
        //
        if (n.name () == "DMESelectionRule" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DMESelectionRule_type > r (
            DMESelectionRule_traits::create (i, f, this));

          this->DMESelectionRule_.push_back (r);
          continue;
        }

        break;
      }
    }

    DMESelectionRulesType* DMESelectionRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMESelectionRulesType (*this, f, c);
    }

    DMESelectionRulesType& DMESelectionRulesType::
    operator= (const DMESelectionRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DMESelectionRule_ = x.DMESelectionRule_;
      }

      return *this;
    }

    DMESelectionRulesType::
    ~DMESelectionRulesType ()
    {
    }

    // PointRuleBaseType
    //

    PointRuleBaseType::
    PointRuleBaseType ()
    : ::xsd::qif2::QIFRuleBaseType ()
    {
    }

    PointRuleBaseType::
    PointRuleBaseType (const PointRuleBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::QIFRuleBaseType (x, f, c)
    {
    }

    PointRuleBaseType::
    PointRuleBaseType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::QIFRuleBaseType (e, f, c)
    {
    }

    PointRuleBaseType* PointRuleBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointRuleBaseType (*this, f, c);
    }

    PointRuleBaseType::
    ~PointRuleBaseType ()
    {
    }

    // IfThenFeatureRuleType
    //

    IfThenFeatureRuleType::
    IfThenFeatureRuleType ()
    : ::xsd::qif2::PointRuleBaseType (),
      BooleanExpression_ (this),
      ThenPoints_ (this)
    {
    }

    IfThenFeatureRuleType::
    IfThenFeatureRuleType (const IfThenFeatureRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      ThenPoints_ (x.ThenPoints_, f, this)
    {
    }

    IfThenFeatureRuleType::
    IfThenFeatureRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this),
      ThenPoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenFeatureRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PointRuleBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->BooleanExpression_)
            {
              ::std::auto_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->BooleanExpression_.set (r);
              continue;
            }
          }
        }

        // ThenPoints
        //
        if (n.name () == "ThenPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPoints_type > r (
            ThenPoints_traits::create (i, f, this));

          if (!this->ThenPoints_)
          {
            this->ThenPoints_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenFeatureRuleType* IfThenFeatureRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenFeatureRuleType (*this, f, c);
    }

    IfThenFeatureRuleType& IfThenFeatureRuleType::
    operator= (const IfThenFeatureRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::PointRuleBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
        this->ThenPoints_ = x.ThenPoints_;
      }

      return *this;
    }

    IfThenFeatureRuleType::
    ~IfThenFeatureRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenFeatureRuleType >
    _xsd_IfThenFeatureRuleType_type_factory_init (
      "IfThenFeatureRuleType",
      "http://qifstandards.org/xsd/qif2");

    // ElseRuleType
    //

    ElseRuleType::
    ElseRuleType (const ThenPoints_type& ThenPoints)
    : ::xsd::qif2::PointRuleBaseType (),
      ThenPoints_ (ThenPoints, this)
    {
    }

    ElseRuleType::
    ElseRuleType (::std::auto_ptr< ThenPoints_type > ThenPoints)
    : ::xsd::qif2::PointRuleBaseType (),
      ThenPoints_ (ThenPoints, this)
    {
    }

    ElseRuleType::
    ElseRuleType (const ElseRuleType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (x, f, c),
      ThenPoints_ (x.ThenPoints_, f, this)
    {
    }

    ElseRuleType::
    ElseRuleType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (e, f | ::xml_schema::flags::base, c),
      ThenPoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElseRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PointRuleBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPoints
        //
        if (n.name () == "ThenPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPoints_type > r (
            ThenPoints_traits::create (i, f, this));

          if (!ThenPoints_.present ())
          {
            this->ThenPoints_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ThenPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThenPoints",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElseRuleType* ElseRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElseRuleType (*this, f, c);
    }

    ElseRuleType& ElseRuleType::
    operator= (const ElseRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::PointRuleBaseType& > (*this) = x;
        this->ThenPoints_ = x.ThenPoints_;
      }

      return *this;
    }

    ElseRuleType::
    ~ElseRuleType ()
    {
    }

    // ThenPointsType
    //

    ThenPointsType::
    ThenPointsType ()
    : ::xml_schema::type (),
      NumberOfPoints_ (this),
      MinPoints_ (this),
      PointDensity_ (this),
      MinPointDensity_ (this)
    {
    }

    ThenPointsType::
    ThenPointsType (const ThenPointsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NumberOfPoints_ (x.NumberOfPoints_, f, this),
      MinPoints_ (x.MinPoints_, f, this),
      PointDensity_ (x.PointDensity_, f, this),
      MinPointDensity_ (x.MinPointDensity_, f, this)
    {
    }

    ThenPointsType::
    ThenPointsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NumberOfPoints_ (this),
      MinPoints_ (this),
      PointDensity_ (this),
      MinPointDensity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThenPointsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NumberOfPoints
        //
        if (n.name () == "NumberOfPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->NumberOfPoints_)
          {
            this->NumberOfPoints_.set (NumberOfPoints_traits::create (i, f, this));
            continue;
          }
        }

        // MinPoints
        //
        if (n.name () == "MinPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->MinPoints_)
          {
            this->MinPoints_.set (MinPoints_traits::create (i, f, this));
            continue;
          }
        }

        // PointDensity
        //
        if (n.name () == "PointDensity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointDensity_type > r (
            PointDensity_traits::create (i, f, this));

          if (!this->PointDensity_)
          {
            this->PointDensity_.set (r);
            continue;
          }
        }

        // MinPointDensity
        //
        if (n.name () == "MinPointDensity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinPointDensity_type > r (
            MinPointDensity_traits::create (i, f, this));

          if (!this->MinPointDensity_)
          {
            this->MinPointDensity_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThenPointsType* ThenPointsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThenPointsType (*this, f, c);
    }

    ThenPointsType& ThenPointsType::
    operator= (const ThenPointsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NumberOfPoints_ = x.NumberOfPoints_;
        this->MinPoints_ = x.MinPoints_;
        this->PointDensity_ = x.PointDensity_;
        this->MinPointDensity_ = x.MinPointDensity_;
      }

      return *this;
    }

    ThenPointsType::
    ~ThenPointsType ()
    {
    }

    // IfThenArcRuleType
    //

    IfThenArcRuleType::
    IfThenArcRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenArcRuleType::
    IfThenArcRuleType (const IfThenArcRuleType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenArcRuleType::
    IfThenArcRuleType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenArcRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenArcRuleType* IfThenArcRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenArcRuleType (*this, f, c);
    }

    IfThenArcRuleType& IfThenArcRuleType::
    operator= (const IfThenArcRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenArcRuleType::
    ~IfThenArcRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenArcRuleType >
    _xsd_IfThenArcRuleType_type_factory_init (
      "IfThenArcRuleType",
      "http://qifstandards.org/xsd/qif2");

    // ArcPointSamplingStrategyType
    //

    ArcPointSamplingStrategyType::
    ArcPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ArcPointSamplingStrategyType::
    ArcPointSamplingStrategyType (const ArcPointSamplingStrategyType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ArcPointSamplingStrategyType::
    ArcPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcPointSamplingStrategyType* ArcPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcPointSamplingStrategyType (*this, f, c);
    }

    ArcPointSamplingStrategyType& ArcPointSamplingStrategyType::
    operator= (const ArcPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ArcPointSamplingStrategyType::
    ~ArcPointSamplingStrategyType ()
    {
    }

    // IfThenCircleRuleType
    //

    IfThenCircleRuleType::
    IfThenCircleRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCircleRuleType::
    IfThenCircleRuleType (const IfThenCircleRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCircleRuleType::
    IfThenCircleRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCircleRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCircleRuleType* IfThenCircleRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCircleRuleType (*this, f, c);
    }

    IfThenCircleRuleType& IfThenCircleRuleType::
    operator= (const IfThenCircleRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCircleRuleType::
    ~IfThenCircleRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenCircleRuleType >
    _xsd_IfThenCircleRuleType_type_factory_init (
      "IfThenCircleRuleType",
      "http://qifstandards.org/xsd/qif2");

    // CirclePointSamplingStrategyType
    //

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType (const CirclePointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CirclePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CirclePointSamplingStrategyType* CirclePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CirclePointSamplingStrategyType (*this, f, c);
    }

    CirclePointSamplingStrategyType& CirclePointSamplingStrategyType::
    operator= (const CirclePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CirclePointSamplingStrategyType::
    ~CirclePointSamplingStrategyType ()
    {
    }

    // IfThenConeRuleType
    //

    IfThenConeRuleType::
    IfThenConeRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenConeRuleType::
    IfThenConeRuleType (const IfThenConeRuleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenConeRuleType::
    IfThenConeRuleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenConeRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenConeRuleType* IfThenConeRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenConeRuleType (*this, f, c);
    }

    IfThenConeRuleType& IfThenConeRuleType::
    operator= (const IfThenConeRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenConeRuleType::
    ~IfThenConeRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenConeRuleType >
    _xsd_IfThenConeRuleType_type_factory_init (
      "IfThenConeRuleType",
      "http://qifstandards.org/xsd/qif2");

    // ConePointSamplingStrategyType
    //

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType (const ConePointSamplingStrategyType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConePointSamplingStrategyType* ConePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConePointSamplingStrategyType (*this, f, c);
    }

    ConePointSamplingStrategyType& ConePointSamplingStrategyType::
    operator= (const ConePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ConePointSamplingStrategyType::
    ~ConePointSamplingStrategyType ()
    {
    }

    // IfThenConicalSegmentRuleType
    //

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType (const IfThenConicalSegmentRuleType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenConicalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenConicalSegmentRuleType* IfThenConicalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenConicalSegmentRuleType (*this, f, c);
    }

    IfThenConicalSegmentRuleType& IfThenConicalSegmentRuleType::
    operator= (const IfThenConicalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenConicalSegmentRuleType::
    ~IfThenConicalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenConicalSegmentRuleType >
    _xsd_IfThenConicalSegmentRuleType_type_factory_init (
      "IfThenConicalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");

    // ConicalSegmentPointSamplingStrategyType
    //

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType (const ConicalSegmentPointSamplingStrategyType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentPointSamplingStrategyType* ConicalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentPointSamplingStrategyType (*this, f, c);
    }

    ConicalSegmentPointSamplingStrategyType& ConicalSegmentPointSamplingStrategyType::
    operator= (const ConicalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ConicalSegmentPointSamplingStrategyType::
    ~ConicalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenCuboidRuleType
    //

    IfThenCuboidRuleType::
    IfThenCuboidRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCuboidRuleType::
    IfThenCuboidRuleType (const IfThenCuboidRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCuboidRuleType::
    IfThenCuboidRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCuboidRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCuboidRuleType* IfThenCuboidRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCuboidRuleType (*this, f, c);
    }

    IfThenCuboidRuleType& IfThenCuboidRuleType::
    operator= (const IfThenCuboidRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCuboidRuleType::
    ~IfThenCuboidRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenCuboidRuleType >
    _xsd_IfThenCuboidRuleType_type_factory_init (
      "IfThenCuboidRuleType",
      "http://qifstandards.org/xsd/qif2");

    // CuboidPointSamplingStrategyType
    //

    CuboidPointSamplingStrategyType::
    CuboidPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CuboidPointSamplingStrategyType::
    CuboidPointSamplingStrategyType (const CuboidPointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CuboidPointSamplingStrategyType::
    CuboidPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidPointSamplingStrategyType* CuboidPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidPointSamplingStrategyType (*this, f, c);
    }

    CuboidPointSamplingStrategyType& CuboidPointSamplingStrategyType::
    operator= (const CuboidPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CuboidPointSamplingStrategyType::
    ~CuboidPointSamplingStrategyType ()
    {
    }

    // IfThenCylinderRuleType
    //

    IfThenCylinderRuleType::
    IfThenCylinderRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCylinderRuleType::
    IfThenCylinderRuleType (const IfThenCylinderRuleType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCylinderRuleType::
    IfThenCylinderRuleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCylinderRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCylinderRuleType* IfThenCylinderRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCylinderRuleType (*this, f, c);
    }

    IfThenCylinderRuleType& IfThenCylinderRuleType::
    operator= (const IfThenCylinderRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCylinderRuleType::
    ~IfThenCylinderRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenCylinderRuleType >
    _xsd_IfThenCylinderRuleType_type_factory_init (
      "IfThenCylinderRuleType",
      "http://qifstandards.org/xsd/qif2");

    // CylinderPointSamplingStrategyType
    //

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType (const CylinderPointSamplingStrategyType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderPointSamplingStrategyType* CylinderPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderPointSamplingStrategyType (*this, f, c);
    }

    CylinderPointSamplingStrategyType& CylinderPointSamplingStrategyType::
    operator= (const CylinderPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CylinderPointSamplingStrategyType::
    ~CylinderPointSamplingStrategyType ()
    {
    }

    // IfThenCylindricalSegmentRuleType
    //

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType (const IfThenCylindricalSegmentRuleType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCylindricalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCylindricalSegmentRuleType* IfThenCylindricalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCylindricalSegmentRuleType (*this, f, c);
    }

    IfThenCylindricalSegmentRuleType& IfThenCylindricalSegmentRuleType::
    operator= (const IfThenCylindricalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCylindricalSegmentRuleType::
    ~IfThenCylindricalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenCylindricalSegmentRuleType >
    _xsd_IfThenCylindricalSegmentRuleType_type_factory_init (
      "IfThenCylindricalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");

    // CylindricalSegmentPointSamplingStrategyType
    //

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType (const CylindricalSegmentPointSamplingStrategyType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentPointSamplingStrategyType* CylindricalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentPointSamplingStrategyType (*this, f, c);
    }

    CylindricalSegmentPointSamplingStrategyType& CylindricalSegmentPointSamplingStrategyType::
    operator= (const CylindricalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CylindricalSegmentPointSamplingStrategyType::
    ~CylindricalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenEllipseRuleType
    //

    IfThenEllipseRuleType::
    IfThenEllipseRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenEllipseRuleType::
    IfThenEllipseRuleType (const IfThenEllipseRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenEllipseRuleType::
    IfThenEllipseRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenEllipseRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenEllipseRuleType* IfThenEllipseRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenEllipseRuleType (*this, f, c);
    }

    IfThenEllipseRuleType& IfThenEllipseRuleType::
    operator= (const IfThenEllipseRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenEllipseRuleType::
    ~IfThenEllipseRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenEllipseRuleType >
    _xsd_IfThenEllipseRuleType_type_factory_init (
      "IfThenEllipseRuleType",
      "http://qifstandards.org/xsd/qif2");

    // EllipsePointSamplingStrategyType
    //

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType (const EllipsePointSamplingStrategyType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipsePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipsePointSamplingStrategyType* EllipsePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipsePointSamplingStrategyType (*this, f, c);
    }

    EllipsePointSamplingStrategyType& EllipsePointSamplingStrategyType::
    operator= (const EllipsePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    EllipsePointSamplingStrategyType::
    ~EllipsePointSamplingStrategyType ()
    {
    }

    // IfThenElongatedCylinderRuleType
    //

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType (const IfThenElongatedCylinderRuleType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenElongatedCylinderRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenElongatedCylinderRuleType* IfThenElongatedCylinderRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenElongatedCylinderRuleType (*this, f, c);
    }

    IfThenElongatedCylinderRuleType& IfThenElongatedCylinderRuleType::
    operator= (const IfThenElongatedCylinderRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenElongatedCylinderRuleType::
    ~IfThenElongatedCylinderRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenElongatedCylinderRuleType >
    _xsd_IfThenElongatedCylinderRuleType_type_factory_init (
      "IfThenElongatedCylinderRuleType",
      "http://qifstandards.org/xsd/qif2");

    // ElongatedCylinderPointSamplingStrategyType
    //

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType (const ElongatedCylinderPointSamplingStrategyType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderPointSamplingStrategyType* ElongatedCylinderPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderPointSamplingStrategyType (*this, f, c);
    }

    ElongatedCylinderPointSamplingStrategyType& ElongatedCylinderPointSamplingStrategyType::
    operator= (const ElongatedCylinderPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ElongatedCylinderPointSamplingStrategyType::
    ~ElongatedCylinderPointSamplingStrategyType ()
    {
    }

    // IfThenExtrudedCrossSectionRuleType
    //

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType (const IfThenExtrudedCrossSectionRuleType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenExtrudedCrossSectionRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenExtrudedCrossSectionRuleType* IfThenExtrudedCrossSectionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenExtrudedCrossSectionRuleType (*this, f, c);
    }

    IfThenExtrudedCrossSectionRuleType& IfThenExtrudedCrossSectionRuleType::
    operator= (const IfThenExtrudedCrossSectionRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenExtrudedCrossSectionRuleType::
    ~IfThenExtrudedCrossSectionRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenExtrudedCrossSectionRuleType >
    _xsd_IfThenExtrudedCrossSectionRuleType_type_factory_init (
      "IfThenExtrudedCrossSectionRuleType",
      "http://qifstandards.org/xsd/qif2");

    // ExtrudedCrossSectionPointSamplingStrategyType
    //

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType (const ExtrudedCrossSectionPointSamplingStrategyType& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionPointSamplingStrategyType* ExtrudedCrossSectionPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionPointSamplingStrategyType (*this, f, c);
    }

    ExtrudedCrossSectionPointSamplingStrategyType& ExtrudedCrossSectionPointSamplingStrategyType::
    operator= (const ExtrudedCrossSectionPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ~ExtrudedCrossSectionPointSamplingStrategyType ()
    {
    }

    // IfThenLineRuleType
    //

    IfThenLineRuleType::
    IfThenLineRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenLineRuleType::
    IfThenLineRuleType (const IfThenLineRuleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenLineRuleType::
    IfThenLineRuleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenLineRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenLineRuleType* IfThenLineRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenLineRuleType (*this, f, c);
    }

    IfThenLineRuleType& IfThenLineRuleType::
    operator= (const IfThenLineRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenLineRuleType::
    ~IfThenLineRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenLineRuleType >
    _xsd_IfThenLineRuleType_type_factory_init (
      "IfThenLineRuleType",
      "http://qifstandards.org/xsd/qif2");

    // LinePointSamplingStrategyType
    //

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType (const LinePointSamplingStrategyType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LinePointSamplingStrategyType* LinePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinePointSamplingStrategyType (*this, f, c);
    }

    LinePointSamplingStrategyType& LinePointSamplingStrategyType::
    operator= (const LinePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    LinePointSamplingStrategyType::
    ~LinePointSamplingStrategyType ()
    {
    }

    // IfThenOppositeLinesRuleType
    //

    IfThenOppositeLinesRuleType::
    IfThenOppositeLinesRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenOppositeLinesRuleType::
    IfThenOppositeLinesRuleType (const IfThenOppositeLinesRuleType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositeLinesRuleType::
    IfThenOppositeLinesRuleType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositeLinesRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositeLinesRuleType* IfThenOppositeLinesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositeLinesRuleType (*this, f, c);
    }

    IfThenOppositeLinesRuleType& IfThenOppositeLinesRuleType::
    operator= (const IfThenOppositeLinesRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenOppositeLinesRuleType::
    ~IfThenOppositeLinesRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenOppositeLinesRuleType >
    _xsd_IfThenOppositeLinesRuleType_type_factory_init (
      "IfThenOppositeLinesRuleType",
      "http://qifstandards.org/xsd/qif2");

    // OppositeLinesPointSamplingStrategyType
    //

    OppositeLinesPointSamplingStrategyType::
    OppositeLinesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    OppositeLinesPointSamplingStrategyType::
    OppositeLinesPointSamplingStrategyType (const OppositeLinesPointSamplingStrategyType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositeLinesPointSamplingStrategyType::
    OppositeLinesPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesPointSamplingStrategyType* OppositeLinesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesPointSamplingStrategyType (*this, f, c);
    }

    OppositeLinesPointSamplingStrategyType& OppositeLinesPointSamplingStrategyType::
    operator= (const OppositeLinesPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    OppositeLinesPointSamplingStrategyType::
    ~OppositeLinesPointSamplingStrategyType ()
    {
    }

    // IfThenOppositePlanesRuleType
    //

    IfThenOppositePlanesRuleType::
    IfThenOppositePlanesRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenOppositePlanesRuleType::
    IfThenOppositePlanesRuleType (const IfThenOppositePlanesRuleType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositePlanesRuleType::
    IfThenOppositePlanesRuleType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositePlanesRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositePlanesRuleType* IfThenOppositePlanesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositePlanesRuleType (*this, f, c);
    }

    IfThenOppositePlanesRuleType& IfThenOppositePlanesRuleType::
    operator= (const IfThenOppositePlanesRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenOppositePlanesRuleType::
    ~IfThenOppositePlanesRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenOppositePlanesRuleType >
    _xsd_IfThenOppositePlanesRuleType_type_factory_init (
      "IfThenOppositePlanesRuleType",
      "http://qifstandards.org/xsd/qif2");

    // OppositePlanesPointSamplingStrategyType
    //

    OppositePlanesPointSamplingStrategyType::
    OppositePlanesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    OppositePlanesPointSamplingStrategyType::
    OppositePlanesPointSamplingStrategyType (const OppositePlanesPointSamplingStrategyType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositePlanesPointSamplingStrategyType::
    OppositePlanesPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesPointSamplingStrategyType* OppositePlanesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesPointSamplingStrategyType (*this, f, c);
    }

    OppositePlanesPointSamplingStrategyType& OppositePlanesPointSamplingStrategyType::
    operator= (const OppositePlanesPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    OppositePlanesPointSamplingStrategyType::
    ~OppositePlanesPointSamplingStrategyType ()
    {
    }

    // IfThenPlaneRuleType
    //

    IfThenPlaneRuleType::
    IfThenPlaneRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenPlaneRuleType::
    IfThenPlaneRuleType (const IfThenPlaneRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPlaneRuleType::
    IfThenPlaneRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPlaneRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPlaneRuleType* IfThenPlaneRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPlaneRuleType (*this, f, c);
    }

    IfThenPlaneRuleType& IfThenPlaneRuleType::
    operator= (const IfThenPlaneRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenPlaneRuleType::
    ~IfThenPlaneRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenPlaneRuleType >
    _xsd_IfThenPlaneRuleType_type_factory_init (
      "IfThenPlaneRuleType",
      "http://qifstandards.org/xsd/qif2");

    // PlanePointSamplingStrategyType
    //

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType (const PlanePointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlanePointSamplingStrategyType* PlanePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePointSamplingStrategyType (*this, f, c);
    }

    PlanePointSamplingStrategyType& PlanePointSamplingStrategyType::
    operator= (const PlanePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PlanePointSamplingStrategyType::
    ~PlanePointSamplingStrategyType ()
    {
    }

    // IfThenPointDefinedCurveRuleType
    //

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType (const IfThenPointDefinedCurveRuleType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPointDefinedCurveRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPointDefinedCurveRuleType* IfThenPointDefinedCurveRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointDefinedCurveRuleType (*this, f, c);
    }

    IfThenPointDefinedCurveRuleType& IfThenPointDefinedCurveRuleType::
    operator= (const IfThenPointDefinedCurveRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenPointDefinedCurveRuleType::
    ~IfThenPointDefinedCurveRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenPointDefinedCurveRuleType >
    _xsd_IfThenPointDefinedCurveRuleType_type_factory_init (
      "IfThenPointDefinedCurveRuleType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedCurvePointSamplingStrategyType
    //

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType (const PointDefinedCurvePointSamplingStrategyType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurvePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurvePointSamplingStrategyType* PointDefinedCurvePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurvePointSamplingStrategyType (*this, f, c);
    }

    PointDefinedCurvePointSamplingStrategyType& PointDefinedCurvePointSamplingStrategyType::
    operator= (const PointDefinedCurvePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PointDefinedCurvePointSamplingStrategyType::
    ~PointDefinedCurvePointSamplingStrategyType ()
    {
    }

    // IfThenPointDefinedSurfaceRuleType
    //

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType (const IfThenPointDefinedSurfaceRuleType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPointDefinedSurfaceRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPointDefinedSurfaceRuleType* IfThenPointDefinedSurfaceRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointDefinedSurfaceRuleType (*this, f, c);
    }

    IfThenPointDefinedSurfaceRuleType& IfThenPointDefinedSurfaceRuleType::
    operator= (const IfThenPointDefinedSurfaceRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenPointDefinedSurfaceRuleType::
    ~IfThenPointDefinedSurfaceRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenPointDefinedSurfaceRuleType >
    _xsd_IfThenPointDefinedSurfaceRuleType_type_factory_init (
      "IfThenPointDefinedSurfaceRuleType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedSurfacePointSamplingStrategyType
    //

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType (const PointDefinedSurfacePointSamplingStrategyType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfacePointSamplingStrategyType* PointDefinedSurfacePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfacePointSamplingStrategyType (*this, f, c);
    }

    PointDefinedSurfacePointSamplingStrategyType& PointDefinedSurfacePointSamplingStrategyType::
    operator= (const PointDefinedSurfacePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PointDefinedSurfacePointSamplingStrategyType::
    ~PointDefinedSurfacePointSamplingStrategyType ()
    {
    }

    // IfThenPointRuleType
    //

    IfThenPointRuleType::
    IfThenPointRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this)
    {
    }

    IfThenPointRuleType::
    IfThenPointRuleType (const IfThenPointRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this)
    {
    }

    IfThenPointRuleType::
    IfThenPointRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPointRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPointRuleType* IfThenPointRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointRuleType (*this, f, c);
    }

    IfThenPointRuleType& IfThenPointRuleType::
    operator= (const IfThenPointRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
      }

      return *this;
    }

    IfThenPointRuleType::
    ~IfThenPointRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenPointRuleType >
    _xsd_IfThenPointRuleType_type_factory_init (
      "IfThenPointRuleType",
      "http://qifstandards.org/xsd/qif2");

    // PointPointSamplingStrategyType
    //

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType (const PointPointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointPointSamplingStrategyType* PointPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointPointSamplingStrategyType (*this, f, c);
    }

    PointPointSamplingStrategyType& PointPointSamplingStrategyType::
    operator= (const PointPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PointPointSamplingStrategyType::
    ~PointPointSamplingStrategyType ()
    {
    }

    // IfThenSphereRuleType
    //

    IfThenSphereRuleType::
    IfThenSphereRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenSphereRuleType::
    IfThenSphereRuleType (const IfThenSphereRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSphereRuleType::
    IfThenSphereRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenSphereRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenSphereRuleType* IfThenSphereRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSphereRuleType (*this, f, c);
    }

    IfThenSphereRuleType& IfThenSphereRuleType::
    operator= (const IfThenSphereRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenSphereRuleType::
    ~IfThenSphereRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenSphereRuleType >
    _xsd_IfThenSphereRuleType_type_factory_init (
      "IfThenSphereRuleType",
      "http://qifstandards.org/xsd/qif2");

    // SpherePointSamplingStrategyType
    //

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType (const SpherePointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SpherePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SpherePointSamplingStrategyType* SpherePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpherePointSamplingStrategyType (*this, f, c);
    }

    SpherePointSamplingStrategyType& SpherePointSamplingStrategyType::
    operator= (const SpherePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    SpherePointSamplingStrategyType::
    ~SpherePointSamplingStrategyType ()
    {
    }

    // IfThenSphericalSegmentRuleType
    //

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType (const IfThenSphericalSegmentRuleType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenSphericalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenSphericalSegmentRuleType* IfThenSphericalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSphericalSegmentRuleType (*this, f, c);
    }

    IfThenSphericalSegmentRuleType& IfThenSphericalSegmentRuleType::
    operator= (const IfThenSphericalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenSphericalSegmentRuleType::
    ~IfThenSphericalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenSphericalSegmentRuleType >
    _xsd_IfThenSphericalSegmentRuleType_type_factory_init (
      "IfThenSphericalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");

    // SphericalSegmentPointSamplingStrategyType
    //

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType (const SphericalSegmentPointSamplingStrategyType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentPointSamplingStrategyType* SphericalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentPointSamplingStrategyType (*this, f, c);
    }

    SphericalSegmentPointSamplingStrategyType& SphericalSegmentPointSamplingStrategyType::
    operator= (const SphericalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    SphericalSegmentPointSamplingStrategyType::
    ~SphericalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenSurfaceOfRevolutionRuleType
    //

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType (const IfThenSurfaceOfRevolutionRuleType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenSurfaceOfRevolutionRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenSurfaceOfRevolutionRuleType* IfThenSurfaceOfRevolutionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSurfaceOfRevolutionRuleType (*this, f, c);
    }

    IfThenSurfaceOfRevolutionRuleType& IfThenSurfaceOfRevolutionRuleType::
    operator= (const IfThenSurfaceOfRevolutionRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenSurfaceOfRevolutionRuleType::
    ~IfThenSurfaceOfRevolutionRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenSurfaceOfRevolutionRuleType >
    _xsd_IfThenSurfaceOfRevolutionRuleType_type_factory_init (
      "IfThenSurfaceOfRevolutionRuleType",
      "http://qifstandards.org/xsd/qif2");

    // SurfaceOfRevolutionPointSamplingStrategyType
    //

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType (const SurfaceOfRevolutionPointSamplingStrategyType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionPointSamplingStrategyType* SurfaceOfRevolutionPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionPointSamplingStrategyType (*this, f, c);
    }

    SurfaceOfRevolutionPointSamplingStrategyType& SurfaceOfRevolutionPointSamplingStrategyType::
    operator= (const SurfaceOfRevolutionPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    ~SurfaceOfRevolutionPointSamplingStrategyType ()
    {
    }

    // IfThenToroidalSegmentRuleType
    //

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType (const IfThenToroidalSegmentRuleType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenToroidalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenToroidalSegmentRuleType* IfThenToroidalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenToroidalSegmentRuleType (*this, f, c);
    }

    IfThenToroidalSegmentRuleType& IfThenToroidalSegmentRuleType::
    operator= (const IfThenToroidalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenToroidalSegmentRuleType::
    ~IfThenToroidalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenToroidalSegmentRuleType >
    _xsd_IfThenToroidalSegmentRuleType_type_factory_init (
      "IfThenToroidalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");

    // ToroidalSegmentPointSamplingStrategyType
    //

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType (const ToroidalSegmentPointSamplingStrategyType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentPointSamplingStrategyType* ToroidalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentPointSamplingStrategyType (*this, f, c);
    }

    ToroidalSegmentPointSamplingStrategyType& ToroidalSegmentPointSamplingStrategyType::
    operator= (const ToroidalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ToroidalSegmentPointSamplingStrategyType::
    ~ToroidalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenTorusRuleType
    //

    IfThenTorusRuleType::
    IfThenTorusRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenTorusRuleType::
    IfThenTorusRuleType (const IfThenTorusRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenTorusRuleType::
    IfThenTorusRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenTorusRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenTorusRuleType* IfThenTorusRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenTorusRuleType (*this, f, c);
    }

    IfThenTorusRuleType& IfThenTorusRuleType::
    operator= (const IfThenTorusRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenTorusRuleType::
    ~IfThenTorusRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenTorusRuleType >
    _xsd_IfThenTorusRuleType_type_factory_init (
      "IfThenTorusRuleType",
      "http://qifstandards.org/xsd/qif2");

    // TorusPointSamplingStrategyType
    //

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType (const TorusPointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusPointSamplingStrategyType* TorusPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusPointSamplingStrategyType (*this, f, c);
    }

    TorusPointSamplingStrategyType& TorusPointSamplingStrategyType::
    operator= (const TorusPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    TorusPointSamplingStrategyType::
    ~TorusPointSamplingStrategyType ()
    {
    }

    // IfThenSurfaceRuleType
    //

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType ()
    {
    }

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType (const IfThenSurfaceRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c)
    {
    }

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f, c)
    {
    }

    IfThenSurfaceRuleType* IfThenSurfaceRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSurfaceRuleType (*this, f, c);
    }

    IfThenSurfaceRuleType::
    ~IfThenSurfaceRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenSurfaceRuleType >
    _xsd_IfThenSurfaceRuleType_type_factory_init (
      "IfThenSurfaceRuleType",
      "http://qifstandards.org/xsd/qif2");

    // IfThenCurveRuleType
    //

    IfThenCurveRuleType::
    IfThenCurveRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType ()
    {
    }

    IfThenCurveRuleType::
    IfThenCurveRuleType (const IfThenCurveRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c)
    {
    }

    IfThenCurveRuleType::
    IfThenCurveRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f, c)
    {
    }

    IfThenCurveRuleType* IfThenCurveRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCurveRuleType (*this, f, c);
    }

    IfThenCurveRuleType::
    ~IfThenCurveRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, IfThenCurveRuleType >
    _xsd_IfThenCurveRuleType_type_factory_init (
      "IfThenCurveRuleType",
      "http://qifstandards.org/xsd/qif2");

    // DMESelectionRuleType
    //

    DMESelectionRuleType::
    DMESelectionRuleType ()
    : ::xml_schema::type ()
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const DMESelectionRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    DMESelectionRuleType* DMESelectionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMESelectionRuleType (*this, f, c);
    }

    DMESelectionRuleType::
    ~DMESelectionRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenCurveRuleType >
    _xsd_IfThenCurveRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCurveRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenSurfaceRuleType >
    _xsd_IfThenSurfaceRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSurfaceRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenArcRuleType >
    _xsd_IfThenArcRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenArcRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenCircleRuleType >
    _xsd_IfThenCircleRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCircleRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenConeRuleType >
    _xsd_IfThenConeRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenConeRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenConicalSegmentRuleType >
    _xsd_IfThenConicalSegmentRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenConicalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenCuboidRuleType >
    _xsd_IfThenCuboidRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCuboidRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenCylinderRuleType >
    _xsd_IfThenCylinderRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCylinderRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    _xsd_IfThenCylindricalSegmentRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCylindricalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenEllipseRuleType >
    _xsd_IfThenEllipseRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenEllipseRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenElongatedCylinderRuleType >
    _xsd_IfThenElongatedCylinderRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenElongatedCylinderRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    _xsd_IfThenExtrudedCrossSectionRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenExtrudedCrossSectionRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenLineRuleType >
    _xsd_IfThenLineRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenLineRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenOppositeLinesRuleType >
    _xsd_IfThenOppositeLinesRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenOppositeLinesRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenOppositePlanesRuleType >
    _xsd_IfThenOppositePlanesRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenOppositePlanesRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenPlaneRuleType >
    _xsd_IfThenPlaneRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPlaneRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    _xsd_IfThenPointDefinedCurveRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPointDefinedCurveRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    _xsd_IfThenPointDefinedSurfaceRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPointDefinedSurfaceRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenPointRuleType >
    _xsd_IfThenPointRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPointRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenSphereRuleType >
    _xsd_IfThenSphereRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSphereRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenSphericalSegmentRuleType >
    _xsd_IfThenSphericalSegmentRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSphericalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    _xsd_IfThenSurfaceOfRevolutionRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSurfaceOfRevolutionRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenToroidalSegmentRuleType >
    _xsd_IfThenToroidalSegmentRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenToroidalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::IfThenTorusRuleType >
    _xsd_IfThenTorusRule_element_factory_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenTorusRule",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::QIFRulesType > (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::QIFRulesType > (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::QIFRulesType > (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Rules (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Rules (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::QIFRulesType > (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::QIFRulesType > (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::QIFRulesType > (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::QIFRulesType > (
          ::xsd::qif2::Rules (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Rules" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::QIFRulesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Rules",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Rules" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::QIFRulesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Rules",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenFeatureRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenFeatureRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > (
          ::xsd::qif2::IfThenFeatureRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenFeatureRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenFeatureRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenFeatureRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenFeatureRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenFeatureRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenFeatureRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenFeatureRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenFeatureRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > (
          ::xsd::qif2::IfThenCurveRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCurveRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCurveRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCurveRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCurveRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCurveRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCurveRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > (
          ::xsd::qif2::IfThenSurfaceRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSurfaceRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSurfaceRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSurfaceRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSurfaceRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenArcRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenArcRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > (
          ::xsd::qif2::IfThenArcRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenArcRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenArcRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenArcRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenArcRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenArcRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenArcRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenArcRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenArcRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCircleRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCircleRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > (
          ::xsd::qif2::IfThenCircleRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCircleRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCircleRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCircleRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCircleRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCircleRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCircleRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCircleRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCircleRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConeRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConeRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > (
          ::xsd::qif2::IfThenConeRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenConeRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenConeRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenConeRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConeRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenConeRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenConeRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenConeRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConeRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::xercesc::DOMDocument& doc,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > (
          ::xsd::qif2::IfThenConicalSegmentRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenConicalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenConicalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenConicalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConicalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenConicalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenConicalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenConicalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConicalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCuboidRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCuboidRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > (
          ::xsd::qif2::IfThenCuboidRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCuboidRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCuboidRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCuboidRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCuboidRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCuboidRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCuboidRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCuboidRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCuboidRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > (
          ::xsd::qif2::IfThenCylinderRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCylinderRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCylinderRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCylinderRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCylinderRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::xercesc::DOMDocument& doc,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > (
          ::xsd::qif2::IfThenCylindricalSegmentRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCylindricalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCylindricalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCylindricalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylindricalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenCylindricalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenCylindricalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenCylindricalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylindricalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenEllipseRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenEllipseRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > (
          ::xsd::qif2::IfThenEllipseRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenEllipseRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenEllipseRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenEllipseRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenEllipseRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenEllipseRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenEllipseRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenEllipseRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenEllipseRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::xercesc::DOMDocument& doc,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > (
          ::xsd::qif2::IfThenElongatedCylinderRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenElongatedCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenElongatedCylinderRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenElongatedCylinderRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenElongatedCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenElongatedCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenElongatedCylinderRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenElongatedCylinderRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenElongatedCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::xercesc::DOMDocument& doc,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > (
          ::xsd::qif2::IfThenExtrudedCrossSectionRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenExtrudedCrossSectionRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenExtrudedCrossSectionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenExtrudedCrossSectionRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenExtrudedCrossSectionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenLineRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenLineRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > (
          ::xsd::qif2::IfThenLineRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenLineRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenLineRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenLineRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenLineRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenLineRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenLineRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenLineRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenLineRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::xercesc::DOMDocument& doc,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > (
          ::xsd::qif2::IfThenOppositeLinesRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenOppositeLinesRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenOppositeLinesRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenOppositeLinesRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositeLinesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenOppositeLinesRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenOppositeLinesRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenOppositeLinesRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositeLinesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::xercesc::DOMDocument& doc,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > (
          ::xsd::qif2::IfThenOppositePlanesRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenOppositePlanesRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenOppositePlanesRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenOppositePlanesRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositePlanesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenOppositePlanesRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenOppositePlanesRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenOppositePlanesRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositePlanesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPlaneRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPlaneRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > (
          ::xsd::qif2::IfThenPlaneRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPlaneRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPlaneRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPlaneRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPlaneRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPlaneRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPlaneRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPlaneRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPlaneRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::xercesc::DOMDocument& doc,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > (
          ::xsd::qif2::IfThenPointDefinedCurveRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPointDefinedCurveRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPointDefinedCurveRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPointDefinedCurveRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPointDefinedCurveRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPointDefinedCurveRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPointDefinedCurveRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::xercesc::DOMDocument& doc,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > (
          ::xsd::qif2::IfThenPointDefinedSurfaceRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPointDefinedSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPointDefinedSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > (
          ::xsd::qif2::IfThenPointRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPointRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPointRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPointRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenPointRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenPointRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenPointRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphereRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphereRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > (
          ::xsd::qif2::IfThenSphereRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSphereRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSphereRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSphereRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphereRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSphereRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSphereRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSphereRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphereRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::std::string& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                const ::std::string& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xercesc::InputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::xercesc::DOMDocument& doc,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > (
          ::xsd::qif2::IfThenSphericalSegmentRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSphericalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSphericalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSphericalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphericalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSphericalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSphericalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSphericalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphericalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::xercesc::DOMDocument& doc,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > (
          ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSurfaceOfRevolutionRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceOfRevolutionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenSurfaceOfRevolutionRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceOfRevolutionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::xercesc::DOMDocument& doc,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > (
          ::xsd::qif2::IfThenToroidalSegmentRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenToroidalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenToroidalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenToroidalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenToroidalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenToroidalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenToroidalSegmentRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenToroidalSegmentRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenToroidalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenTorusRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenTorusRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > (
          ::xsd::qif2::IfThenTorusRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenTorusRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenTorusRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenTorusRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenTorusRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IfThenTorusRule",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::IfThenTorusRuleType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
          dynamic_cast< ::xsd::qif2::IfThenTorusRuleType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenTorusRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DMESelectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DMESelectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > (
          ::xsd::qif2::DMESelectionRule (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "DMESelectionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::DMESelectionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DMESelectionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "DMESelectionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::DMESelectionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DMESelectionRule",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    Rules (::std::ostream& o,
           const ::xsd::qif2::QIFRulesType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Rules (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Rules (::std::ostream& o,
           const ::xsd::qif2::QIFRulesType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Rules (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Rules (::std::ostream& o,
           const ::xsd::qif2::QIFRulesType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Rules (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Rules (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::QIFRulesType& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Rules (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Rules (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::QIFRulesType& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Rules (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Rules (::xercesc::XMLFormatTarget& t,
           const ::xsd::qif2::QIFRulesType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Rules (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Rules (::xercesc::DOMDocument& d,
           const ::xsd::qif2::QIFRulesType& s,
           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Rules" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Rules",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Rules (const ::xsd::qif2::QIFRulesType& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Rules",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::Rules (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const QIFRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Version",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Version ();
      }

      // RulesUnits
      //
      if (i.RulesUnits ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RulesUnits",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RulesUnits ();
      }

      // FeatureRules
      //
      if (i.FeatureRules ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureRules",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureRules ();
      }

      // DMESelectionRules
      //
      if (i.DMESelectionRules ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DMESelectionRules",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DMESelectionRules ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SamplingRigorMax
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SamplingRigorMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SamplingRigorMax ();
      }

      // IfThenElseFeatureRules
      //
      if (i.IfThenElseFeatureRules ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IfThenElseFeatureRules",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.IfThenElseFeatureRules ();
      }

      // MaxFeatureRules
      //
      if (i.MaxFeatureRules ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxFeatureRules",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxFeatureRules ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const QIFRuleBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      if (i.name ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << *i.name ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenElseFeatureRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IfThenFeatureRule
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (IfThenElseFeatureRulesType::IfThenFeatureRule_const_iterator
             b (i.IfThenFeatureRule ().begin ()), n (i.IfThenFeatureRule ().end ());
             b != n; ++b)
        {
          if (typeid (IfThenElseFeatureRulesType::IfThenFeatureRule_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "IfThenFeatureRule",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "IfThenFeatureRule",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }

      // Else
      //
      if (i.Else ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Else",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Else ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MaxFeatureRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IfThenFeatureRule
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (MaxFeatureRulesType::IfThenFeatureRule_const_iterator
             b (i.IfThenFeatureRule ().begin ()), n (i.IfThenFeatureRule ().end ());
             b != n; ++b)
        {
          if (typeid (MaxFeatureRulesType::IfThenFeatureRule_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "IfThenFeatureRule",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "IfThenFeatureRule",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }

      // Else
      //
      if (i.Else ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Else",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Else ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DMESelectionRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DMESelectionRule
      //
      for (DMESelectionRulesType::DMESelectionRule_const_iterator
           b (i.DMESelectionRule ().begin ()), n (i.DMESelectionRule ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DMESelectionRule",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointRuleBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::QIFRuleBaseType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenFeatureRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::PointRuleBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.BooleanExpression ())
        {
          const IfThenFeatureRuleType::BooleanExpression_type& x (*i.BooleanExpression ());
          if (typeid (IfThenFeatureRuleType::BooleanExpression_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BooleanExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, x);
        }
      }

      // ThenPoints
      //
      if (i.ThenPoints ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPoints ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenFeatureRuleType >
    _xsd_IfThenFeatureRuleType_type_serializer_init (
      "IfThenFeatureRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ElseRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::PointRuleBaseType& > (i);

      // ThenPoints
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThenPoints ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThenPointsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NumberOfPoints
      //
      if (i.NumberOfPoints ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NumberOfPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NumberOfPoints ();
      }

      // MinPoints
      //
      if (i.MinPoints ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinPoints ();
      }

      // PointDensity
      //
      if (i.PointDensity ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointDensity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointDensity ();
      }

      // MinPointDensity
      //
      if (i.MinPointDensity ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinPointDensity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinPointDensity ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenArcRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenArcRuleType >
    _xsd_IfThenArcRuleType_type_serializer_init (
      "IfThenArcRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArcPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenCircleRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenCircleRuleType >
    _xsd_IfThenCircleRuleType_type_serializer_init (
      "IfThenCircleRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CirclePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenConeRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenConeRuleType >
    _xsd_IfThenConeRuleType_type_serializer_init (
      "IfThenConeRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenConicalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenConicalSegmentRuleType >
    _xsd_IfThenConicalSegmentRuleType_type_serializer_init (
      "IfThenConicalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenCuboidRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenCuboidRuleType >
    _xsd_IfThenCuboidRuleType_type_serializer_init (
      "IfThenCuboidRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CuboidPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenCylinderRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenCylinderRuleType >
    _xsd_IfThenCylinderRuleType_type_serializer_init (
      "IfThenCylinderRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylinderPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenCylindricalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenCylindricalSegmentRuleType >
    _xsd_IfThenCylindricalSegmentRuleType_type_serializer_init (
      "IfThenCylindricalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenEllipseRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenEllipseRuleType >
    _xsd_IfThenEllipseRuleType_type_serializer_init (
      "IfThenEllipseRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EllipsePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenElongatedCylinderRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenElongatedCylinderRuleType >
    _xsd_IfThenElongatedCylinderRuleType_type_serializer_init (
      "IfThenElongatedCylinderRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenExtrudedCrossSectionRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenExtrudedCrossSectionRuleType >
    _xsd_IfThenExtrudedCrossSectionRuleType_type_serializer_init (
      "IfThenExtrudedCrossSectionRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenLineRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenLineRuleType >
    _xsd_IfThenLineRuleType_type_serializer_init (
      "IfThenLineRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LinePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenOppositeLinesRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenOppositeLinesRuleType >
    _xsd_IfThenOppositeLinesRuleType_type_serializer_init (
      "IfThenOppositeLinesRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenOppositePlanesRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenOppositePlanesRuleType >
    _xsd_IfThenOppositePlanesRuleType_type_serializer_init (
      "IfThenOppositePlanesRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenPlaneRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenPlaneRuleType >
    _xsd_IfThenPlaneRuleType_type_serializer_init (
      "IfThenPlaneRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PlanePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenPointDefinedCurveRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenPointDefinedCurveRuleType >
    _xsd_IfThenPointDefinedCurveRuleType_type_serializer_init (
      "IfThenPointDefinedCurveRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurvePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenPointDefinedSurfaceRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenPointDefinedSurfaceRuleType >
    _xsd_IfThenPointDefinedSurfaceRuleType_type_serializer_init (
      "IfThenPointDefinedSurfaceRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfacePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenPointRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenPointRuleType >
    _xsd_IfThenPointRuleType_type_serializer_init (
      "IfThenPointRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenSphereRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenSphereRuleType >
    _xsd_IfThenSphereRuleType_type_serializer_init (
      "IfThenSphereRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SpherePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenSphericalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenSphericalSegmentRuleType >
    _xsd_IfThenSphericalSegmentRuleType_type_serializer_init (
      "IfThenSphericalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenSurfaceOfRevolutionRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenSurfaceOfRevolutionRuleType >
    _xsd_IfThenSurfaceOfRevolutionRuleType_type_serializer_init (
      "IfThenSurfaceOfRevolutionRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenToroidalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenToroidalSegmentRuleType >
    _xsd_IfThenToroidalSegmentRuleType_type_serializer_init (
      "IfThenToroidalSegmentRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenTorusRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenPointStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThenFittingAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenTorusRuleType >
    _xsd_IfThenTorusRuleType_type_serializer_init (
      "IfThenTorusRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TorusPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointSamplingStrategyEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UserDefinedStrategy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IfThenSurfaceRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenSurfaceRuleType >
    _xsd_IfThenSurfaceRuleType_type_serializer_init (
      "IfThenSurfaceRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const IfThenCurveRuleType& i)
    {
      e << static_cast< const ::xsd::qif2::IfThenFeatureRuleType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IfThenCurveRuleType >
    _xsd_IfThenCurveRuleType_type_serializer_init (
      "IfThenCurveRuleType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DMESelectionRuleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const DMESelectionRuleType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const DMESelectionRuleType&)
    {
    }

    void
    IfThenFeatureRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenFeatureRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenFeatureRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenFeatureRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenFeatureRuleType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenFeatureRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenFeatureRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenFeatureRuleType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenFeatureRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenFeatureRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenFeatureRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenFeatureRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenFeatureRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenFeatureRuleType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenFeatureRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenFeatureRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenFeatureRuleType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenFeatureRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenFeatureRule (::xercesc::DOMDocument& d,
                       const ::xsd::qif2::IfThenFeatureRuleType& s,
                       ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenFeatureRuleType) == typeid (s))
      {
        if (n.name () == "IfThenFeatureRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenFeatureRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenFeatureRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenFeatureRule (const ::xsd::qif2::IfThenFeatureRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenFeatureRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenFeatureRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenFeatureRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenFeatureRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenCurveRuleType >
    _xsd_IfThenCurveRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCurveRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenCurveRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenCurveRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCurveRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCurveRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenCurveRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCurveRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCurveRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenCurveRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCurveRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCurveRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenCurveRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCurveRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCurveRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenCurveRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCurveRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCurveRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenCurveRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCurveRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCurveRule (::xercesc::DOMDocument& d,
                     const ::xsd::qif2::IfThenCurveRuleType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenCurveRuleType) == typeid (s))
      {
        if (n.name () == "IfThenCurveRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenCurveRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCurveRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenCurveRule (const ::xsd::qif2::IfThenCurveRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenCurveRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenCurveRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCurveRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenCurveRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenSurfaceRuleType >
    _xsd_IfThenSurfaceRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSurfaceRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenSurfaceRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSurfaceRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSurfaceRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceRule (::xercesc::DOMDocument& d,
                       const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenSurfaceRuleType) == typeid (s))
      {
        if (n.name () == "IfThenSurfaceRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenSurfaceRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenSurfaceRule (const ::xsd::qif2::IfThenSurfaceRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenSurfaceRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenSurfaceRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenArcRuleType >
    _xsd_IfThenArcRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenArcRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenArcRule (::std::ostream& o,
                   const ::xsd::qif2::IfThenArcRuleType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenArcRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenArcRule (::std::ostream& o,
                   const ::xsd::qif2::IfThenArcRuleType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenArcRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenArcRule (::std::ostream& o,
                   const ::xsd::qif2::IfThenArcRuleType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenArcRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenArcRule (::xercesc::XMLFormatTarget& t,
                   const ::xsd::qif2::IfThenArcRuleType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenArcRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenArcRule (::xercesc::XMLFormatTarget& t,
                   const ::xsd::qif2::IfThenArcRuleType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenArcRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenArcRule (::xercesc::XMLFormatTarget& t,
                   const ::xsd::qif2::IfThenArcRuleType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenArcRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenArcRule (::xercesc::DOMDocument& d,
                   const ::xsd::qif2::IfThenArcRuleType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenArcRuleType) == typeid (s))
      {
        if (n.name () == "IfThenArcRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenArcRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenArcRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenArcRule (const ::xsd::qif2::IfThenArcRuleType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenArcRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenArcRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenArcRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenArcRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenCircleRuleType >
    _xsd_IfThenCircleRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCircleRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenCircleRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenCircleRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCircleRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCircleRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenCircleRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCircleRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCircleRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenCircleRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCircleRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCircleRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenCircleRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCircleRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCircleRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenCircleRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCircleRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCircleRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenCircleRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCircleRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCircleRule (::xercesc::DOMDocument& d,
                      const ::xsd::qif2::IfThenCircleRuleType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenCircleRuleType) == typeid (s))
      {
        if (n.name () == "IfThenCircleRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenCircleRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCircleRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenCircleRule (const ::xsd::qif2::IfThenCircleRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenCircleRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenCircleRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCircleRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenCircleRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenConeRuleType >
    _xsd_IfThenConeRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenConeRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenConeRule (::std::ostream& o,
                    const ::xsd::qif2::IfThenConeRuleType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConeRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenConeRule (::std::ostream& o,
                    const ::xsd::qif2::IfThenConeRuleType& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConeRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConeRule (::std::ostream& o,
                    const ::xsd::qif2::IfThenConeRuleType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConeRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConeRule (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::IfThenConeRuleType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConeRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenConeRule (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::IfThenConeRuleType& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConeRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConeRule (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::IfThenConeRuleType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConeRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConeRule (::xercesc::DOMDocument& d,
                    const ::xsd::qif2::IfThenConeRuleType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenConeRuleType) == typeid (s))
      {
        if (n.name () == "IfThenConeRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenConeRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenConeRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenConeRule (const ::xsd::qif2::IfThenConeRuleType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenConeRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenConeRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenConeRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenConeRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenConicalSegmentRuleType >
    _xsd_IfThenConicalSegmentRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenConicalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenConicalSegmentRule (::std::ostream& o,
                              const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConicalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenConicalSegmentRule (::std::ostream& o,
                              const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              ::xml_schema::error_handler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConicalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConicalSegmentRule (::std::ostream& o,
                              const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConicalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConicalSegmentRule (::xercesc::XMLFormatTarget& t,
                              const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConicalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenConicalSegmentRule (::xercesc::XMLFormatTarget& t,
                              const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              ::xml_schema::error_handler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConicalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConicalSegmentRule (::xercesc::XMLFormatTarget& t,
                              const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenConicalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenConicalSegmentRule (::xercesc::DOMDocument& d,
                              const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenConicalSegmentRuleType) == typeid (s))
      {
        if (n.name () == "IfThenConicalSegmentRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenConicalSegmentRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenConicalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenConicalSegmentRule (const ::xsd::qif2::IfThenConicalSegmentRuleType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenConicalSegmentRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenConicalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenConicalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenConicalSegmentRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenCuboidRuleType >
    _xsd_IfThenCuboidRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCuboidRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenCuboidRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenCuboidRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCuboidRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCuboidRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenCuboidRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCuboidRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCuboidRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenCuboidRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCuboidRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCuboidRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenCuboidRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCuboidRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCuboidRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenCuboidRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCuboidRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCuboidRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenCuboidRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCuboidRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCuboidRule (::xercesc::DOMDocument& d,
                      const ::xsd::qif2::IfThenCuboidRuleType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenCuboidRuleType) == typeid (s))
      {
        if (n.name () == "IfThenCuboidRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenCuboidRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCuboidRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenCuboidRule (const ::xsd::qif2::IfThenCuboidRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenCuboidRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenCuboidRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCuboidRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenCuboidRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenCylinderRuleType >
    _xsd_IfThenCylinderRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCylinderRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenCylinderRule (::std::ostream& o,
                        const ::xsd::qif2::IfThenCylinderRuleType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylinderRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCylinderRule (::std::ostream& o,
                        const ::xsd::qif2::IfThenCylinderRuleType& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylinderRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylinderRule (::std::ostream& o,
                        const ::xsd::qif2::IfThenCylinderRuleType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylinderRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylinderRule (::xercesc::XMLFormatTarget& t,
                        const ::xsd::qif2::IfThenCylinderRuleType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylinderRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCylinderRule (::xercesc::XMLFormatTarget& t,
                        const ::xsd::qif2::IfThenCylinderRuleType& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylinderRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylinderRule (::xercesc::XMLFormatTarget& t,
                        const ::xsd::qif2::IfThenCylinderRuleType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylinderRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylinderRule (::xercesc::DOMDocument& d,
                        const ::xsd::qif2::IfThenCylinderRuleType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenCylinderRuleType) == typeid (s))
      {
        if (n.name () == "IfThenCylinderRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenCylinderRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenCylinderRule (const ::xsd::qif2::IfThenCylinderRuleType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenCylinderRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenCylinderRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    _xsd_IfThenCylindricalSegmentRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenCylindricalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenCylindricalSegmentRule (::std::ostream& o,
                                  const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylindricalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCylindricalSegmentRule (::std::ostream& o,
                                  const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  ::xml_schema::error_handler& h,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylindricalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylindricalSegmentRule (::std::ostream& o,
                                  const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylindricalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylindricalSegmentRule (::xercesc::XMLFormatTarget& t,
                                  const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylindricalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenCylindricalSegmentRule (::xercesc::XMLFormatTarget& t,
                                  const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  ::xml_schema::error_handler& h,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylindricalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylindricalSegmentRule (::xercesc::XMLFormatTarget& t,
                                  const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenCylindricalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenCylindricalSegmentRule (::xercesc::DOMDocument& d,
                                  const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenCylindricalSegmentRuleType) == typeid (s))
      {
        if (n.name () == "IfThenCylindricalSegmentRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenCylindricalSegmentRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCylindricalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenCylindricalSegmentRule (const ::xsd::qif2::IfThenCylindricalSegmentRuleType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenCylindricalSegmentRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenCylindricalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenCylindricalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenCylindricalSegmentRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenEllipseRuleType >
    _xsd_IfThenEllipseRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenEllipseRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenEllipseRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenEllipseRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenEllipseRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenEllipseRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenEllipseRuleType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenEllipseRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenEllipseRule (::std::ostream& o,
                       const ::xsd::qif2::IfThenEllipseRuleType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenEllipseRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenEllipseRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenEllipseRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenEllipseRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenEllipseRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenEllipseRuleType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenEllipseRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenEllipseRule (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::IfThenEllipseRuleType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenEllipseRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenEllipseRule (::xercesc::DOMDocument& d,
                       const ::xsd::qif2::IfThenEllipseRuleType& s,
                       ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenEllipseRuleType) == typeid (s))
      {
        if (n.name () == "IfThenEllipseRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenEllipseRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenEllipseRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenEllipseRule (const ::xsd::qif2::IfThenEllipseRuleType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenEllipseRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenEllipseRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenEllipseRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenEllipseRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenElongatedCylinderRuleType >
    _xsd_IfThenElongatedCylinderRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenElongatedCylinderRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenElongatedCylinderRule (::std::ostream& o,
                                 const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenElongatedCylinderRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenElongatedCylinderRule (::std::ostream& o,
                                 const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 ::xml_schema::error_handler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenElongatedCylinderRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenElongatedCylinderRule (::std::ostream& o,
                                 const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenElongatedCylinderRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenElongatedCylinderRule (::xercesc::XMLFormatTarget& t,
                                 const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenElongatedCylinderRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenElongatedCylinderRule (::xercesc::XMLFormatTarget& t,
                                 const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 ::xml_schema::error_handler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenElongatedCylinderRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenElongatedCylinderRule (::xercesc::XMLFormatTarget& t,
                                 const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenElongatedCylinderRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenElongatedCylinderRule (::xercesc::DOMDocument& d,
                                 const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenElongatedCylinderRuleType) == typeid (s))
      {
        if (n.name () == "IfThenElongatedCylinderRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenElongatedCylinderRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenElongatedCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenElongatedCylinderRule (const ::xsd::qif2::IfThenElongatedCylinderRuleType& s,
                                 const ::xml_schema::namespace_infomap& m,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenElongatedCylinderRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenElongatedCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenElongatedCylinderRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenElongatedCylinderRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    _xsd_IfThenExtrudedCrossSectionRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenExtrudedCrossSectionRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenExtrudedCrossSectionRule (::std::ostream& o,
                                    const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    const ::xml_schema::namespace_infomap& m,
                                    const ::std::string& e,
                                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenExtrudedCrossSectionRule (::std::ostream& o,
                                    const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    ::xml_schema::error_handler& h,
                                    const ::xml_schema::namespace_infomap& m,
                                    const ::std::string& e,
                                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenExtrudedCrossSectionRule (::std::ostream& o,
                                    const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    ::xercesc::DOMErrorHandler& h,
                                    const ::xml_schema::namespace_infomap& m,
                                    const ::std::string& e,
                                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenExtrudedCrossSectionRule (::xercesc::XMLFormatTarget& t,
                                    const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    const ::xml_schema::namespace_infomap& m,
                                    const ::std::string& e,
                                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenExtrudedCrossSectionRule (::xercesc::XMLFormatTarget& t,
                                    const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    ::xml_schema::error_handler& h,
                                    const ::xml_schema::namespace_infomap& m,
                                    const ::std::string& e,
                                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenExtrudedCrossSectionRule (::xercesc::XMLFormatTarget& t,
                                    const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    ::xercesc::DOMErrorHandler& h,
                                    const ::xml_schema::namespace_infomap& m,
                                    const ::std::string& e,
                                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenExtrudedCrossSectionRule (::xercesc::DOMDocument& d,
                                    const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenExtrudedCrossSectionRuleType) == typeid (s))
      {
        if (n.name () == "IfThenExtrudedCrossSectionRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenExtrudedCrossSectionRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenExtrudedCrossSectionRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenExtrudedCrossSectionRule (const ::xsd::qif2::IfThenExtrudedCrossSectionRuleType& s,
                                    const ::xml_schema::namespace_infomap& m,
                                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenExtrudedCrossSectionRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenExtrudedCrossSectionRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenExtrudedCrossSectionRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenExtrudedCrossSectionRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenLineRuleType >
    _xsd_IfThenLineRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenLineRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenLineRule (::std::ostream& o,
                    const ::xsd::qif2::IfThenLineRuleType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenLineRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenLineRule (::std::ostream& o,
                    const ::xsd::qif2::IfThenLineRuleType& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenLineRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenLineRule (::std::ostream& o,
                    const ::xsd::qif2::IfThenLineRuleType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenLineRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenLineRule (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::IfThenLineRuleType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenLineRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenLineRule (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::IfThenLineRuleType& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenLineRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenLineRule (::xercesc::XMLFormatTarget& t,
                    const ::xsd::qif2::IfThenLineRuleType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenLineRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenLineRule (::xercesc::DOMDocument& d,
                    const ::xsd::qif2::IfThenLineRuleType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenLineRuleType) == typeid (s))
      {
        if (n.name () == "IfThenLineRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenLineRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenLineRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenLineRule (const ::xsd::qif2::IfThenLineRuleType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenLineRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenLineRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenLineRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenLineRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenOppositeLinesRuleType >
    _xsd_IfThenOppositeLinesRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenOppositeLinesRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenOppositeLinesRule (::std::ostream& o,
                             const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::string& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositeLinesRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenOppositeLinesRule (::std::ostream& o,
                             const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             ::xml_schema::error_handler& h,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::string& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositeLinesRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositeLinesRule (::std::ostream& o,
                             const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::string& e,
                             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositeLinesRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositeLinesRule (::xercesc::XMLFormatTarget& t,
                             const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::string& e,
                             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositeLinesRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenOppositeLinesRule (::xercesc::XMLFormatTarget& t,
                             const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             ::xml_schema::error_handler& h,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::string& e,
                             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositeLinesRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositeLinesRule (::xercesc::XMLFormatTarget& t,
                             const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::string& e,
                             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositeLinesRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositeLinesRule (::xercesc::DOMDocument& d,
                             const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenOppositeLinesRuleType) == typeid (s))
      {
        if (n.name () == "IfThenOppositeLinesRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenOppositeLinesRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenOppositeLinesRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenOppositeLinesRule (const ::xsd::qif2::IfThenOppositeLinesRuleType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenOppositeLinesRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenOppositeLinesRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenOppositeLinesRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenOppositeLinesRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenOppositePlanesRuleType >
    _xsd_IfThenOppositePlanesRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenOppositePlanesRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenOppositePlanesRule (::std::ostream& o,
                              const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositePlanesRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenOppositePlanesRule (::std::ostream& o,
                              const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              ::xml_schema::error_handler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositePlanesRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositePlanesRule (::std::ostream& o,
                              const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositePlanesRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositePlanesRule (::xercesc::XMLFormatTarget& t,
                              const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositePlanesRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenOppositePlanesRule (::xercesc::XMLFormatTarget& t,
                              const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              ::xml_schema::error_handler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositePlanesRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositePlanesRule (::xercesc::XMLFormatTarget& t,
                              const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::string& e,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenOppositePlanesRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenOppositePlanesRule (::xercesc::DOMDocument& d,
                              const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenOppositePlanesRuleType) == typeid (s))
      {
        if (n.name () == "IfThenOppositePlanesRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenOppositePlanesRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenOppositePlanesRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenOppositePlanesRule (const ::xsd::qif2::IfThenOppositePlanesRuleType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenOppositePlanesRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenOppositePlanesRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenOppositePlanesRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenOppositePlanesRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenPlaneRuleType >
    _xsd_IfThenPlaneRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPlaneRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenPlaneRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenPlaneRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPlaneRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPlaneRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenPlaneRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPlaneRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPlaneRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenPlaneRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPlaneRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPlaneRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenPlaneRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPlaneRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPlaneRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenPlaneRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPlaneRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPlaneRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenPlaneRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPlaneRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPlaneRule (::xercesc::DOMDocument& d,
                     const ::xsd::qif2::IfThenPlaneRuleType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenPlaneRuleType) == typeid (s))
      {
        if (n.name () == "IfThenPlaneRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenPlaneRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPlaneRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenPlaneRule (const ::xsd::qif2::IfThenPlaneRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenPlaneRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenPlaneRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPlaneRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenPlaneRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    _xsd_IfThenPointDefinedCurveRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPointDefinedCurveRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenPointDefinedCurveRule (::std::ostream& o,
                                 const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedCurveRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPointDefinedCurveRule (::std::ostream& o,
                                 const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 ::xml_schema::error_handler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedCurveRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedCurveRule (::std::ostream& o,
                                 const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedCurveRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedCurveRule (::xercesc::XMLFormatTarget& t,
                                 const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedCurveRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPointDefinedCurveRule (::xercesc::XMLFormatTarget& t,
                                 const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 ::xml_schema::error_handler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedCurveRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedCurveRule (::xercesc::XMLFormatTarget& t,
                                 const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::xml_schema::namespace_infomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedCurveRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedCurveRule (::xercesc::DOMDocument& d,
                                 const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenPointDefinedCurveRuleType) == typeid (s))
      {
        if (n.name () == "IfThenPointDefinedCurveRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenPointDefinedCurveRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPointDefinedCurveRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenPointDefinedCurveRule (const ::xsd::qif2::IfThenPointDefinedCurveRuleType& s,
                                 const ::xml_schema::namespace_infomap& m,
                                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenPointDefinedCurveRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenPointDefinedCurveRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPointDefinedCurveRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenPointDefinedCurveRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    _xsd_IfThenPointDefinedSurfaceRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPointDefinedSurfaceRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenPointDefinedSurfaceRule (::std::ostream& o,
                                   const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPointDefinedSurfaceRule (::std::ostream& o,
                                   const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   ::xml_schema::error_handler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedSurfaceRule (::std::ostream& o,
                                   const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedSurfaceRule (::xercesc::XMLFormatTarget& t,
                                   const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPointDefinedSurfaceRule (::xercesc::XMLFormatTarget& t,
                                   const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   ::xml_schema::error_handler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedSurfaceRule (::xercesc::XMLFormatTarget& t,
                                   const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointDefinedSurfaceRule (::xercesc::DOMDocument& d,
                                   const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenPointDefinedSurfaceRuleType) == typeid (s))
      {
        if (n.name () == "IfThenPointDefinedSurfaceRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenPointDefinedSurfaceRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPointDefinedSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenPointDefinedSurfaceRule (const ::xsd::qif2::IfThenPointDefinedSurfaceRuleType& s,
                                   const ::xml_schema::namespace_infomap& m,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenPointDefinedSurfaceRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenPointDefinedSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPointDefinedSurfaceRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenPointDefinedSurfaceRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenPointRuleType >
    _xsd_IfThenPointRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenPointRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenPointRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenPointRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPointRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenPointRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenPointRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenPointRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenPointRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenPointRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenPointRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenPointRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenPointRule (::xercesc::DOMDocument& d,
                     const ::xsd::qif2::IfThenPointRuleType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenPointRuleType) == typeid (s))
      {
        if (n.name () == "IfThenPointRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenPointRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPointRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenPointRule (const ::xsd::qif2::IfThenPointRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenPointRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenPointRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenPointRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenPointRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenSphereRuleType >
    _xsd_IfThenSphereRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSphereRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenSphereRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenSphereRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphereRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSphereRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenSphereRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphereRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphereRule (::std::ostream& o,
                      const ::xsd::qif2::IfThenSphereRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphereRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphereRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenSphereRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphereRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSphereRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenSphereRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphereRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphereRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::IfThenSphereRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphereRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphereRule (::xercesc::DOMDocument& d,
                      const ::xsd::qif2::IfThenSphereRuleType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenSphereRuleType) == typeid (s))
      {
        if (n.name () == "IfThenSphereRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenSphereRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSphereRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenSphereRule (const ::xsd::qif2::IfThenSphereRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenSphereRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenSphereRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSphereRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenSphereRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenSphericalSegmentRuleType >
    _xsd_IfThenSphericalSegmentRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSphericalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenSphericalSegmentRule (::std::ostream& o,
                                const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::string& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphericalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSphericalSegmentRule (::std::ostream& o,
                                const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                ::xml_schema::error_handler& h,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::string& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphericalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphericalSegmentRule (::std::ostream& o,
                                const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::string& e,
                                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphericalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphericalSegmentRule (::xercesc::XMLFormatTarget& t,
                                const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::string& e,
                                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphericalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSphericalSegmentRule (::xercesc::XMLFormatTarget& t,
                                const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                ::xml_schema::error_handler& h,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::string& e,
                                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphericalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphericalSegmentRule (::xercesc::XMLFormatTarget& t,
                                const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::string& e,
                                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSphericalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSphericalSegmentRule (::xercesc::DOMDocument& d,
                                const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenSphericalSegmentRuleType) == typeid (s))
      {
        if (n.name () == "IfThenSphericalSegmentRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenSphericalSegmentRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSphericalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenSphericalSegmentRule (const ::xsd::qif2::IfThenSphericalSegmentRuleType& s,
                                const ::xml_schema::namespace_infomap& m,
                                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenSphericalSegmentRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenSphericalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSphericalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenSphericalSegmentRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    _xsd_IfThenSurfaceOfRevolutionRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenSurfaceOfRevolutionRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenSurfaceOfRevolutionRule (::std::ostream& o,
                                   const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSurfaceOfRevolutionRule (::std::ostream& o,
                                   const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   ::xml_schema::error_handler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceOfRevolutionRule (::std::ostream& o,
                                   const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceOfRevolutionRule (::xercesc::XMLFormatTarget& t,
                                   const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenSurfaceOfRevolutionRule (::xercesc::XMLFormatTarget& t,
                                   const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   ::xml_schema::error_handler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceOfRevolutionRule (::xercesc::XMLFormatTarget& t,
                                   const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::namespace_infomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenSurfaceOfRevolutionRule (::xercesc::DOMDocument& d,
                                   const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenSurfaceOfRevolutionRuleType) == typeid (s))
      {
        if (n.name () == "IfThenSurfaceOfRevolutionRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenSurfaceOfRevolutionRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSurfaceOfRevolutionRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenSurfaceOfRevolutionRule (const ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType& s,
                                   const ::xml_schema::namespace_infomap& m,
                                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenSurfaceOfRevolutionRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenSurfaceOfRevolutionRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenSurfaceOfRevolutionRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenSurfaceOfRevolutionRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenToroidalSegmentRuleType >
    _xsd_IfThenToroidalSegmentRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenToroidalSegmentRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenToroidalSegmentRule (::std::ostream& o,
                               const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenToroidalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenToroidalSegmentRule (::std::ostream& o,
                               const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               ::xml_schema::error_handler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenToroidalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenToroidalSegmentRule (::std::ostream& o,
                               const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenToroidalSegmentRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenToroidalSegmentRule (::xercesc::XMLFormatTarget& t,
                               const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenToroidalSegmentRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenToroidalSegmentRule (::xercesc::XMLFormatTarget& t,
                               const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               ::xml_schema::error_handler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenToroidalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenToroidalSegmentRule (::xercesc::XMLFormatTarget& t,
                               const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::string& e,
                               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenToroidalSegmentRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenToroidalSegmentRule (::xercesc::DOMDocument& d,
                               const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenToroidalSegmentRuleType) == typeid (s))
      {
        if (n.name () == "IfThenToroidalSegmentRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenToroidalSegmentRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenToroidalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenToroidalSegmentRule (const ::xsd::qif2::IfThenToroidalSegmentRuleType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenToroidalSegmentRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenToroidalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenToroidalSegmentRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenToroidalSegmentRule (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::IfThenTorusRuleType >
    _xsd_IfThenTorusRule_element_serializer_init (
      "IfThenFeatureRule",
      "http://qifstandards.org/xsd/qif2",
      "IfThenTorusRule",
      "http://qifstandards.org/xsd/qif2");


    void
    IfThenTorusRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenTorusRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenTorusRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenTorusRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenTorusRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenTorusRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenTorusRule (::std::ostream& o,
                     const ::xsd::qif2::IfThenTorusRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenTorusRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenTorusRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenTorusRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenTorusRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    IfThenTorusRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenTorusRuleType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenTorusRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenTorusRule (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::IfThenTorusRuleType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::IfThenTorusRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    IfThenTorusRule (::xercesc::DOMDocument& d,
                     const ::xsd::qif2::IfThenTorusRuleType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::IfThenTorusRuleType) == typeid (s))
      {
        if (n.name () == "IfThenTorusRule" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "IfThenTorusRule",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenTorusRule",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    IfThenTorusRule (const ::xsd::qif2::IfThenTorusRuleType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::IfThenTorusRuleType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "IfThenTorusRule",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "IfThenTorusRule",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::IfThenTorusRule (*d, s, f);
      return d;
    }

    void
    DMESelectionRule (::std::ostream& o,
                      const ::xsd::qif2::DMESelectionRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DMESelectionRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    DMESelectionRule (::std::ostream& o,
                      const ::xsd::qif2::DMESelectionRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DMESelectionRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DMESelectionRule (::std::ostream& o,
                      const ::xsd::qif2::DMESelectionRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DMESelectionRule (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DMESelectionRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::DMESelectionRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DMESelectionRule (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    DMESelectionRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::DMESelectionRuleType& s,
                      ::xml_schema::error_handler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DMESelectionRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DMESelectionRule (::xercesc::XMLFormatTarget& t,
                      const ::xsd::qif2::DMESelectionRuleType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::DMESelectionRule (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    DMESelectionRule (::xercesc::DOMDocument& d,
                      const ::xsd::qif2::DMESelectionRuleType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "DMESelectionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "DMESelectionRule",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    DMESelectionRule (const ::xsd::qif2::DMESelectionRuleType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "DMESelectionRule",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::DMESelectionRule (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

